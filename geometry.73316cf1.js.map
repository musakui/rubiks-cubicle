{"version":3,"file":"geometry.73316cf1.js","sources":["../node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js","../node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js","../node_modules/@babylonjs/core/Materials/prePassConfiguration.js","../node_modules/@babylonjs/core/Materials/pushMaterial.js","../node_modules/@babylonjs/core/Materials/thinMaterialHelper.js","../node_modules/@babylonjs/core/Materials/materialHelper.js","../node_modules/@babylonjs/core/Materials/Textures/thinTexture.js","../node_modules/@babylonjs/core/Materials/Textures/baseTexture.js","../node_modules/@babylonjs/core/Misc/copyTools.js","../node_modules/@babylonjs/core/Materials/Textures/texture.js","../node_modules/@babylonjs/core/Materials/materialFlags.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js","../node_modules/@babylonjs/core/Shaders/default.fragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js","../node_modules/@babylonjs/core/Shaders/default.vertex.js","../node_modules/@babylonjs/core/Materials/effectFallbacks.js","../node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js","../node_modules/@babylonjs/core/Materials/standardMaterial.js","../node_modules/@babylonjs/core/Meshes/instancedMesh.js","../node_modules/@babylonjs/core/Animations/runtimeAnimation.js","../node_modules/@babylonjs/core/Bones/bone.js","../node_modules/@babylonjs/core/Animations/animatable.js","../src/geometry.js"],"sourcesContent":["import { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nVertexData.CreateBox = function (options) {\r\n    var nbFaces = 6;\r\n    var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\r\n    var uvs = [];\r\n    var positions = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var depth = options.depth || options.size || 1;\r\n    var wrap = options.wrap || false;\r\n    var topBaseAt = (options.topBaseAt === void 0) ? 1 : options.topBaseAt;\r\n    var bottomBaseAt = (options.bottomBaseAt === void 0) ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    var topOrder = [2, 0, 3, 1];\r\n    var bottomOrder = [2, 0, 1, 3];\r\n    var topIndex = topOrder[topBaseAt];\r\n    var bottomIndex = bottomOrder[bottomBaseAt];\r\n    var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\r\n        var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\r\n        var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\r\n        var topFaceOrder = [17, 18, 19, 16];\r\n        var bottomFaceOrder = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    var scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce(function (accumulator, currentValue, currentIndex) { return accumulator.concat(currentValue * scaleArray[currentIndex % 3]); }, []);\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var faceUV = options.faceUV || new Array(6);\r\n    var faceColors = options.faceColors;\r\n    var colors = [];\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    // Create each face in turn.\r\n    for (var index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].y);\r\n        uvs.push(faceUV[index].z, faceUV[index].y);\r\n        if (faceColors) {\r\n            for (var c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n    return vertexData;\r\n};\r\nMesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        size: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return BoxBuilder.CreateBox(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar BoxBuilder = /** @class */ (function () {\r\n    function BoxBuilder() {\r\n    }\r\n    /**\r\n     * Creates a box mesh\r\n     * * The parameter `size` sets the size (float) of each box side (default 1)\r\n     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    BoxBuilder.CreateBox = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var box = new Mesh(name, scene);\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        box._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreateBox(options);\r\n        vertexData.applyToMesh(box, options.updatable);\r\n        return box;\r\n    };\r\n    return BoxBuilder;\r\n}());\r\nexport { BoxBuilder };\r\n//# sourceMappingURL=boxBuilder.js.map","import { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nVertexData.CreatePlane = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    // Vertices\r\n    var halfWidth = width / 2.0;\r\n    var halfHeight = height / 2.0;\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 0.0);\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 0.0);\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 1.0);\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 1.0);\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\nMesh.CreatePlane = function (name, size, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        size: size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return PlaneBuilder.CreatePlane(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar PlaneBuilder = /** @class */ (function () {\r\n    function PlaneBuilder() {\r\n    }\r\n    /**\r\n     * Creates a plane mesh\r\n     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n     */\r\n    PlaneBuilder.CreatePlane = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var plane = new Mesh(name, scene);\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        plane._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreatePlane(options);\r\n        vertexData.applyToMesh(plane, options.updatable);\r\n        if (options.sourcePlane) {\r\n            plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n            plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n        }\r\n        return plane;\r\n    };\r\n    return PlaneBuilder;\r\n}());\r\nexport { PlaneBuilder };\r\n//# sourceMappingURL=planeBuilder.js.map","import { Matrix } from \"../Maths/math.vector\";\r\n/**\r\n * Configuration needed for prepass-capable materials\r\n */\r\nvar PrePassConfiguration = /** @class */ (function () {\r\n    function PrePassConfiguration() {\r\n        /**\r\n         * Previous world matrices of meshes carrying this material\r\n         * Used for computing velocity\r\n         */\r\n        this.previousWorldMatrices = {};\r\n        /**\r\n         * Previous bones of meshes carrying this material\r\n         * Used for computing velocity\r\n         */\r\n        this.previousBones = {};\r\n    }\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    PrePassConfiguration.AddUniforms = function (uniforms) {\r\n        uniforms.push(\"previousWorld\", \"previousViewProjection\");\r\n    };\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    PrePassConfiguration.AddSamplers = function (samplers) {\r\n        // pass\r\n    };\r\n    /**\r\n     * Binds the material data.\r\n     * @param effect defines the effect to update\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param mesh The mesh\r\n     * @param world World matrix of this mesh\r\n     * @param isFrozen Is the material frozen\r\n     */\r\n    PrePassConfiguration.prototype.bindForSubMesh = function (effect, scene, mesh, world, isFrozen) {\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled) {\r\n            if (scene.prePassRenderer.getIndex(2) !== -1) {\r\n                if (!this.previousWorldMatrices[mesh.uniqueId]) {\r\n                    this.previousWorldMatrices[mesh.uniqueId] = Matrix.Identity();\r\n                }\r\n                if (!this.previousViewProjection) {\r\n                    this.previousViewProjection = scene.getTransformMatrix();\r\n                }\r\n                effect.setMatrix(\"previousWorld\", this.previousWorldMatrices[mesh.uniqueId]);\r\n                effect.setMatrix(\"previousViewProjection\", this.previousViewProjection);\r\n                this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n                this.previousViewProjection = scene.getTransformMatrix().clone();\r\n            }\r\n        }\r\n    };\r\n    return PrePassConfiguration;\r\n}());\r\nexport { PrePassConfiguration };\r\n//# sourceMappingURL=prePassConfiguration.js.map","import { __extends } from \"tslib\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Material } from \"../Materials/material\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\r\nvar PushMaterial = /** @class */ (function (_super) {\r\n    __extends(PushMaterial, _super);\r\n    function PushMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        _this._normalMatrix = new Matrix();\r\n        _this._storeEffectOnSubMeshes = true;\r\n        return _this;\r\n    }\r\n    PushMaterial.prototype.getEffect = function () {\r\n        return this._activeEffect;\r\n    };\r\n    PushMaterial.prototype.isReady = function (mesh, useInstances) {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    };\r\n    PushMaterial.prototype._isReadyForSubMesh = function (subMesh) {\r\n        var defines = subMesh._materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n    * Binds the given world matrix to the active effect\r\n    *\r\n    * @param world the matrix to bind\r\n    */\r\n    PushMaterial.prototype.bindOnlyWorldMatrix = function (world) {\r\n        this._activeEffect.setMatrix(\"world\", world);\r\n    };\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    PushMaterial.prototype.bindOnlyNormalMatrix = function (normalMatrix) {\r\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\r\n    };\r\n    PushMaterial.prototype.bind = function (world, mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    };\r\n    PushMaterial.prototype._afterBind = function (mesh, effect) {\r\n        if (effect === void 0) { effect = null; }\r\n        _super.prototype._afterBind.call(this, mesh);\r\n        this.getScene()._cachedEffect = effect;\r\n    };\r\n    PushMaterial.prototype._mustRebind = function (scene, effect, visibility) {\r\n        if (visibility === void 0) { visibility = 1; }\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    };\r\n    return PushMaterial;\r\n}(Material));\r\nexport { PushMaterial };\r\n//# sourceMappingURL=pushMaterial.js.map","/**\r\n * \"Static Class\" containing a few commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It is complementary with MaterialHelper but provides completely independent functions (for tree shaking sake)\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nvar ThinMaterialHelper = /** @class */ (function () {\r\n    function ThinMaterialHelper() {\r\n    }\r\n    /**\r\n     * Binds the clip plane information from the holder to the effect.\r\n     * @param effect The effect we are binding the data to\r\n     * @param holder The entity containing the clip plane information\r\n     */\r\n    ThinMaterialHelper.BindClipPlane = function (effect, holder) {\r\n        if (holder.clipPlane) {\r\n            var clipPlane = holder.clipPlane;\r\n            effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane2) {\r\n            var clipPlane = holder.clipPlane2;\r\n            effect.setFloat4(\"vClipPlane2\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane3) {\r\n            var clipPlane = holder.clipPlane3;\r\n            effect.setFloat4(\"vClipPlane3\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane4) {\r\n            var clipPlane = holder.clipPlane4;\r\n            effect.setFloat4(\"vClipPlane4\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane5) {\r\n            var clipPlane = holder.clipPlane5;\r\n            effect.setFloat4(\"vClipPlane5\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane6) {\r\n            var clipPlane = holder.clipPlane6;\r\n            effect.setFloat4(\"vClipPlane6\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n    };\r\n    return ThinMaterialHelper;\r\n}());\r\nexport { ThinMaterialHelper };\r\n//# sourceMappingURL=thinMaterialHelper.js.map","import { Logger } from \"../Misc/logger\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { ThinMaterialHelper } from './thinMaterialHelper';\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nvar MaterialHelper = /** @class */ (function () {\r\n    function MaterialHelper() {\r\n    }\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param scene The scene the eyes position is used from\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    MaterialHelper.BindEyePosition = function (effect, scene, variableName) {\r\n        if (variableName === void 0) { variableName = \"vEyePosition\"; }\r\n        if (scene._forcedViewPosition) {\r\n            effect.setVector3(variableName, scene._forcedViewPosition);\r\n            return;\r\n        }\r\n        var globalPosition = scene.activeCamera.globalPosition;\r\n        if (!globalPosition) {\r\n            // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\r\n            globalPosition = scene.activeCamera.devicePosition;\r\n        }\r\n        effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\r\n    };\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can accross channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            if (texture.coordinatesIndex === 0) {\r\n                defines[\"MAINUV1\"] = true;\r\n            }\r\n            else {\r\n                defines[\"MAINUV2\"] = true;\r\n            }\r\n        }\r\n        else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Binds a texture matrix value to its corrsponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receivin the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\r\n        var matrix = texture.getTextureMatrix();\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    };\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    MaterialHelper.GetFogState = function (mesh, scene) {\r\n        return (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE);\r\n    };\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    };\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, useClipPlane, useThinInstances) {\r\n        if (useClipPlane === void 0) { useClipPlane = null; }\r\n        if (useThinInstances === void 0) { useThinInstances = false; }\r\n        var changed = false;\r\n        var useClipPlane1 = false;\r\n        var useClipPlane2 = false;\r\n        var useClipPlane3 = false;\r\n        var useClipPlane4 = false;\r\n        var useClipPlane5 = false;\r\n        var useClipPlane6 = false;\r\n        useClipPlane1 = useClipPlane == null ? (scene.clipPlane !== undefined && scene.clipPlane !== null) : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? (scene.clipPlane2 !== undefined && scene.clipPlane2 !== null) : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? (scene.clipPlane3 !== undefined && scene.clipPlane3 !== null) : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? (scene.clipPlane4 !== undefined && scene.clipPlane4 !== null) : useClipPlane;\r\n        useClipPlane5 = useClipPlane == null ? (scene.clipPlane5 !== undefined && scene.clipPlane5 !== null) : useClipPlane;\r\n        useClipPlane6 = useClipPlane == null ? (scene.clipPlane6 !== undefined && scene.clipPlane6 !== null) : useClipPlane;\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\r\n            defines[\"CLIPPLANE5\"] = useClipPlane5;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\r\n            defines[\"CLIPPLANE6\"] = useClipPlane6;\r\n            changed = true;\r\n        }\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForBones = function (mesh, defines) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n            var materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            }\r\n            else {\r\n                defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n                var prePassRenderer = mesh.getScene().prePassRenderer;\r\n                if (prePassRenderer && prePassRenderer.enabled) {\r\n                    var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                    defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForMorphTargets = function (mesh, defines) {\r\n        var manager = mesh.morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n        }\r\n        else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha) {\r\n        if (useMorphTargets === void 0) { useMorphTargets = false; }\r\n        if (useVertexAlpha === void 0) { useVertexAlpha = true; }\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n        defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n        if (defines._needUVs) {\r\n            defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n            defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\r\n        }\r\n        else {\r\n            defines[\"UV1\"] = false;\r\n            defines[\"UV2\"] = false;\r\n        }\r\n        if (useVertexColor) {\r\n            var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForMultiview = function (scene, defines) {\r\n        if (scene.activeCamera) {\r\n            var previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = (scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1);\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    MaterialHelper.PrepareDefinesForPrePass = function (scene, defines, canRenderToMRT) {\r\n        var previousPrePass = defines.PREPASS;\r\n        if (!defines._arePrePassDirty) {\r\n            return;\r\n        }\r\n        var texturesList = [\r\n            {\r\n                type: 1,\r\n                define: \"PREPASS_POSITION\",\r\n                index: \"PREPASS_POSITION_INDEX\",\r\n            },\r\n            {\r\n                type: 2,\r\n                define: \"PREPASS_VELOCITY\",\r\n                index: \"PREPASS_VELOCITY_INDEX\",\r\n            },\r\n            {\r\n                type: 3,\r\n                define: \"PREPASS_REFLECTIVITY\",\r\n                index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n            },\r\n            {\r\n                type: 0,\r\n                define: \"PREPASS_IRRADIANCE\",\r\n                index: \"PREPASS_IRRADIANCE_INDEX\",\r\n            },\r\n            {\r\n                type: 6,\r\n                define: \"PREPASS_ALBEDO\",\r\n                index: \"PREPASS_ALBEDO_INDEX\",\r\n            },\r\n            {\r\n                type: 5,\r\n                define: \"PREPASS_DEPTHNORMAL\",\r\n                index: \"PREPASS_DEPTHNORMAL_INDEX\",\r\n            }\r\n        ];\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n            for (var i = 0; i < texturesList.length; i++) {\r\n                var index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n                if (index !== -1) {\r\n                    defines[texturesList[i].define] = true;\r\n                    defines[texturesList[i].index] = index;\r\n                }\r\n                else {\r\n                    defines[texturesList[i].define] = false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.PREPASS = false;\r\n            for (var i = 0; i < texturesList.length; i++) {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     */\r\n    MaterialHelper.PrepareDefinesForLight = function (scene, mesh, light, lightIndex, defines, specularSupported, state) {\r\n        state.needNormals = true;\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n        switch (light.falloffType) {\r\n            case Light.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            var shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                var shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY);\r\n        }\r\n        else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (disableLighting === void 0) { disableLighting = false; }\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n        var lightIndex = 0;\r\n        var state = {\r\n            needNormals: false,\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false\r\n        };\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {\r\n                var light = _a[_i];\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n        // Resetting all other lights if any\r\n        for (var index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCLOSEESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n        var caps = scene.getEngine().getCaps();\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n        defines[\"SHADOWFLOAT\"] = state.shadowEnabled &&\r\n            ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\r\n                (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n        return state.needNormals;\r\n    };\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    MaterialHelper.PrepareUniformsAndSamplersForLight = function (lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {\r\n        if (uniformBuffersList === void 0) { uniformBuffersList = null; }\r\n        if (updateOnlyBuffersList === void 0) { updateOnlyBuffersList = false; }\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n        if (updateOnlyBuffersList) {\r\n            return;\r\n        }\r\n        uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n        uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n     */\r\n    MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        var uniformsList;\r\n        var uniformBuffersList = null;\r\n        if (uniformsListOrOptions.uniformsNames) {\r\n            var options = uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        }\r\n        else {\r\n            uniformsList = uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n    };\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights, rank) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (rank === void 0) { rank = 0; }\r\n        var lightFallbackRank = 0;\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    MaterialHelper.PrepareAttributesForMorphTargetsInfluencers = function (attribs, mesh, influencers) {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\r\n        var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            var manager = mesh.morphTargetManager;\r\n            var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            var uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (var index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current efffect fallback strategy\r\n     */\r\n    MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs);\r\n        }\r\n    };\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     */\r\n    MaterialHelper.PushAttributesForInstances = function (attribs) {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n    };\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    };\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    MaterialHelper.BindLight = function (light, lightIndex, scene, effect, useSpecular, rebuildInParallel) {\r\n        if (rebuildInParallel === void 0) { rebuildInParallel = false; }\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\r\n    };\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights, rebuildInParallel) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (rebuildInParallel === void 0) { rebuildInParallel = false; }\r\n        var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n        for (var i = 0; i < len; i++) {\r\n            var light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\r\n        }\r\n    };\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    MaterialHelper.BindFogParameters = function (scene, mesh, effect, linearSpace) {\r\n        if (linearSpace === void 0) { linearSpace = false; }\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._tempFogColor);\r\n            }\r\n            else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    MaterialHelper.BindBonesParameters = function (mesh, effect, prePassConfiguration) {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            var skeleton = mesh.skeleton;\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                var boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            }\r\n            else {\r\n                var matrices = skeleton.getTransformMatrices(mesh);\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                    if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\r\n                        if (prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                        }\r\n                        MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    MaterialHelper._CopyBonesTransformationMatrices = function (source, target) {\r\n        target.set(source);\r\n        return target;\r\n    };\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\r\n        var manager = abstractMesh.morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    };\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    MaterialHelper.BindLogDepth = function (defines, effect, scene) {\r\n        if (defines[\"LOGARITHMICDEPTH\"]) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n    };\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param scene The scene the clip plane information are extracted from\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    MaterialHelper.BindClipPlane = function (effect, scene) {\r\n        ThinMaterialHelper.BindClipPlane(effect, scene);\r\n    };\r\n    MaterialHelper._TmpMorphInfluencers = { \"NUM_MORPH_INFLUENCERS\": 0 };\r\n    MaterialHelper._tempFogColor = Color3.Black();\r\n    return MaterialHelper;\r\n}());\r\nexport { MaterialHelper };\r\n//# sourceMappingURL=materialHelper.js.map","import { Size } from '../../Maths/math.size';\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nvar ThinTexture = /** @class */ (function () {\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap\r\n     */\r\n    function ThinTexture(internalTexture) {\r\n        this._wrapU = 1;\r\n        this._wrapV = 1;\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        this.wrapR = 1;\r\n        /**\r\n         * With compliant hardware and browser (supporting anisotropic filtering)\r\n         * this defines the level of anisotropic filtering in the texture.\r\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n         */\r\n        this.anisotropicFilteringLevel = 4;\r\n        /**\r\n         * Define the current state of the loading sequence when in delayed load mode.\r\n         */\r\n        this.delayLoadState = 0;\r\n        /** @hidden */\r\n        this._texture = null;\r\n        this._engine = null;\r\n        this._cachedSize = Size.Zero();\r\n        this._cachedBaseSize = Size.Zero();\r\n        this._texture = internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n    Object.defineProperty(ThinTexture.prototype, \"wrapU\", {\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        get: function () {\r\n            return this._wrapU;\r\n        },\r\n        set: function (value) {\r\n            this._wrapU = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"wrapV\", {\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        get: function () {\r\n            return this._wrapV;\r\n        },\r\n        set: function (value) {\r\n            this._wrapV = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"coordinatesMode\", {\r\n        /**\r\n         * How a texture is mapped.\r\n         * Unused in thin texture mode.\r\n         */\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"isCube\", {\r\n        /**\r\n         * Define if the texture is a cube texture or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.isCube;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.isCube = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"is3D\", {\r\n        /**\r\n         * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is3D;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is3D = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"is2DArray\", {\r\n        /**\r\n         * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is2DArray;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is2DArray = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    ThinTexture.prototype.getClassName = function () {\r\n        return \"ThinTexture\";\r\n    };\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    ThinTexture.prototype.isReady = function () {\r\n        if (this.delayLoadState === 4) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    ThinTexture.prototype.delayLoad = function () {\r\n    };\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the insternal texture\r\n     */\r\n    ThinTexture.prototype.getInternalTexture = function () {\r\n        return this._texture;\r\n    };\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    ThinTexture.prototype.getSize = function () {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n        return this._cachedSize;\r\n    };\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    ThinTexture.prototype.getBaseSize = function () {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    };\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    ThinTexture.prototype.updateSamplingMode = function (samplingMode) {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    ThinTexture.prototype.releaseInternalTexture = function () {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    ThinTexture.prototype.dispose = function () {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    };\r\n    return ThinTexture;\r\n}());\r\nexport { ThinTexture };\r\n//# sourceMappingURL=thinTexture.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { GUID } from '../../Misc/guid';\r\nimport \"../../Misc/fileTools\";\r\nimport { ThinTexture } from './thinTexture';\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nvar BaseTexture = /** @class */ (function (_super) {\r\n    __extends(BaseTexture, _super);\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture blongs to\r\n     */\r\n    function BaseTexture(sceneOrEngine) {\r\n        var _this = _super.call(this, null) || this;\r\n        /**\r\n         * Gets or sets an object used to store user defined information.\r\n         */\r\n        _this.metadata = null;\r\n        /**\r\n         * For internal use only. Please do not use.\r\n         */\r\n        _this.reservedDataStore = null;\r\n        _this._hasAlpha = false;\r\n        /**\r\n         * Defines if the alpha value should be determined via the rgb values.\r\n         * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n         */\r\n        _this.getAlphaFromRGB = false;\r\n        /**\r\n         * Intensity or strength of the texture.\r\n         * It is commonly used by materials to fine tune the intensity of the texture\r\n         */\r\n        _this.level = 1;\r\n        /**\r\n         * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n         * This is part of the texture as textures usually maps to one uv set.\r\n         */\r\n        _this.coordinatesIndex = 0;\r\n        _this._coordinatesMode = 0;\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        _this.wrapR = 1;\r\n        /**\r\n         * With compliant hardware and browser (supporting anisotropic filtering)\r\n         * this defines the level of anisotropic filtering in the texture.\r\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n         */\r\n        _this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n        _this._isCube = false;\r\n        _this._gammaSpace = true;\r\n        /**\r\n         * Is Z inverted in the texture (useful in a cube texture).\r\n         */\r\n        _this.invertZ = false;\r\n        /**\r\n         * @hidden\r\n         */\r\n        _this.lodLevelInAlpha = false;\r\n        /**\r\n         * Define if the texture is a render target.\r\n         */\r\n        _this.isRenderTarget = false;\r\n        /** @hidden */\r\n        _this._prefiltered = false;\r\n        /**\r\n         * Define the list of animation attached to the texture.\r\n         */\r\n        _this.animations = new Array();\r\n        /**\r\n        * An event triggered when the texture is disposed.\r\n        */\r\n        _this.onDisposeObservable = new Observable();\r\n        _this._onDisposeObserver = null;\r\n        _this._scene = null;\r\n        /** @hidden */\r\n        _this._texture = null;\r\n        _this._uid = null;\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._isScene(sceneOrEngine)) {\r\n                _this._scene = sceneOrEngine;\r\n            }\r\n            else {\r\n                _this._engine = sceneOrEngine;\r\n            }\r\n        }\r\n        else {\r\n            _this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n        if (_this._scene) {\r\n            _this.uniqueId = _this._scene.getUniqueId();\r\n            _this._scene.addTexture(_this);\r\n            _this._engine = _this._scene.getEngine();\r\n        }\r\n        _this._uid = null;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\r\n        get: function () {\r\n            return this._hasAlpha;\r\n        },\r\n        /**\r\n         * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n         */\r\n        set: function (value) {\r\n            if (this._hasAlpha === value) {\r\n                return;\r\n            }\r\n            this._hasAlpha = value;\r\n            if (this._scene) {\r\n                this._scene.markAllMaterialsAsDirty(1 | 16);\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\r\n        get: function () {\r\n            return this._coordinatesMode;\r\n        },\r\n        /**\r\n        * How a texture is mapped.\r\n        *\r\n        * | Value | Type                                | Description |\r\n        * | ----- | ----------------------------------- | ----------- |\r\n        * | 0     | EXPLICIT_MODE                       |             |\r\n        * | 1     | SPHERICAL_MODE                      |             |\r\n        * | 2     | PLANAR_MODE                         |             |\r\n        * | 3     | CUBIC_MODE                          |             |\r\n        * | 4     | PROJECTION_MODE                     |             |\r\n        * | 5     | SKYBOX_MODE                         |             |\r\n        * | 6     | INVCUBIC_MODE                       |             |\r\n        * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n        * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n        * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n        */\r\n        set: function (value) {\r\n            if (this._coordinatesMode === value) {\r\n                return;\r\n            }\r\n            this._coordinatesMode = value;\r\n            if (this._scene) {\r\n                this._scene.markAllMaterialsAsDirty(1);\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"wrapU\", {\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        get: function () {\r\n            return this._wrapU;\r\n        },\r\n        set: function (value) {\r\n            this._wrapU = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"wrapV\", {\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        get: function () {\r\n            return this._wrapV;\r\n        },\r\n        set: function (value) {\r\n            this._wrapV = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isCube\", {\r\n        /**\r\n         * Define if the texture is a cube texture or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._isCube;\r\n            }\r\n            return this._texture.isCube;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                this._isCube = value;\r\n            }\r\n            else {\r\n                this._texture.isCube = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"is3D\", {\r\n        /**\r\n         * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is3D;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is3D = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"is2DArray\", {\r\n        /**\r\n         * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is2DArray;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is2DArray = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"gammaSpace\", {\r\n        /**\r\n         * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n         * HDR texture are usually stored in linear space.\r\n         * This only impacts the PBR and Background materials\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._gammaSpace;\r\n            }\r\n            else {\r\n                if (this._texture._gammaSpace === null) {\r\n                    this._texture._gammaSpace = this._gammaSpace;\r\n                }\r\n            }\r\n            return this._texture._gammaSpace;\r\n        },\r\n        set: function (gamma) {\r\n            if (!this._texture) {\r\n                if (this._gammaSpace === gamma) {\r\n                    return;\r\n                }\r\n                this._gammaSpace = gamma;\r\n            }\r\n            else {\r\n                if (this._texture._gammaSpace === gamma) {\r\n                    return;\r\n                }\r\n                this._texture._gammaSpace = gamma;\r\n            }\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isRGBD\", {\r\n        /**\r\n         * Gets or sets whether or not the texture contains RGBD data.\r\n         */\r\n        get: function () {\r\n            return this._texture != null && this._texture._isRGBD;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._isRGBD = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"noMipmap\", {\r\n        /**\r\n         * Are mip maps generated for this texture or not.\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"lodGenerationOffset\", {\r\n        /**\r\n         * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodGenerationOffset;\r\n            }\r\n            return 0.0;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._lodGenerationOffset = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"lodGenerationScale\", {\r\n        /**\r\n         * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodGenerationScale;\r\n            }\r\n            return 0.0;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._lodGenerationScale = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"linearSpecularLOD\", {\r\n        /**\r\n         * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n         * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n         * average roughness values.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._linearSpecularLOD;\r\n            }\r\n            return false;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._linearSpecularLOD = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"irradianceTexture\", {\r\n        /**\r\n         * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n         * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n         * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._irradianceTexture;\r\n            }\r\n            return null;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._irradianceTexture = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"uid\", {\r\n        /**\r\n         * Define the unique id of the texture in the scene.\r\n         */\r\n        get: function () {\r\n            if (!this._uid) {\r\n                this._uid = GUID.RandomId();\r\n            }\r\n            return this._uid;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    BaseTexture.prototype.toString = function () {\r\n        return this.name;\r\n    };\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    BaseTexture.prototype.getClassName = function () {\r\n        return \"BaseTexture\";\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\r\n        /**\r\n         * Callback triggered when the texture has been disposed.\r\n         * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n         */\r\n        set: function (callback) {\r\n            if (this._onDisposeObserver) {\r\n                this.onDisposeObservable.remove(this._onDisposeObserver);\r\n            }\r\n            this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\r\n        /**\r\n         * Define if the texture is preventinga material to render or not.\r\n         * If not and the texture is not ready, the engine will use a default black texture instead.\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    BaseTexture.prototype.getScene = function () {\r\n        return this._scene;\r\n    };\r\n    /** @hidden */\r\n    BaseTexture.prototype._getEngine = function () {\r\n        return this._engine;\r\n    };\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    BaseTexture.prototype.checkTransformsAreIdentical = function (texture) {\r\n        return texture !== null;\r\n    };\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for istance.\r\n     * @returns the transformation matrix\r\n     */\r\n    BaseTexture.prototype.getTextureMatrix = function () {\r\n        return Matrix.IdentityReadOnly;\r\n    };\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    BaseTexture.prototype.getReflectionTextureMatrix = function () {\r\n        return Matrix.IdentityReadOnly;\r\n    };\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready or not blocking\r\n     */\r\n    BaseTexture.prototype.isReadyOrNotBlocking = function () {\r\n        return !this.isBlocking || this.isReady();\r\n    };\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    BaseTexture.prototype.scale = function (ratio) {\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\r\n        /**\r\n         * Get if the texture can rescale.\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @hidden */\r\n    BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling, invertY) {\r\n        var engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n        var texturesCache = engine.getLoadedTexturesCache();\r\n        for (var index = 0; index < texturesCache.length; index++) {\r\n            var texturesCacheEntry = texturesCache[index];\r\n            if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                    if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                        texturesCacheEntry.incrementReferences();\r\n                        return texturesCacheEntry;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /** @hidden */\r\n    BaseTexture.prototype._rebuild = function () {\r\n    };\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    BaseTexture.prototype.clone = function () {\r\n        return null;\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"textureType\", {\r\n        /**\r\n         * Get the texture underlying type (INT, FLOAT...)\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return 0;\r\n            }\r\n            return (this._texture.type !== undefined) ? this._texture.type : 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\r\n        /**\r\n         * Get the texture underlying format (RGB, RGBA...)\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return 5;\r\n            }\r\n            return (this._texture.format !== undefined) ? this._texture.format : 5;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    BaseTexture.prototype._markAllSubMeshesAsTexturesDirty = function () {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1);\r\n    };\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @returns The Array buffer containing the pixels data.\r\n     */\r\n    BaseTexture.prototype.readPixels = function (faceIndex, level, buffer) {\r\n        if (faceIndex === void 0) { faceIndex = 0; }\r\n        if (level === void 0) { level = 0; }\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        var engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\r\n            }\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureHigh;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureMid;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureLow;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    BaseTexture.prototype.dispose = function () {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n            // Remove from scene\r\n            this._scene._removePendingData(this);\r\n            var index = this._scene.textures.indexOf(this);\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n        }\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        _super.prototype.dispose.call(this);\r\n    };\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    BaseTexture.prototype.serialize = function () {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    BaseTexture.WhenAllReady = function (textures, callback) {\r\n        var numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n        for (var i = 0; i < textures.length; i++) {\r\n            var texture = textures[i];\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            }\r\n            else {\r\n                var onLoadObservable = texture.onLoadObservable;\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(function () {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    };\r\n    BaseTexture._isScene = function (sceneOrEngine) {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    };\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"uniqueId\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"name\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"metadata\", void 0);\r\n    __decorate([\r\n        serialize(\"hasAlpha\")\r\n    ], BaseTexture.prototype, \"_hasAlpha\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"getAlphaFromRGB\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"level\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"coordinatesIndex\", void 0);\r\n    __decorate([\r\n        serialize(\"coordinatesMode\")\r\n    ], BaseTexture.prototype, \"_coordinatesMode\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapU\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapV\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapR\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"isCube\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"is3D\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"is2DArray\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"gammaSpace\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"invertZ\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodGenerationOffset\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodGenerationScale\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"linearSpecularLOD\", null);\r\n    __decorate([\r\n        serializeAsTexture()\r\n    ], BaseTexture.prototype, \"irradianceTexture\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"isRenderTarget\", void 0);\r\n    return BaseTexture;\r\n}(ThinTexture));\r\nexport { BaseTexture };\r\n//# sourceMappingURL=baseTexture.js.map","/**\r\n * Class used to host copy specific utilities\r\n */\r\nvar CopyTools = /** @class */ (function () {\r\n    function CopyTools() {\r\n    }\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    CopyTools.GenerateBase64StringFromTexture = function (texture, faceIndex, level) {\r\n        if (faceIndex === void 0) { faceIndex = 0; }\r\n        if (level === void 0) { level = 0; }\r\n        var internalTexture = texture.getInternalTexture();\r\n        if (!internalTexture) {\r\n            return null;\r\n        }\r\n        var pixels = texture.readPixels(faceIndex, level);\r\n        if (!pixels) {\r\n            return null;\r\n        }\r\n        var size = texture.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        if (pixels instanceof Float32Array) {\r\n            var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n            var npixels = new Uint8Array(len);\r\n            while (--len >= 0) {\r\n                var val = pixels[len];\r\n                if (val < 0) {\r\n                    val = 0;\r\n                }\r\n                else if (val > 1) {\r\n                    val = 1;\r\n                }\r\n                npixels[len] = val * 255;\r\n            }\r\n            pixels = npixels;\r\n        }\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        var ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            return null;\r\n        }\r\n        var imageData = ctx.createImageData(width, height);\r\n        var castData = imageData.data;\r\n        castData.set(pixels);\r\n        ctx.putImageData(imageData, 0, 0);\r\n        if (internalTexture.invertY) {\r\n            var canvas2 = document.createElement('canvas');\r\n            canvas2.width = width;\r\n            canvas2.height = height;\r\n            var ctx2 = canvas2.getContext('2d');\r\n            if (!ctx2) {\r\n                return null;\r\n            }\r\n            ctx2.translate(0, height);\r\n            ctx2.scale(1, -1);\r\n            ctx2.drawImage(canvas, 0, 0);\r\n            return canvas2.toDataURL('image/png');\r\n        }\r\n        return canvas.toDataURL('image/png');\r\n    };\r\n    return CopyTools;\r\n}());\r\nexport { CopyTools };\r\n//# sourceMappingURL=copyTools.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { _DevTools } from '../../Misc/devTools';\r\nimport { TimingTools } from '../../Misc/timingTools';\r\nimport { InstantiationTools } from '../../Misc/instantiationTools';\r\nimport { Plane } from '../../Maths/math.plane';\r\nimport { StringTools } from '../../Misc/stringTools';\r\nimport { CopyTools } from '../../Misc/copyTools';\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n */\r\nvar Texture = /** @class */ (function (_super) {\r\n    __extends(Texture, _super);\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmap defines if the texture will require mip maps or not\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     */\r\n    function Texture(url, sceneOrEngine, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions) {\r\n        if (noMipmap === void 0) { noMipmap = false; }\r\n        if (invertY === void 0) { invertY = true; }\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (deleteBuffer === void 0) { deleteBuffer = false; }\r\n        var _this = _super.call(this, sceneOrEngine) || this;\r\n        /**\r\n         * Define the url of the texture.\r\n         */\r\n        _this.url = null;\r\n        /**\r\n         * Define an offset on the texture to offset the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n         */\r\n        _this.uOffset = 0;\r\n        /**\r\n         * Define an offset on the texture to offset the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n         */\r\n        _this.vOffset = 0;\r\n        /**\r\n         * Define an offset on the texture to scale the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n         */\r\n        _this.uScale = 1.0;\r\n        /**\r\n         * Define an offset on the texture to scale the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n         */\r\n        _this.vScale = 1.0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.uAng = 0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.vAng = 0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.wAng = 0;\r\n        /**\r\n         * Defines the center of rotation (U)\r\n         */\r\n        _this.uRotationCenter = 0.5;\r\n        /**\r\n         * Defines the center of rotation (V)\r\n         */\r\n        _this.vRotationCenter = 0.5;\r\n        /**\r\n         * Defines the center of rotation (W)\r\n         */\r\n        _this.wRotationCenter = 0.5;\r\n        /**\r\n         * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n         */\r\n        _this.homogeneousRotationInUVTransform = false;\r\n        /**\r\n         * List of inspectable custom properties (used by the Inspector)\r\n         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n         */\r\n        _this.inspectableCustomProperties = null;\r\n        _this._noMipmap = false;\r\n        /** @hidden */\r\n        _this._invertY = false;\r\n        _this._rowGenerationMatrix = null;\r\n        _this._cachedTextureMatrix = null;\r\n        _this._projectionModeMatrix = null;\r\n        _this._t0 = null;\r\n        _this._t1 = null;\r\n        _this._t2 = null;\r\n        _this._cachedUOffset = -1;\r\n        _this._cachedVOffset = -1;\r\n        _this._cachedUScale = 0;\r\n        _this._cachedVScale = 0;\r\n        _this._cachedUAng = -1;\r\n        _this._cachedVAng = -1;\r\n        _this._cachedWAng = -1;\r\n        _this._cachedProjectionMatrixId = -1;\r\n        _this._cachedURotationCenter = -1;\r\n        _this._cachedVRotationCenter = -1;\r\n        _this._cachedWRotationCenter = -1;\r\n        _this._cachedHomogeneousRotationInUVTransform = false;\r\n        _this._cachedCoordinatesMode = -1;\r\n        /** @hidden */\r\n        _this._initialSamplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n        /** @hidden */\r\n        _this._buffer = null;\r\n        _this._deleteBuffer = false;\r\n        _this._format = null;\r\n        _this._delayedOnLoad = null;\r\n        _this._delayedOnError = null;\r\n        /**\r\n         * Observable triggered once the texture has been loaded.\r\n         */\r\n        _this.onLoadObservable = new Observable();\r\n        _this._isBlocking = true;\r\n        _this.name = url || \"\";\r\n        _this.url = url;\r\n        _this._noMipmap = noMipmap;\r\n        _this._invertY = invertY;\r\n        _this._initialSamplingMode = samplingMode;\r\n        _this._buffer = buffer;\r\n        _this._deleteBuffer = deleteBuffer;\r\n        _this._mimeType = mimeType;\r\n        _this._loaderOptions = loaderOptions;\r\n        if (format) {\r\n            _this._format = format;\r\n        }\r\n        var scene = _this.getScene();\r\n        var engine = _this._getEngine();\r\n        if (!engine) {\r\n            return _this;\r\n        }\r\n        engine.onBeforeTextureInitObservable.notifyObservers(_this);\r\n        var load = function () {\r\n            if (_this._texture) {\r\n                if (_this._texture._invertVScale) {\r\n                    _this.vScale *= -1;\r\n                    _this.vOffset += 1;\r\n                }\r\n                // Update texutre to match internal texture's wrapping\r\n                if (_this._texture._cachedWrapU !== null) {\r\n                    _this.wrapU = _this._texture._cachedWrapU;\r\n                    _this._texture._cachedWrapU = null;\r\n                }\r\n                if (_this._texture._cachedWrapV !== null) {\r\n                    _this.wrapV = _this._texture._cachedWrapV;\r\n                    _this._texture._cachedWrapV = null;\r\n                }\r\n                if (_this._texture._cachedWrapR !== null) {\r\n                    _this.wrapR = _this._texture._cachedWrapR;\r\n                    _this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n            if (_this.onLoadObservable.hasObservers()) {\r\n                _this.onLoadObservable.notifyObservers(_this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n            if (!_this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n        if (!_this.url) {\r\n            _this._delayedOnLoad = load;\r\n            _this._delayedOnError = onError;\r\n            return _this;\r\n        }\r\n        _this._texture = _this._getFromCache(_this.url, noMipmap, samplingMode, invertY);\r\n        if (!_this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                _this._texture = engine.createTexture(_this.url, noMipmap, invertY, scene, samplingMode, load, onError, _this._buffer, undefined, _this._format, null, mimeType, loaderOptions);\r\n                if (deleteBuffer) {\r\n                    _this._buffer = null;\r\n                }\r\n            }\r\n            else {\r\n                _this.delayLoadState = 4;\r\n                _this._delayedOnLoad = load;\r\n                _this._delayedOnError = onError;\r\n            }\r\n        }\r\n        else {\r\n            if (_this._texture.isReady) {\r\n                TimingTools.SetImmediate(function () { return load(); });\r\n            }\r\n            else {\r\n                _this._texture.onLoadedObservable.add(load);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Texture.prototype, \"noMipmap\", {\r\n        /**\r\n         * Are mip maps generated for this texture or not.\r\n         */\r\n        get: function () {\r\n            return this._noMipmap;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"mimeType\", {\r\n        /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n        get: function () {\r\n            return this._mimeType;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"isBlocking\", {\r\n        get: function () {\r\n            return this._isBlocking;\r\n        },\r\n        /**\r\n         * Is the texture preventing material to render while loading.\r\n         * If false, a default texture will be used instead of the loading one during the preparation step.\r\n         */\r\n        set: function (value) {\r\n            this._isBlocking = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"samplingMode\", {\r\n        /**\r\n         * Get the current sampling mode associated with the texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._initialSamplingMode;\r\n            }\r\n            return this._texture.samplingMode;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"invertY\", {\r\n        /**\r\n         * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n         */\r\n        get: function () {\r\n            return this._invertY;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     */\r\n    Texture.prototype.updateURL = function (url, buffer, onLoad) {\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene().markAllMaterialsAsDirty(1);\r\n        }\r\n        if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this.delayLoadState = 4;\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    };\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @hidden\r\n     */\r\n    Texture.prototype.delayLoad = function () {\r\n        if (this.delayLoadState !== 4) {\r\n            return;\r\n        }\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.delayLoadState = 1;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY);\r\n        if (!this._texture) {\r\n            this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions);\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        }\r\n        else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                }\r\n                else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    };\r\n    Texture.prototype._prepareRowForTextureGeneration = function (x, y, z, t) {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    };\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    Texture.prototype.checkTransformsAreIdentical = function (texture) {\r\n        return texture !== null &&\r\n            this.uOffset === texture.uOffset &&\r\n            this.vOffset === texture.vOffset &&\r\n            this.uScale === texture.uScale &&\r\n            this.vScale === texture.vScale &&\r\n            this.uAng === texture.uAng &&\r\n            this.vAng === texture.vAng &&\r\n            this.wAng === texture.wAng;\r\n    };\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    Texture.prototype.getTextureMatrix = function (uBase) {\r\n        var _this = this;\r\n        if (uBase === void 0) { uBase = 1; }\r\n        if (this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        }\r\n        else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);\r\n            this._t1.subtractInPlace(this._t0);\r\n            this._t2.subtractInPlace(this._t0);\r\n            Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0.0, this._t2.x, this._t2.y, this._t2.z, 0.0, this._t0.x, this._t0.y, this._t0.z, 0.0, 0.0, 0.0, 0.0, 1.0, this._cachedTextureMatrix);\r\n        }\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1, function (mat) {\r\n            return mat.hasTexture(_this);\r\n        });\r\n        return this._cachedTextureMatrix;\r\n    };\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    Texture.prototype.getReflectionTextureMatrix = function () {\r\n        var _this = this;\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        if (this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.coordinatesMode === this._cachedCoordinatesMode) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedTextureMatrix;\r\n                }\r\n            }\r\n            else {\r\n                return this._cachedTextureMatrix;\r\n            }\r\n        }\r\n        if (!this._cachedTextureMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n        }\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedCoordinatesMode = this.coordinatesMode;\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                this._cachedTextureMatrix[0] = this.uScale;\r\n                this._cachedTextureMatrix[5] = this.vScale;\r\n                this._cachedTextureMatrix[12] = this.uOffset;\r\n                this._cachedTextureMatrix[13] = this.vOffset;\r\n                break;\r\n            case Texture.PROJECTION_MODE:\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n                var projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\r\n                break;\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                break;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1, function (mat) {\r\n            return (mat.getActiveTextures().indexOf(_this) !== -1);\r\n        });\r\n        return this._cachedTextureMatrix;\r\n    };\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    Texture.prototype.clone = function () {\r\n        var _this = this;\r\n        return SerializationHelper.Clone(function () {\r\n            return new Texture(_this._texture ? _this._texture.url : null, _this.getScene(), _this._noMipmap, _this._invertY, _this.samplingMode, undefined, undefined, _this._texture ? _this._texture._buffer : undefined);\r\n        }, this);\r\n    };\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    Texture.prototype.serialize = function () {\r\n        var savedName = this.name;\r\n        if (!Texture.SerializeBuffers) {\r\n            if (StringTools.StartsWith(this.name, \"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n        if (StringTools.StartsWith(this.name, \"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n        var serializationObject = _super.prototype.serialize.call(this);\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && this._buffer.substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            }\r\n            else if (this.url && StringTools.StartsWith(this.url, \"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + StringTools.EncodeArrayBufferToBase64(this._buffer);\r\n            }\r\n            else if (Texture.ForceSerializeBuffers) {\r\n                serializationObject.base64String = CopyTools.GenerateBase64StringFromTexture(this);\r\n            }\r\n        }\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        this.name = savedName;\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    Texture.prototype.getClassName = function () {\r\n        return \"Texture\";\r\n    };\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    Texture.prototype.dispose = function () {\r\n        _super.prototype.dispose.call(this);\r\n        this.onLoadObservable.clear();\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    };\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    Texture.Parse = function (parsedTexture, scene, rootUrl) {\r\n        if (parsedTexture.customType) {\r\n            var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            return null;\r\n        }\r\n        var onLoaded = function () {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                var sampling = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    var parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var texture = SerializationHelper.Parse(function () {\r\n            var generateMipMaps = true;\r\n            if (parsedTexture.noMipmap) {\r\n                generateMipMaps = false;\r\n            }\r\n            if (parsedTexture.mirrorPlane) {\r\n                var mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                onLoaded();\r\n                return mirrorTexture;\r\n            }\r\n            else if (parsedTexture.isRenderTarget) {\r\n                var renderTargetTexture = null;\r\n                if (parsedTexture.isCube) {\r\n                    // Search for an existing reflection probe (which contains a cube render target texture)\r\n                    if (scene.reflectionProbes) {\r\n                        for (var index = 0; index < scene.reflectionProbes.length; index++) {\r\n                            var probe = scene.reflectionProbes[index];\r\n                            if (probe.name === parsedTexture.name) {\r\n                                return probe.cubeTexture;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                }\r\n                onLoaded();\r\n                return renderTargetTexture;\r\n            }\r\n            else {\r\n                var texture;\r\n                if (parsedTexture.base64String) {\r\n                    texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, undefined, onLoaded);\r\n                }\r\n                else {\r\n                    var url = void 0;\r\n                    if (parsedTexture.name && parsedTexture.name.indexOf(\"://\") > 0) {\r\n                        url = parsedTexture.name;\r\n                    }\r\n                    else {\r\n                        url = rootUrl + parsedTexture.name;\r\n                    }\r\n                    if (StringTools.StartsWith(parsedTexture.url, \"data:\") || (Texture.UseSerializedUrlIfAny && parsedTexture.url)) {\r\n                        url = parsedTexture.url;\r\n                    }\r\n                    texture = new Texture(url, scene, !generateMipMaps, parsedTexture.invertY, undefined, onLoaded);\r\n                }\r\n                return texture;\r\n            }\r\n        }, parsedTexture, scene);\r\n        return texture;\r\n    };\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    Texture.CreateFromBase64String = function (data, name, scene, noMipmap, invertY, samplingMode, onLoad, onError, format) {\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (format === void 0) { format = 5; }\r\n        return new Texture(\"data:\" + name, scene, noMipmap, invertY, samplingMode, onLoad, onError, data, false, format);\r\n    };\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    Texture.LoadFromDataString = function (name, buffer, scene, deleteBuffer, noMipmap, invertY, samplingMode, onLoad, onError, format) {\r\n        if (deleteBuffer === void 0) { deleteBuffer = false; }\r\n        if (noMipmap === void 0) { noMipmap = false; }\r\n        if (invertY === void 0) { invertY = true; }\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (format === void 0) { format = 5; }\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n        return new Texture(name, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format);\r\n    };\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    Texture.SerializeBuffers = true;\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    Texture.ForceSerializeBuffers = false;\r\n    /** @hidden */\r\n    Texture._CubeTextureParser = function (jsonTexture, scene, rootUrl) {\r\n        throw _DevTools.WarnImport(\"CubeTexture\");\r\n    };\r\n    /** @hidden */\r\n    Texture._CreateMirror = function (name, renderTargetSize, scene, generateMipMaps) {\r\n        throw _DevTools.WarnImport(\"MirrorTexture\");\r\n    };\r\n    /** @hidden */\r\n    Texture._CreateRenderTargetTexture = function (name, renderTargetSize, scene, generateMipMaps) {\r\n        throw _DevTools.WarnImport(\"RenderTargetTexture\");\r\n    };\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    Texture.NEAREST_SAMPLINGMODE = 1;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    Texture.NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    Texture.BILINEAR_SAMPLINGMODE = 2;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    Texture.LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    Texture.TRILINEAR_SAMPLINGMODE = 3;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    Texture.LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    Texture.NEAREST_NEAREST_MIPNEAREST = 4;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    Texture.NEAREST_LINEAR_MIPNEAREST = 5;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    Texture.NEAREST_LINEAR_MIPLINEAR = 6;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    Texture.NEAREST_LINEAR = 7;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    Texture.NEAREST_NEAREST = 1;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    Texture.LINEAR_NEAREST_MIPNEAREST = 9;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    Texture.LINEAR_NEAREST_MIPLINEAR = 10;\r\n    /** mag = linear and min = linear and mip = none */\r\n    Texture.LINEAR_LINEAR = 2;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    Texture.LINEAR_NEAREST = 12;\r\n    /** Explicit coordinates mode */\r\n    Texture.EXPLICIT_MODE = 0;\r\n    /** Spherical coordinates mode */\r\n    Texture.SPHERICAL_MODE = 1;\r\n    /** Planar coordinates mode */\r\n    Texture.PLANAR_MODE = 2;\r\n    /** Cubic coordinates mode */\r\n    Texture.CUBIC_MODE = 3;\r\n    /** Projection coordinates mode */\r\n    Texture.PROJECTION_MODE = 4;\r\n    /** Inverse Cubic coordinates mode */\r\n    Texture.SKYBOX_MODE = 5;\r\n    /** Inverse Cubic coordinates mode */\r\n    Texture.INVCUBIC_MODE = 6;\r\n    /** Equirectangular coordinates mode */\r\n    Texture.EQUIRECTANGULAR_MODE = 7;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    Texture.FIXED_EQUIRECTANGULAR_MODE = 8;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    Texture.CLAMP_ADDRESSMODE = 0;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    Texture.WRAP_ADDRESSMODE = 1;\r\n    /** Texture is repeating and mirrored */\r\n    Texture.MIRROR_ADDRESSMODE = 2;\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    Texture.UseSerializedUrlIfAny = false;\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"url\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uScale\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vScale\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"wAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"wRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"homogeneousRotationInUVTransform\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"isBlocking\", null);\r\n    return Texture;\r\n}(BaseTexture));\r\nexport { Texture };\r\n// References the dependencies.\r\n_TypeStore.RegisteredTypes[\"BABYLON.Texture\"] = Texture;\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n//# sourceMappingURL=texture.js.map","import { Engine } from \"../Engines/engine\";\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nvar MaterialFlags = /** @class */ (function () {\r\n    function MaterialFlags() {\r\n    }\r\n    Object.defineProperty(MaterialFlags, \"DiffuseTextureEnabled\", {\r\n        /**\r\n         * Are diffuse textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._DiffuseTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._DiffuseTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._DiffuseTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"DetailTextureEnabled\", {\r\n        /**\r\n         * Are detail textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._DetailTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._DetailTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._DetailTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"AmbientTextureEnabled\", {\r\n        /**\r\n         * Are ambient textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._AmbientTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._AmbientTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._AmbientTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"OpacityTextureEnabled\", {\r\n        /**\r\n         * Are opacity textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._OpacityTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._OpacityTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._OpacityTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ReflectionTextureEnabled\", {\r\n        /**\r\n         * Are reflection textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ReflectionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ReflectionTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ReflectionTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"EmissiveTextureEnabled\", {\r\n        /**\r\n         * Are emissive textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._EmissiveTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._EmissiveTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._EmissiveTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"SpecularTextureEnabled\", {\r\n        /**\r\n         * Are specular textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._SpecularTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._SpecularTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._SpecularTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"BumpTextureEnabled\", {\r\n        /**\r\n         * Are bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._BumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._BumpTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._BumpTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"LightmapTextureEnabled\", {\r\n        /**\r\n         * Are lightmap textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._LightmapTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._LightmapTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._LightmapTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"RefractionTextureEnabled\", {\r\n        /**\r\n         * Are refraction textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._RefractionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._RefractionTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._RefractionTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ColorGradingTextureEnabled\", {\r\n        /**\r\n         * Are color grading textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ColorGradingTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ColorGradingTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ColorGradingTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"FresnelEnabled\", {\r\n        /**\r\n         * Are fresnels enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._FresnelEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._FresnelEnabled === value) {\r\n                return;\r\n            }\r\n            this._FresnelEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(4);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatTextureEnabled\", {\r\n        /**\r\n         * Are clear coat textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatBumpTextureEnabled\", {\r\n        /**\r\n         * Are clear coat bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatBumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatBumpTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatBumpTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatTintTextureEnabled\", {\r\n        /**\r\n         * Are clear coat tint textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatTintTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatTintTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatTintTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"SheenTextureEnabled\", {\r\n        /**\r\n         * Are sheen textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._SheenTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._SheenTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._SheenTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"AnisotropicTextureEnabled\", {\r\n        /**\r\n         * Are anisotropic textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._AnisotropicTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._AnisotropicTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._AnisotropicTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ThicknessTextureEnabled\", {\r\n        /**\r\n         * Are thickness textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ThicknessTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ThicknessTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ThicknessTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    MaterialFlags._DiffuseTextureEnabled = true;\r\n    MaterialFlags._DetailTextureEnabled = true;\r\n    MaterialFlags._AmbientTextureEnabled = true;\r\n    MaterialFlags._OpacityTextureEnabled = true;\r\n    MaterialFlags._ReflectionTextureEnabled = true;\r\n    MaterialFlags._EmissiveTextureEnabled = true;\r\n    MaterialFlags._SpecularTextureEnabled = true;\r\n    MaterialFlags._BumpTextureEnabled = true;\r\n    MaterialFlags._LightmapTextureEnabled = true;\r\n    MaterialFlags._RefractionTextureEnabled = true;\r\n    MaterialFlags._ColorGradingTextureEnabled = true;\r\n    MaterialFlags._FresnelEnabled = true;\r\n    MaterialFlags._ClearCoatTextureEnabled = true;\r\n    MaterialFlags._ClearCoatBumpTextureEnabled = true;\r\n    MaterialFlags._ClearCoatTintTextureEnabled = true;\r\n    MaterialFlags._SheenTextureEnabled = true;\r\n    MaterialFlags._AnisotropicTextureEnabled = true;\r\n    MaterialFlags._ThicknessTextureEnabled = true;\r\n    return MaterialFlags;\r\n}());\r\nexport { MaterialFlags };\r\n//# sourceMappingURL=materialFlags.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultFragmentDeclaration';\r\nvar shader = \"uniform vec4 vDiffuseColor;\\n#ifdef SPECULARTERM\\nuniform vec4 vSpecularColor;\\n#endif\\nuniform vec3 vEmissiveColor;\\nuniform float visibility;\\n\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\n#ifndef REFRACTIONMAP_3D\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nuniform vec4 refractionLeftColor;\\nuniform vec4 refractionRightColor;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nuniform vec4 diffuseLeftColor;\\nuniform vec4 diffuseRightColor;\\n#endif\\n#ifdef OPACITYFRESNEL\\nuniform vec4 opacityParts;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nuniform vec4 emissiveLeftColor;\\nuniform vec4 emissiveRightColor;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifndef REFLECTIONMAP_SKYBOX\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize;\\n#endif\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 reflectionLeftColor;\\nuniform vec4 reflectionRightColor;\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultUboDeclaration';\r\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nvec4 diffuseLeftColor;\\nvec4 diffuseRightColor;\\nvec4 opacityParts;\\nvec4 reflectionLeftColor;\\nvec4 reflectionRightColor;\\nvec4 refractionLeftColor;\\nvec4 refractionRightColor;\\nvec4 emissiveLeftColor;\\nvec4 emissiveRightColor;\\nvec2 vDiffuseInfos;\\nvec2 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vReflectionInfos;\\nvec3 vReflectionPosition;\\nvec3 vReflectionSize;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec2 vSpecularInfos;\\nvec3 vBumpInfos;\\nmat4 diffuseMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 reflectionMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 specularMatrix;\\nmat4 bumpMatrix;\\nvec2 vTangentSpaceParams;\\nfloat pointSize;\\nmat4 refractionMatrix;\\nvec4 vRefractionInfos;\\nvec4 vSpecularColor;\\nvec3 vEmissiveColor;\\nfloat visibility;\\nvec4 vDiffuseColor;\\nvec4 vDetailInfos;\\nmat4 detailMatrix;\\n};\\nuniform Scene {\\nmat4 viewProjection;\\n#ifdef MULTIVIEW\\nmat4 viewProjectionR;\\n#endif\\nmat4 view;\\n};\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultUboDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultUboDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassDeclaration';\r\nvar shader = \"#ifdef PREPASS\\n#extension GL_EXT_draw_buffers : require\\n#ifdef WEBGL2\\nlayout(location=0) out highp vec4 glFragData[{X}];\\nhighp vec4 gl_FragColor;\\n#endif\\n#ifdef PREPASS_DEPTHNORMAL\\nvarying highp vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvarying highp vec4 vCurrentPosition;\\nvarying highp vec4 vPreviousPosition;\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'helperFunctions';\r\nvar shader = \"const float PI=3.1415926535897932384626433832795;\\nconst float HALF_MIN=5.96046448e-08;\\nconst float LinearEncodePowerApprox=2.2;\\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\\nconst float Epsilon=0.0000001;\\n#define saturate(x) clamp(x,0.0,1.0)\\n#define absEps(x) abs(x)+Epsilon\\n#define maxEps(x) max(x,Epsilon)\\n#define saturateEps(x) clamp(x,Epsilon,1.0)\\nmat3 transposeMat3(mat3 inMatrix) {\\nvec3 i0=inMatrix[0];\\nvec3 i1=inMatrix[1];\\nvec3 i2=inMatrix[2];\\nmat3 outMatrix=mat3(\\nvec3(i0.x,i1.x,i2.x),\\nvec3(i0.y,i1.y,i2.y),\\nvec3(i0.z,i1.z,i2.z)\\n);\\nreturn outMatrix;\\n}\\n\\nmat3 inverseMat3(mat3 inMatrix) {\\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\\nfloat b01=a22*a11-a12*a21;\\nfloat b11=-a22*a10+a12*a20;\\nfloat b21=a21*a10-a11*a20;\\nfloat det=a00*b01+a01*b11+a02*b21;\\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\\n}\\nfloat toLinearSpace(float color)\\n{\\nreturn pow(color,LinearEncodePowerApprox);\\n}\\nvec3 toLinearSpace(vec3 color)\\n{\\nreturn pow(color,vec3(LinearEncodePowerApprox));\\n}\\nvec4 toLinearSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\\n}\\nvec3 toGammaSpace(vec3 color)\\n{\\nreturn pow(color,vec3(GammaEncodePowerApprox));\\n}\\nvec4 toGammaSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\\n}\\nfloat toGammaSpace(float color)\\n{\\nreturn pow(color,GammaEncodePowerApprox);\\n}\\nfloat square(float value)\\n{\\nreturn value*value;\\n}\\nfloat pow5(float value) {\\nfloat sq=value*value;\\nreturn sq*sq*value;\\n}\\nfloat getLuminance(vec3 color)\\n{\\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\\n}\\n\\nfloat getRand(vec2 seed) {\\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\\n}\\nfloat dither(vec2 seed,float varianceAmount) {\\nfloat rand=getRand(seed);\\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\\nreturn dither;\\n}\\n\\nconst float rgbdMaxRange=255.0;\\nvec4 toRGBD(vec3 color) {\\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\\nfloat D=max(rgbdMaxRange/maxRGB,1.);\\nD=clamp(floor(D)/255.0,0.,1.);\\n\\nvec3 rgb=color.rgb*D;\\n\\nrgb=toGammaSpace(rgb);\\nreturn vec4(rgb,D);\\n}\\nvec3 fromRGBD(vec4 rgbd) {\\n\\nrgbd.rgb=toLinearSpace(rgbd.rgb);\\n\\nreturn rgbd.rgb/rgbd.a;\\n}\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var helperFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=helperFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightFragmentDeclaration';\r\nvar shader = \"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec4 vLightSpecular{X};\\n#else\\nvec4 vLightSpecular{X}=vec4(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec4 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\nuniform vec4 vLightFalloff{X};\\n#elif defined(POINTLIGHT{X})\\nuniform vec4 vLightFalloff{X};\\n#elif defined(HEMILIGHT{X})\\nuniform vec3 vLightGround{X};\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=lightFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightUboDeclaration';\r\nvar shader = \"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec4 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\nvec4 vLightFalloff;\\n#elif defined(POINTLIGHT{X})\\nvec4 vLightFalloff;\\n#elif defined(HEMILIGHT{X})\\nvec3 vLightGround;\\n#endif\\nvec4 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightUboDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=lightUboDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightsFragmentFunctions';\r\nvar shader = \"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef NDOTL\\nfloat ndl;\\n#endif\\n};\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 lightVectorW;\\nfloat attenuation=1.0;\\nif (lightData.w == 0.)\\n{\\nvec3 direction=lightData.xyz-vPositionW;\\nattenuation=max(0.,1.0-length(direction)/range);\\nlightVectorW=normalize(direction);\\n}\\nelse\\n{\\nlightVectorW=normalize(-lightData.xyz);\\n}\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 direction=lightData.xyz-vPositionW;\\nvec3 lightVectorW=normalize(direction);\\nfloat attenuation=max(0.,1.0-length(direction)/range);\\n\\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\\nif (cosAngle>=lightDirection.w)\\n{\\ncosAngle=max(0.,pow(cosAngle,lightData.w));\\nattenuation*=cosAngle;\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nresult.diffuse=vec3(0.);\\n#ifdef SPECULARTERM\\nresult.specular=vec3(0.);\\n#endif\\n#ifdef NDOTL\\nresult.ndl=0.;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\\nlightingInfo result;\\n\\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor;\\n#endif\\nreturn result;\\n}\\n#define inline\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn textureColor;\\n}\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightsFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=lightsFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'shadowsFragmentFunctions';\r\nvar shader = \"#ifdef SHADOWS\\n#ifndef SHADOWFLOAT\\n\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\\n{\\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\\nreturn mix(value,1.0,mask);\\n}\\n#define inline\\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nreturn depth>shadow ? darkness : 1.0;\\n}\\n#define inline\\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\nfloat visibility=1.;\\nvec3 poissonDisk[4];\\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\\n#else\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\n#define inline\\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn esm;\\n}\\n#define inline\\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn esm;\\n}\\n#ifdef WEBGL2\\n#define inline\\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\\n#else\\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n#endif\\n#define inline\\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadow=texture2D(shadowSampler,uv).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n}\\n#define inline\\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\nfloat visibility=1.;\\nvec2 poissonDisk[4];\\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\\npoissonDisk[3]=vec2(0.34495938,0.29387760);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\\n#else\\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\n#endif\\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#ifdef WEBGL2\\n#define GREATEST_LESS_THAN_ONE 0.99999994\\n\\n#define inline\\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat shadow=texture(shadowSampler,uvDepthLayer);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\n\\n\\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n#define inline\\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat shadow=texture2D(shadowSampler,uvDepth);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\n\\n\\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\nconst vec3 PoissonSamplers32[64]=vec3[64](\\nvec3(0.06407013,0.05409927,0.),\\nvec3(0.7366577,0.5789394,0.),\\nvec3(-0.6270542,-0.5320278,0.),\\nvec3(-0.4096107,0.8411095,0.),\\nvec3(0.6849564,-0.4990818,0.),\\nvec3(-0.874181,-0.04579735,0.),\\nvec3(0.9989998,0.0009880066,0.),\\nvec3(-0.004920578,-0.9151649,0.),\\nvec3(0.1805763,0.9747483,0.),\\nvec3(-0.2138451,0.2635818,0.),\\nvec3(0.109845,0.3884785,0.),\\nvec3(0.06876755,-0.3581074,0.),\\nvec3(0.374073,-0.7661266,0.),\\nvec3(0.3079132,-0.1216763,0.),\\nvec3(-0.3794335,-0.8271583,0.),\\nvec3(-0.203878,-0.07715034,0.),\\nvec3(0.5912697,0.1469799,0.),\\nvec3(-0.88069,0.3031784,0.),\\nvec3(0.5040108,0.8283722,0.),\\nvec3(-0.5844124,0.5494877,0.),\\nvec3(0.6017799,-0.1726654,0.),\\nvec3(-0.5554981,0.1559997,0.),\\nvec3(-0.3016369,-0.3900928,0.),\\nvec3(-0.5550632,-0.1723762,0.),\\nvec3(0.925029,0.2995041,0.),\\nvec3(-0.2473137,0.5538505,0.),\\nvec3(0.9183037,-0.2862392,0.),\\nvec3(0.2469421,0.6718712,0.),\\nvec3(0.3916397,-0.4328209,0.),\\nvec3(-0.03576927,-0.6220032,0.),\\nvec3(-0.04661255,0.7995201,0.),\\nvec3(0.4402924,0.3640312,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.)\\n);\\nconst vec3 PoissonSamplers64[64]=vec3[64](\\nvec3(-0.613392,0.617481,0.),\\nvec3(0.170019,-0.040254,0.),\\nvec3(-0.299417,0.791925,0.),\\nvec3(0.645680,0.493210,0.),\\nvec3(-0.651784,0.717887,0.),\\nvec3(0.421003,0.027070,0.),\\nvec3(-0.817194,-0.271096,0.),\\nvec3(-0.705374,-0.668203,0.),\\nvec3(0.977050,-0.108615,0.),\\nvec3(0.063326,0.142369,0.),\\nvec3(0.203528,0.214331,0.),\\nvec3(-0.667531,0.326090,0.),\\nvec3(-0.098422,-0.295755,0.),\\nvec3(-0.885922,0.215369,0.),\\nvec3(0.566637,0.605213,0.),\\nvec3(0.039766,-0.396100,0.),\\nvec3(0.751946,0.453352,0.),\\nvec3(0.078707,-0.715323,0.),\\nvec3(-0.075838,-0.529344,0.),\\nvec3(0.724479,-0.580798,0.),\\nvec3(0.222999,-0.215125,0.),\\nvec3(-0.467574,-0.405438,0.),\\nvec3(-0.248268,-0.814753,0.),\\nvec3(0.354411,-0.887570,0.),\\nvec3(0.175817,0.382366,0.),\\nvec3(0.487472,-0.063082,0.),\\nvec3(-0.084078,0.898312,0.),\\nvec3(0.488876,-0.783441,0.),\\nvec3(0.470016,0.217933,0.),\\nvec3(-0.696890,-0.549791,0.),\\nvec3(-0.149693,0.605762,0.),\\nvec3(0.034211,0.979980,0.),\\nvec3(0.503098,-0.308878,0.),\\nvec3(-0.016205,-0.872921,0.),\\nvec3(0.385784,-0.393902,0.),\\nvec3(-0.146886,-0.859249,0.),\\nvec3(0.643361,0.164098,0.),\\nvec3(0.634388,-0.049471,0.),\\nvec3(-0.688894,0.007843,0.),\\nvec3(0.464034,-0.188818,0.),\\nvec3(-0.440840,0.137486,0.),\\nvec3(0.364483,0.511704,0.),\\nvec3(0.034028,0.325968,0.),\\nvec3(0.099094,-0.308023,0.),\\nvec3(0.693960,-0.366253,0.),\\nvec3(0.678884,-0.204688,0.),\\nvec3(0.001801,0.780328,0.),\\nvec3(0.145177,-0.898984,0.),\\nvec3(0.062655,-0.611866,0.),\\nvec3(0.315226,-0.604297,0.),\\nvec3(-0.780145,0.486251,0.),\\nvec3(-0.371868,0.882138,0.),\\nvec3(0.200476,0.494430,0.),\\nvec3(-0.494552,-0.711051,0.),\\nvec3(0.612476,0.705252,0.),\\nvec3(-0.578845,-0.768792,0.),\\nvec3(-0.772454,-0.090976,0.),\\nvec3(0.504440,0.372295,0.),\\nvec3(0.155736,0.065157,0.),\\nvec3(0.391522,0.849605,0.),\\nvec3(-0.620106,-0.328104,0.),\\nvec3(0.789239,-0.419965,0.),\\nvec3(-0.545396,0.538133,0.),\\nvec3(-0.178564,-0.596057,0.)\\n);\\n\\n\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\n\\nfloat AAOffset=shadowMapSizeInverse*10.;\\n\\n\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec4 offset=vec4(poissonSamplers[i],0.);\\n\\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\n\\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\\n\\nshadow=mix(darkness,1.,shadow);\\n\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\n\\nfloat AAOffset=shadowMapSizeInverse*10.;\\n\\n\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec3 offset=poissonSamplers[i];\\n\\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\n\\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\\n\\nshadow=mix(darkness,1.,shadow);\\n\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var shadowsFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=shadowsFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fresnelFunction';\r\nvar shader = \"#ifdef FRESNEL\\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\\n{\\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\\nreturn clamp(fresnelTerm,0.,1.);\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fresnelFunction = { name: name, shader: shader };\r\n//# sourceMappingURL=fresnelFunction.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'reflectionFunction';\r\nvar shader = \"vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\\n\\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\\nvec3 halfSize=cubeSize*0.5;\\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\\n\\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\\n\\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\\n\\nvec3 intersectPositionWS=vertexPos+origVec*distance;\\n\\nreturn intersectPositionWS-cubePos;\\n}\\nvec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0);\\n}\\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(1.0-s,t,0);\\n}\\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\\nr=vec3(reflectionMatrix*vec4(r,0));\\nfloat lon=atan(r.z,r.x);\\nfloat lat=acos(r.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0);\\n}\\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(vec3(view*worldPos));\\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\\nvec3 r=reflect(viewDir,viewNormal);\\nr=vec3(reflectionMatrix*vec4(r,0));\\nr.z=r.z-1.0;\\nfloat m=2.0*length(r);\\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\\n}\\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=worldPos.xyz-eyePosition;\\nvec3 coords=normalize(reflect(viewDir,worldNormal));\\nreturn vec3(reflectionMatrix*vec4(coords,1));\\n}\\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\n\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\n\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*(view*worldPos));\\n}\\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\\n}\\n#ifdef REFLECTION\\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\\n{\\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SPHERICAL\\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_PLANAR\\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_CUBIC\\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\\n#else\\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_PROJECTION\\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_EXPLICIT\\nreturn vec3(0,0,0);\\n#endif\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var reflectionFunction = { name: name, shader: shader };\r\n//# sourceMappingURL=reflectionFunction.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'imageProcessingDeclaration';\r\nvar shader = \"#ifdef EXPOSURE\\nuniform float exposureLinear;\\n#endif\\n#ifdef CONTRAST\\nuniform float contrast;\\n#endif\\n#ifdef VIGNETTE\\nuniform vec2 vInverseScreenSize;\\nuniform vec4 vignetteSettings1;\\nuniform vec4 vignetteSettings2;\\n#endif\\n#ifdef COLORCURVES\\nuniform vec4 vCameraColorCurveNegative;\\nuniform vec4 vCameraColorCurveNeutral;\\nuniform vec4 vCameraColorCurvePositive;\\n#endif\\n#ifdef COLORGRADING\\n#ifdef COLORGRADING3D\\nuniform highp sampler3D txColorTransform;\\n#else\\nuniform sampler2D txColorTransform;\\n#endif\\nuniform vec4 colorTransformSettings;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var imageProcessingDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=imageProcessingDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'imageProcessingFunctions';\r\nvar shader = \"#if defined(COLORGRADING) && !defined(COLORGRADING3D)\\n\\n#define inline\\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\\n{\\nfloat sliceSize=2.0*sampler3dSetting.x;\\n#ifdef SAMPLER3DGREENDEPTH\\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\\n#else\\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\\n#endif\\nfloat sliceInteger=floor(sliceContinuous);\\n\\n\\nfloat sliceFraction=sliceContinuous-sliceInteger;\\n#ifdef SAMPLER3DGREENDEPTH\\nvec2 sliceUV=color.rb;\\n#else\\nvec2 sliceUV=color.rg;\\n#endif\\nsliceUV.x*=sliceSize;\\nsliceUV.x+=sliceInteger*sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\\nsliceUV.x+=sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\\n#ifdef SAMPLER3DBGRMAP\\ncolor.rgb=result.rgb;\\n#else\\ncolor.rgb=result.bgr;\\n#endif\\nreturn color;\\n}\\n#endif\\n#ifdef TONEMAPPING_ACES\\n\\n\\n\\n\\n\\nconst mat3 ACESInputMat=mat3(\\nvec3(0.59719,0.07600,0.02840),\\nvec3(0.35458,0.90834,0.13383),\\nvec3(0.04823,0.01566,0.83777)\\n);\\n\\nconst mat3 ACESOutputMat=mat3(\\nvec3( 1.60475,-0.10208,-0.00327),\\nvec3(-0.53108,1.10813,-0.07276),\\nvec3(-0.07367,-0.00605,1.07602)\\n);\\nvec3 RRTAndODTFit(vec3 v)\\n{\\nvec3 a=v*(v+0.0245786)-0.000090537;\\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\\nreturn a/b;\\n}\\nvec3 ACESFitted(vec3 color)\\n{\\ncolor=ACESInputMat*color;\\n\\ncolor=RRTAndODTFit(color);\\ncolor=ACESOutputMat*color;\\n\\ncolor=saturate(color);\\nreturn color;\\n}\\n#endif\\nvec4 applyImageProcessing(vec4 result) {\\n#ifdef EXPOSURE\\nresult.rgb*=exposureLinear;\\n#endif\\n#ifdef VIGNETTE\\n\\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\\nviewportXY=viewportXY*2.0-1.0;\\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\\n\\nvec3 vignetteColor=vignetteSettings2.rgb;\\n#ifdef VIGNETTEBLENDMODEMULTIPLY\\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\\nresult.rgb*=vignetteColorMultiplier;\\n#endif\\n#ifdef VIGNETTEBLENDMODEOPAQUE\\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\\n#endif\\n#endif\\n#ifdef TONEMAPPING\\n#ifdef TONEMAPPING_ACES\\nresult.rgb=ACESFitted(result.rgb);\\n#else\\nconst float tonemappingCalibration=1.590579;\\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\\n#endif\\n#endif\\n\\nresult.rgb=toGammaSpace(result.rgb);\\nresult.rgb=saturate(result.rgb);\\n#ifdef CONTRAST\\n\\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\\nif (contrast<1.0) {\\n\\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\\n} else {\\n\\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\\n}\\n#endif\\n\\n#ifdef COLORGRADING\\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\\n#ifdef COLORGRADING3D\\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\\n#else\\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\\n#endif\\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\\n#endif\\n#ifdef COLORCURVES\\n\\nfloat luma=getLuminance(result.rgb);\\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\\nresult.rgb*=colorCurve.rgb;\\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\\n#endif\\nreturn result;\\n}\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var imageProcessingFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=imageProcessingFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragmentMainFunctions';\r\nvar shader = \"#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\\n#if defined(TANGENT) && defined(NORMAL)\\nvarying mat3 vTBN;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nuniform mat4 normalMatrix;\\n#endif\\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\\n{\\n#ifdef NORMALXYSCALE\\nnormal=normalize(normal*vec3(scale,scale,1.0));\\n#endif\\nreturn normalize(cotangentFrame*normal);\\n}\\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\\n{\\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\\n}\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\\n{\\n\\nuv=gl_FrontFacing ? uv : -uv;\\n\\nvec3 dp1=dFdx(p);\\nvec3 dp2=dFdy(p);\\nvec2 duv1=dFdx(uv);\\nvec2 duv2=dFdy(uv);\\n\\nvec3 dp2perp=cross(dp2,normal);\\nvec3 dp1perp=cross(normal,dp1);\\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\\n\\ntangent*=tangentSpaceParams.x;\\nbitangent*=tangentSpaceParams.y;\\n\\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\\n}\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragmentMainFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragmentMainFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragmentFunctions';\r\nvar shader = \"#if defined(BUMP)\\n#if BUMPDIRECTUV == 1\\n#define vBumpUV vMainUV1\\n#elif BUMPDIRECTUV == 2\\n#define vBumpUV vMainUV2\\n#else\\nvarying vec2 vBumpUV;\\n#endif\\nuniform sampler2D bumpSampler;\\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\\n{\\nreturn perturbNormal(cotangentFrame,texture2D(bumpSampler,uv).xyz,vBumpInfos.y);\\n}\\n#endif\\n#if defined(DETAIL)\\n#if DETAILDIRECTUV == 1\\n#define vDetailUV vMainUV1\\n#elif DETAILDIRECTUV == 2\\n#define vDetailUV vMainUV2\\n#else\\nvarying vec2 vDetailUV;\\n#endif\\nuniform sampler2D detailSampler;\\n#endif\\n#if defined(BUMP)\\nvec3 perturbNormal(mat3 cotangentFrame,vec3 color)\\n{\\nreturn perturbNormal(cotangentFrame,color,vBumpInfos.y);\\n}\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\\n{\\nreturn cotangent_frame(normal,p,uv,vTangentSpaceParams);\\n}\\n#endif\\n#if defined(BUMP) && defined(PARALLAX)\\nconst float minSamples=4.;\\nconst float maxSamples=15.;\\nconst int iMaxSamples=15;\\n\\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\\nparallaxLimit*=parallaxScale;\\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\\nfloat stepSize=1.0/numSamples;\\n\\nfloat currRayHeight=1.0;\\nvec2 vCurrOffset=vec2(0,0);\\nvec2 vLastOffset=vec2(0,0);\\nfloat lastSampledHeight=1.0;\\nfloat currSampledHeight=1.0;\\nfor (int i=0; i<iMaxSamples; i++)\\n{\\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\\n\\nif (currSampledHeight>currRayHeight)\\n{\\nfloat delta1=currSampledHeight-currRayHeight;\\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\\nfloat ratio=delta1/(delta1+delta2);\\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\\n\\nbreak;\\n}\\nelse\\n{\\ncurrRayHeight-=stepSize;\\nvLastOffset=vCurrOffset;\\nvCurrOffset+=stepSize*vMaxOffset;\\nlastSampledHeight=currSampledHeight;\\n}\\n}\\nreturn vCurrOffset;\\n}\\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\\n{\\n\\nfloat height=texture2D(bumpSampler,vBumpUV).w;\\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\\nreturn -texCoordOffset;\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneFragmentDeclaration';\r\nvar shader = \"#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nvarying float fClipDistance6;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthDeclaration';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nuniform float logarithmicDepthConstant;\\nvarying float vFragmentDepth;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogFragmentDeclaration';\r\nvar shader = \"#ifdef FOG\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying vec3 vFogDistance;\\nfloat CalcFogFactor()\\n{\\nfloat fogCoeff=1.0;\\nfloat fogStart=vFogInfos.y;\\nfloat fogEnd=vFogInfos.z;\\nfloat fogDensity=vFogInfos.w;\\nfloat fogDistance=length(vFogDistance);\\nif (FOGMODE_LINEAR == vFogInfos.x)\\n{\\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\\n}\\nelse if (FOGMODE_EXP == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\\n}\\nelse if (FOGMODE_EXP2 == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\\n}\\nreturn clamp(fogCoeff,0.0,1.0);\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=fogFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneFragment';\r\nvar shader = \"#ifdef CLIPPLANE\\nif (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE2\\nif (fClipDistance2>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE3\\nif (fClipDistance3>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE4\\nif (fClipDistance4>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE5\\nif (fClipDistance5>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE6\\nif (fClipDistance6>0.0)\\n{\\ndiscard;\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragment';\r\nvar shader = \"vec2 uvOffset=vec2(0.0,0.0);\\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\\n#ifdef NORMALXYSCALE\\nfloat normalScale=1.0;\\n#elif defined(BUMP)\\nfloat normalScale=vBumpInfos.y;\\n#else\\nfloat normalScale=1.0;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#elif defined(BUMP)\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\\n#else\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vDetailUV,vec2(1.,1.));\\n#endif\\n#elif defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#else\\nmat3 TBN=cotangent_frame(normalW,vPositionW,vMainUV1,vec2(1.,1.));\\n#endif\\n#endif\\n#ifdef PARALLAX\\nmat3 invTBN=transposeMat3(TBN);\\n#ifdef PARALLAXOCCLUSION\\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\\n#else\\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\\n#endif\\n#endif\\n#ifdef DETAIL\\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\\n#endif\\n#ifdef BUMP\\n#ifdef OBJECTSPACE_NORMALMAP\\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\\nnormalW=normalize(mat3(normalMatrix)*normalW);\\n#elif !defined(DETAIL)\\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\\n#else\\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\\n\\n#if DETAIL_NORMALBLENDMETHOD == 0\\ndetailNormal.xy*=vDetailInfos.z;\\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\\n#elif DETAIL_NORMALBLENDMETHOD == 1\\ndetailNormal.xy*=vDetailInfos.z;\\nbumpNormal+=vec3(0.0,0.0,1.0);\\ndetailNormal*=vec3(-1.0,-1.0,1.0);\\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\\n#endif\\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\\n#endif\\n#elif defined(DETAIL)\\ndetailNormal.xy*=vDetailInfos.z;\\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'depthPrePass';\r\nvar shader = \"#ifdef DEPTHPREPASS\\ngl_FragColor=vec4(0.,0.,0.,1.0);\\nreturn;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var depthPrePass = { name: name, shader: shader };\r\n//# sourceMappingURL=depthPrePass.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightFragment';\r\nvar shader = \"#ifdef LIGHT{X}\\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\\n\\n#else\\n#ifdef PBR\\n\\n#ifdef SPOTLIGHT{X}\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(POINTLIGHT{X})\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(HEMILIGHT{X})\\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(DIRLIGHT{X})\\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#endif\\npreInfo.NdotV=NdotV;\\n\\n#ifdef SPOTLIGHT{X}\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#endif\\n#elif defined(POINTLIGHT{X})\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\n#endif\\n#else\\npreInfo.attenuation=1.0;\\n#endif\\n\\n\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=roughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n\\n#ifdef HEMILIGHT{X}\\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\\n#elif defined(SS_TRANSLUCENCY)\\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\\n#else\\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\\n#endif\\n\\n#ifdef SPECULARTERM\\n#ifdef ANISOTROPIC\\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#else\\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n#endif\\n\\n#ifdef SHEEN\\n#ifdef SHEEN_LINKWITHALBEDO\\n\\npreInfo.roughness=sheenOut.sheenIntensity;\\n#else\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=sheenOut.sheenRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n#endif\\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n\\n#ifdef CLEARCOAT\\n\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\\n#ifdef CLEARCOAT_TINT\\n\\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\\ninfo.diffuse*=absorption;\\n#ifdef SPECULARTERM\\ninfo.specular*=absorption;\\n#endif\\n#endif\\n\\ninfo.diffuse*=info.clearCoat.w;\\n#ifdef SPECULARTERM\\ninfo.specular*=info.clearCoat.w;\\n#endif\\n#ifdef SHEEN\\ninfo.sheen*=info.clearCoat.w;\\n#endif\\n#endif\\n#else\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#elif defined(HEMILIGHT{X})\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\\n#endif\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\\n{\\n#ifdef SHADOWCSM_RIGHTHANDED{X}\\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\\n#else\\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\\n#endif\\nif (diff{X}>=0.) {\\nindex{X}=i;\\nbreak;\\n}\\n}\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nif (index{X}>=0)\\n#endif\\n{\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\\n#endif\\n#ifndef SHADOWCSMNOBLEND{X}\\nfloat frustumLength=frustumLengths{X}[index{X}];\\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\\n{\\nindex{X}+=1;\\nfloat nextShadow=0.;\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\nshadow=mix(nextShadow,shadow,diffRatio);\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\\n#endif\\n}\\n#endif\\n}\\n#elif defined(SHADOWCLOSEESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPOISSON{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#else\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#endif\\n#ifdef SHADOWONLY\\n#ifndef SHADOWINUSE\\n#define SHADOWINUSE\\n#endif\\nglobalShadow+=shadow;\\nshadowLightCount+=1.0;\\n#endif\\n#else\\nshadow=1.;\\n#endif\\n#ifndef SHADOWONLY\\n#ifdef CUSTOMUSERLIGHTING\\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\\n#ifdef SPECULARTERM\\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\\n#endif\\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\\ndiffuseBase+=lightmapColor.rgb*shadow;\\n#ifdef SPECULARTERM\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef CLEARCOAT\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef SHEEN\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#else\\n#ifdef SHADOWCSMDEBUG{X}\\ndiffuseBase+=info.diffuse*shadowDebug{X};\\n#else\\ndiffuseBase+=info.diffuse*shadow;\\n#endif\\n#ifdef SPECULARTERM\\nspecularBase+=info.specular*shadow;\\n#endif\\n#ifdef CLEARCOAT\\nclearCoatBase+=info.clearCoat.rgb*shadow;\\n#endif\\n#ifdef SHEEN\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=lightFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthFragment';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogFragment';\r\nvar shader = \"#ifdef FOG\\nfloat fog=CalcFogFactor();\\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=fogFragment.js.map","import { Effect } from \"../Materials/effect\";\r\nimport \"./ShadersInclude/defaultFragmentDeclaration\";\r\nimport \"./ShadersInclude/defaultUboDeclaration\";\r\nimport \"./ShadersInclude/prePassDeclaration\";\r\nimport \"./ShadersInclude/helperFunctions\";\r\nimport \"./ShadersInclude/lightFragmentDeclaration\";\r\nimport \"./ShadersInclude/lightUboDeclaration\";\r\nimport \"./ShadersInclude/lightsFragmentFunctions\";\r\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\r\nimport \"./ShadersInclude/fresnelFunction\";\r\nimport \"./ShadersInclude/reflectionFunction\";\r\nimport \"./ShadersInclude/imageProcessingDeclaration\";\r\nimport \"./ShadersInclude/imageProcessingFunctions\";\r\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\r\nimport \"./ShadersInclude/bumpFragmentFunctions\";\r\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\r\nimport \"./ShadersInclude/logDepthDeclaration\";\r\nimport \"./ShadersInclude/fogFragmentDeclaration\";\r\nimport \"./ShadersInclude/clipPlaneFragment\";\r\nimport \"./ShadersInclude/bumpFragment\";\r\nimport \"./ShadersInclude/depthPrePass\";\r\nimport \"./ShadersInclude/lightFragment\";\r\nimport \"./ShadersInclude/logDepthFragment\";\r\nimport \"./ShadersInclude/fogFragment\";\r\nvar name = 'defaultPixelShader';\r\nvar shader = \"#include<__decl__defaultFragment>\\n#if defined(BUMP) || !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\\n#define CUSTOM_FRAGMENT_BEGIN\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n\\n#define RECIPROCAL_PI2 0.15915494\\nuniform vec3 vEyePosition;\\nuniform vec3 vAmbientColor;\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n\\n#include<helperFunctions>\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV == 1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV == 2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY\\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\nuniform samplerCube refractionCubeSampler;\\n#else\\nuniform sampler2D refraction2DSampler;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\n#if SPECULARDIRECTUV == 1\\n#define vSpecularUV vMainUV1\\n#elif SPECULARDIRECTUV == 2\\n#define vSpecularUV vMainUV2\\n#else\\nvarying vec2 vSpecularUV;\\n#endif\\nuniform sampler2D specularSampler;\\n#endif\\n#ifdef ALPHATEST\\nuniform float alphaCutOff;\\n#endif\\n\\n#include<fresnelFunction>\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\nuniform samplerCube reflectionCubeSampler;\\n#else\\nuniform sampler2D reflection2DSampler;\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<imageProcessingFunctions>\\n#include<bumpFragmentMainFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n\\nvec4 baseColor=vec4(1.,1.,1.,1.);\\nvec3 diffuseColor=vDiffuseColor.rgb;\\n\\nfloat alpha=vDiffuseColor.a;\\n\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\\n#endif\\n#include<bumpFragment>\\n#ifdef TWOSIDEDLIGHTING\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n#ifdef DIFFUSE\\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\\nif (baseColor.a<alphaCutOff)\\ndiscard;\\n#endif\\n#ifdef ALPHAFROMDIFFUSE\\nalpha*=baseColor.a;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\\nbaseColor.rgb*=vDiffuseInfos.y;\\n#endif\\n#include<depthPrePass>\\n#ifdef VERTEXCOLOR\\nbaseColor.rgb*=vColor.rgb;\\n#endif\\n#ifdef DETAIL\\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\\n\\nvec3 baseAmbientColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\\n\\n#ifdef SPECULARTERM\\nfloat glossiness=vSpecularColor.a;\\nvec3 specularColor=vSpecularColor.rgb;\\n#ifdef SPECULAR\\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\\nspecularColor=specularMapColor.rgb;\\n#ifdef GLOSSINESS\\nglossiness=glossiness*specularMapColor.a;\\n#endif\\n#endif\\n#else\\nfloat glossiness=0.;\\n#endif\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\nlightingInfo info;\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\nfloat shadow=1.;\\n#ifdef LIGHTMAP\\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\\n#ifdef RGBDLIGHTMAP\\nlightmapColor.rgb=fromRGBD(lightmapColor);\\n#endif\\nlightmapColor.rgb*=vLightmapInfos.y;\\n#endif\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\nvec4 refractionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFRACTION\\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nif (dot(refractionVector,viewDirectionW)<1.0) {\\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\\n}\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\\n#endif\\n#ifdef RGBDREFRACTION\\nrefractionColor.rgb=fromRGBD(refractionColor);\\n#endif\\n#ifdef IS_REFRACTION_LINEAR\\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\\n#endif\\nrefractionColor.rgb*=vRefractionInfos.x;\\n#endif\\n\\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFLECTION\\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_3D\\n#ifdef ROUGHNESS\\nfloat bias=vReflectionInfos.y;\\n#ifdef SPECULARTERM\\n#ifdef SPECULAR\\n#ifdef GLOSSINESS\\nbias*=(1.0-specularMapColor.a);\\n#endif\\n#endif\\n#endif\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\\n#else\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\\n#endif\\n#else\\nvec2 coords=vReflectionUVW.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\ncoords/=vReflectionUVW.z;\\n#endif\\ncoords.y=1.0-coords.y;\\nreflectionColor=texture2D(reflection2DSampler,coords);\\n#endif\\n#ifdef RGBDREFLECTION\\nreflectionColor.rgb=fromRGBD(reflectionColor);\\n#endif\\n#ifdef IS_REFLECTION_LINEAR\\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\\n#endif\\nreflectionColor.rgb*=vReflectionInfos.x;\\n#ifdef REFLECTIONFRESNEL\\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\\n#ifdef REFLECTIONFRESNELFROMSPECULAR\\n#ifdef SPECULARTERM\\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#endif\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\\n#else\\nalpha*=opacityMap.a*vOpacityInfos.y;\\n#endif\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\\nif (alpha<alphaCutOff)\\ndiscard;\\n#endif\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n\\nvec3 emissiveColor=vEmissiveColor;\\n#ifdef EMISSIVE\\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\\n#endif\\n\\n#ifdef DIFFUSEFRESNEL\\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase*specularColor;\\n#ifdef SPECULAROVERALPHA\\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#else\\nvec3 finalSpecular=vec3(0.0);\\n#endif\\n#ifdef REFLECTIONOVERALPHA\\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\\n#else\\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\\n#endif\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\ncolor.rgb*=lightmapColor.rgb;\\n#else\\ncolor.rgb+=lightmapColor.rgb;\\n#endif\\n#endif\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FOG\\ncolor.rgb=max(color.rgb,0.);\\n#include<logDepthFragment>\\n#include<fogFragment>\\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ncolor.rgb=toLinearSpace(color.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ncolor.rgb=toLinearSpace(color.rgb);\\ncolor=applyImageProcessing(color);\\n#endif\\n#endif\\ncolor.a*=visibility;\\n#ifdef PREMULTIPLYALPHA\\n\\ncolor.rgb*=color.a;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\\n#ifdef PREPASS\\ngl_FragData[0]=color;\\n#ifdef PREPASS_POSITION\\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,1.0);\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\\nvec2 velocity=abs(a-b);\\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\\n#endif\\n#ifdef PREPASS_IRRADIANCE\\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#ifdef PREPASS_DEPTHNORMAL\\ngl_FragData[PREPASS_DEPTHNORMAL_INDEX]=vec4(vViewPos.z,(view*vec4(normalW,0.0)).rgb);\\n#endif\\n#ifdef PREPASS_ALBEDO\\ngl_FragData[PREPASS_ALBEDO_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#ifdef PREPASS_REFLECTIVITY\\n#if defined(SPECULAR)\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=specularMapColor;\\n#else\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#endif\\n#endif\\n#if !defined(PREPASS) || defined(WEBGL2)\\ngl_FragColor=color;\\n#endif\\n}\\n\";\r\nEffect.ShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultPixelShader = { name: name, shader: shader };\r\n//# sourceMappingURL=default.fragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultVertexDeclaration';\r\nvar shader = \"\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\nuniform mat4 specularMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef REFLECTION\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bonesDeclaration';\r\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\n#ifdef BONETEXTURE\\nuniform sampler2D boneSampler;\\nuniform float boneTextureWidth;\\n#else\\nuniform mat4 mBones[BonesPerMesh];\\n#ifdef BONES_VELOCITY_ENABLED\\nuniform mat4 mPreviousBones[BonesPerMesh];\\n#endif\\n#endif\\nattribute vec4 matricesIndices;\\nattribute vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute vec4 matricesIndicesExtra;\\nattribute vec4 matricesWeightsExtra;\\n#endif\\n#ifdef BONETEXTURE\\n#define inline\\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\\n{\\nfloat offset=index*4.0;\\nfloat dx=1.0/boneTextureWidth;\\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\\nreturn mat4(m0,m1,m2,m3);\\n}\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bonesDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=bonesDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'instancesDeclaration';\r\nvar shader = \"#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#ifdef THIN_INSTANCES\\nuniform mat4 world;\\n#endif\\n#else\\nuniform mat4 world;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var instancesDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=instancesDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassVertexDeclaration';\r\nvar shader = \"#ifdef PREPASS\\n#ifdef PREPASS_DEPTHNORMAL\\nvarying vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nuniform mat4 previousWorld;\\nuniform mat4 previousViewProjection;\\nvarying vec4 vCurrentPosition;\\nvarying vec4 vPreviousPosition;\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpVertexDeclaration';\r\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nvarying mat3 vTBN;\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneVertexDeclaration';\r\nvar shader = \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nuniform vec4 vClipPlane5;\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nuniform vec4 vClipPlane6;\\nvarying float fClipDistance6;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogVertexDeclaration';\r\nvar shader = \"#ifdef FOG\\nvarying vec3 vFogDistance;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=fogVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertexGlobalDeclaration';\r\nvar shader = \"#ifdef MORPHTARGETS\\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertexGlobalDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertexDeclaration';\r\nvar shader = \"#ifdef MORPHTARGETS\\nattribute vec3 position{X};\\n#ifdef MORPHTARGETS_NORMAL\\nattribute vec3 normal{X};\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute vec3 tangent{X};\\n#endif\\n#ifdef MORPHTARGETS_UV\\nattribute vec2 uv_{X};\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertex';\r\nvar shader = \"#ifdef MORPHTARGETS\\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'instancesVertex';\r\nvar shader = \"#ifdef INSTANCES\\nmat4 finalWorld=mat4(world0,world1,world2,world3);\\n#ifdef THIN_INSTANCES\\nfinalWorld=world*finalWorld;\\n#endif\\n#else\\nmat4 finalWorld=world;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var instancesVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=instancesVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bonesVertex';\r\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\nmat4 influence;\\n#ifdef BONETEXTURE\\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\\n#endif\\n#else\\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\n#endif\\nfinalWorld=finalWorld*influence;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bonesVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=bonesVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassVertex';\r\nvar shader = \"#ifdef PREPASS_DEPTHNORMAL\\nvViewPos=(view*worldPos).rgb;\\n#endif\\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*worldPos;\\n#if NUM_BONE_INFLUENCERS>0\\nmat4 previousInfluence;\\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\nvPreviousPosition=previousViewProjection*previousWorld*previousInfluence*vec4(positionUpdated,1.0);\\n#else\\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpVertex';\r\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nvec3 tbnNormal=normalize(normalUpdated);\\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneVertex';\r\nvar shader = \"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\\n#ifdef CLIPPLANE2\\nfClipDistance2=dot(worldPos,vClipPlane2);\\n#endif\\n#ifdef CLIPPLANE3\\nfClipDistance3=dot(worldPos,vClipPlane3);\\n#endif\\n#ifdef CLIPPLANE4\\nfClipDistance4=dot(worldPos,vClipPlane4);\\n#endif\\n#ifdef CLIPPLANE5\\nfClipDistance5=dot(worldPos,vClipPlane5);\\n#endif\\n#ifdef CLIPPLANE6\\nfClipDistance6=dot(worldPos,vClipPlane6);\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogVertex';\r\nvar shader = \"#ifdef FOG\\nvFogDistance=(view*worldPos).xyz;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=fogVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'shadowsVertex';\r\nvar shader = \"#ifdef SHADOWS\\n#if defined(SHADOWCSM{X})\\nvPositionFromCamera{X}=view*worldPos;\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\\nvDepthMetric{X}[i]=((vPositionFromLight{X}[i].z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n}\\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var shadowsVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=shadowsVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'pointCloudVertex';\r\nvar shader = \"#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var pointCloudVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=pointCloudVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthVertex';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nvFragmentDepth=1.0+gl_Position.w;\\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthVertex.js.map","import { Effect } from \"../Materials/effect\";\r\nimport \"./ShadersInclude/defaultVertexDeclaration\";\r\nimport \"./ShadersInclude/defaultUboDeclaration\";\r\nimport \"./ShadersInclude/helperFunctions\";\r\nimport \"./ShadersInclude/bonesDeclaration\";\r\nimport \"./ShadersInclude/instancesDeclaration\";\r\nimport \"./ShadersInclude/prePassVertexDeclaration\";\r\nimport \"./ShadersInclude/bumpVertexDeclaration\";\r\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\r\nimport \"./ShadersInclude/fogVertexDeclaration\";\r\nimport \"./ShadersInclude/lightFragmentDeclaration\";\r\nimport \"./ShadersInclude/lightUboDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"./ShadersInclude/logDepthDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertex\";\r\nimport \"./ShadersInclude/instancesVertex\";\r\nimport \"./ShadersInclude/bonesVertex\";\r\nimport \"./ShadersInclude/prePassVertex\";\r\nimport \"./ShadersInclude/bumpVertex\";\r\nimport \"./ShadersInclude/clipPlaneVertex\";\r\nimport \"./ShadersInclude/fogVertex\";\r\nimport \"./ShadersInclude/shadowsVertex\";\r\nimport \"./ShadersInclude/pointCloudVertex\";\r\nimport \"./ShadersInclude/logDepthVertex\";\r\nvar name = 'defaultVertexShader';\r\nvar shader = \"#include<__decl__defaultVertex>\\n\\n#define CUSTOM_VERTEX_BEGIN\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#include<prePassVertexDeclaration>\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#if defined(DETAIL) && DETAILDIRECTUV == 0\\nvarying vec2 vDetailUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nvarying vec2 vSpecularUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_POSITION\\n#define CUSTOM_VERTEX_UPDATE_NORMAL\\n#include<instancesVertex>\\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\\n\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#include<bonesVertex>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\\nvNormalW=normalize(normalWorld*vNormalW);\\n#else\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#endif\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR == 0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\nvPositionW=vec3(worldPos);\\n#include<prePassVertex>\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uvUpdated=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uvUpdated;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nif (vDiffuseInfos.x == 0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(DETAIL) && DETAILDIRECTUV == 0\\nif (vDetailInfos.x == 0.)\\n{\\nvDetailUV=vec2(detailMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvDetailUV=vec2(detailMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nif (vSpecularInfos.x == 0.)\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n#include<pointCloudVertex>\\n#include<logDepthVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\r\nEffect.ShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultVertexShader = { name: name, shader: shader };\r\n//# sourceMappingURL=default.vertex.js.map","/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nvar EffectFallbacks = /** @class */ (function () {\r\n    function EffectFallbacks() {\r\n        this._defines = {};\r\n        this._currentRank = 32;\r\n        this._maxRank = -1;\r\n        this._mesh = null;\r\n    }\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    EffectFallbacks.prototype.unBindMesh = function () {\r\n        this._mesh = null;\r\n    };\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    EffectFallbacks.prototype.addFallback = function (rank, define) {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n            this._defines[rank] = new Array();\r\n        }\r\n        this._defines[rank].push(define);\r\n    };\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    EffectFallbacks.prototype.addCPUSkinningFallback = function (rank, mesh) {\r\n        this._mesh = mesh;\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    };\r\n    Object.defineProperty(EffectFallbacks.prototype, \"hasMoreFallbacks\", {\r\n        /**\r\n         * Checks to see if more fallbacks are still availible.\r\n         */\r\n        get: function () {\r\n            return this._currentRank <= this._maxRank;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    EffectFallbacks.prototype.reduce = function (currentDefines, effect) {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n            var scene = this._mesh.getScene();\r\n            for (var index = 0; index < scene.meshes.length; index++) {\r\n                var otherMesh = scene.meshes[index];\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                }\r\n                else if (otherMesh.subMeshes) {\r\n                    for (var _i = 0, _a = otherMesh.subMeshes; _i < _a.length; _i++) {\r\n                        var subMesh = _a[_i];\r\n                        var subMeshEffect = subMesh.effect;\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (var index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n            this._currentRank++;\r\n        }\r\n        return currentDefines;\r\n    };\r\n    return EffectFallbacks;\r\n}());\r\nexport { EffectFallbacks };\r\n//# sourceMappingURL=effectFallbacks.js.map","import { __decorate } from \"tslib\";\r\nimport { Material } from \"./material\";\r\nimport { serialize, expandToProperty, serializeAsTexture, SerializationHelper } from '../Misc/decorators';\r\nimport { MaterialFlags } from './materialFlags';\r\nimport { MaterialHelper } from './materialHelper';\r\n/**\r\n * Define the code related to the detail map parameters of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nvar DetailMapConfiguration = /** @class */ (function () {\r\n    /**\r\n     * Instantiate a new detail map\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    function DetailMapConfiguration(markAllSubMeshesAsTexturesDirty) {\r\n        this._texture = null;\r\n        /**\r\n         * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n         * Bigger values mean stronger blending\r\n         */\r\n        this.diffuseBlendLevel = 1;\r\n        /**\r\n         * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n         * Bigger values mean stronger blending. Only used with PBR materials\r\n         */\r\n        this.roughnessBlendLevel = 1;\r\n        /**\r\n         * Defines how strong the bump effect from the detail map is\r\n         * Bigger values mean stronger effect\r\n         */\r\n        this.bumpLevel = 1;\r\n        this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n        this._isEnabled = false;\r\n        /**\r\n         * Enable or disable the detail map on this material\r\n         */\r\n        this.isEnabled = false;\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n    /** @hidden */\r\n    DetailMapConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    };\r\n    /**\r\n     * Gets whether the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    DetailMapConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\r\n        var engine = scene.getEngine();\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Update the defines for detail map usage\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    DetailMapConfiguration.prototype.prepareDefines = function (defines, scene) {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n            var engine = scene.getEngine();\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                }\r\n                else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.DETAIL = false;\r\n        }\r\n    };\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     */\r\n    DetailMapConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen) {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    DetailMapConfiguration.prototype.hasTexture = function (texture) {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    DetailMapConfiguration.prototype.getActiveTextures = function (activeTextures) {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    DetailMapConfiguration.prototype.getAnimatables = function (animatables) {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    DetailMapConfiguration.prototype.dispose = function (forceDisposeTextures) {\r\n        var _a;\r\n        if (forceDisposeTextures) {\r\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        }\r\n    };\r\n    /**\r\n    * Get the current class name useful for serialization or dynamic coding.\r\n    * @returns \"DetailMap\"\r\n    */\r\n    DetailMapConfiguration.prototype.getClassName = function () {\r\n        return \"DetailMap\";\r\n    };\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    DetailMapConfiguration.AddUniforms = function (uniforms) {\r\n        uniforms.push(\"vDetailInfos\");\r\n    };\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    DetailMapConfiguration.AddSamplers = function (samplers) {\r\n        samplers.push(\"detailSampler\");\r\n    };\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    DetailMapConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\r\n        uniformBuffer.addUniform(\"vDetailInfos\", 4);\r\n        uniformBuffer.addUniform(\"detailMatrix\", 16);\r\n    };\r\n    /**\r\n     * Makes a duplicate of the current instance into another one.\r\n     * @param detailMap define the instance where to copy the info\r\n     */\r\n    DetailMapConfiguration.prototype.copyTo = function (detailMap) {\r\n        SerializationHelper.Clone(function () { return detailMap; }, this);\r\n    };\r\n    /**\r\n     * Serializes this detail map instance\r\n     * @returns - An object with the serialized instance.\r\n     */\r\n    DetailMapConfiguration.prototype.serialize = function () {\r\n        return SerializationHelper.Serialize(this);\r\n    };\r\n    /**\r\n     * Parses a detail map setting from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    DetailMapConfiguration.prototype.parse = function (source, scene, rootUrl) {\r\n        var _this = this;\r\n        SerializationHelper.Parse(function () { return _this; }, source, scene, rootUrl);\r\n    };\r\n    __decorate([\r\n        serializeAsTexture(\"detailTexture\"),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"texture\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"diffuseBlendLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"roughnessBlendLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"bumpLevel\", void 0);\r\n    __decorate([\r\n        serialize(),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"normalBlendMethod\", void 0);\r\n    __decorate([\r\n        serialize(),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"isEnabled\", void 0);\r\n    return DetailMapConfiguration;\r\n}());\r\nexport { DetailMapConfiguration };\r\n//# sourceMappingURL=material.detailMapConfiguration.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport \"../Shaders/default.fragment\";\r\nimport \"../Shaders/default.vertex\";\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { DetailMapConfiguration } from './material.detailMapConfiguration';\r\nvar onCreatedEffectParameters = { effect: null, subMesh: null };\r\n/** @hidden */\r\nvar StandardMaterialDefines = /** @class */ (function (_super) {\r\n    __extends(StandardMaterialDefines, _super);\r\n    function StandardMaterialDefines() {\r\n        var _this = _super.call(this) || this;\r\n        _this.MAINUV1 = false;\r\n        _this.MAINUV2 = false;\r\n        _this.DIFFUSE = false;\r\n        _this.DIFFUSEDIRECTUV = 0;\r\n        _this.DETAIL = false;\r\n        _this.DETAILDIRECTUV = 0;\r\n        _this.DETAIL_NORMALBLENDMETHOD = 0;\r\n        _this.AMBIENT = false;\r\n        _this.AMBIENTDIRECTUV = 0;\r\n        _this.OPACITY = false;\r\n        _this.OPACITYDIRECTUV = 0;\r\n        _this.OPACITYRGB = false;\r\n        _this.REFLECTION = false;\r\n        _this.EMISSIVE = false;\r\n        _this.EMISSIVEDIRECTUV = 0;\r\n        _this.SPECULAR = false;\r\n        _this.SPECULARDIRECTUV = 0;\r\n        _this.BUMP = false;\r\n        _this.BUMPDIRECTUV = 0;\r\n        _this.PARALLAX = false;\r\n        _this.PARALLAXOCCLUSION = false;\r\n        _this.SPECULAROVERALPHA = false;\r\n        _this.CLIPPLANE = false;\r\n        _this.CLIPPLANE2 = false;\r\n        _this.CLIPPLANE3 = false;\r\n        _this.CLIPPLANE4 = false;\r\n        _this.CLIPPLANE5 = false;\r\n        _this.CLIPPLANE6 = false;\r\n        _this.ALPHATEST = false;\r\n        _this.DEPTHPREPASS = false;\r\n        _this.ALPHAFROMDIFFUSE = false;\r\n        _this.POINTSIZE = false;\r\n        _this.FOG = false;\r\n        _this.SPECULARTERM = false;\r\n        _this.DIFFUSEFRESNEL = false;\r\n        _this.OPACITYFRESNEL = false;\r\n        _this.REFLECTIONFRESNEL = false;\r\n        _this.REFRACTIONFRESNEL = false;\r\n        _this.EMISSIVEFRESNEL = false;\r\n        _this.FRESNEL = false;\r\n        _this.NORMAL = false;\r\n        _this.UV1 = false;\r\n        _this.UV2 = false;\r\n        _this.VERTEXCOLOR = false;\r\n        _this.VERTEXALPHA = false;\r\n        _this.NUM_BONE_INFLUENCERS = 0;\r\n        _this.BonesPerMesh = 0;\r\n        _this.BONETEXTURE = false;\r\n        _this.BONES_VELOCITY_ENABLED = false;\r\n        _this.INSTANCES = false;\r\n        _this.THIN_INSTANCES = false;\r\n        _this.GLOSSINESS = false;\r\n        _this.ROUGHNESS = false;\r\n        _this.EMISSIVEASILLUMINATION = false;\r\n        _this.LINKEMISSIVEWITHDIFFUSE = false;\r\n        _this.REFLECTIONFRESNELFROMSPECULAR = false;\r\n        _this.LIGHTMAP = false;\r\n        _this.LIGHTMAPDIRECTUV = 0;\r\n        _this.OBJECTSPACE_NORMALMAP = false;\r\n        _this.USELIGHTMAPASSHADOWMAP = false;\r\n        _this.REFLECTIONMAP_3D = false;\r\n        _this.REFLECTIONMAP_SPHERICAL = false;\r\n        _this.REFLECTIONMAP_PLANAR = false;\r\n        _this.REFLECTIONMAP_CUBIC = false;\r\n        _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n        _this.REFLECTIONMAP_PROJECTION = false;\r\n        _this.REFLECTIONMAP_SKYBOX = false;\r\n        _this.REFLECTIONMAP_EXPLICIT = false;\r\n        _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n        _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n        _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n        _this.INVERTCUBICMAP = false;\r\n        _this.LOGARITHMICDEPTH = false;\r\n        _this.REFRACTION = false;\r\n        _this.REFRACTIONMAP_3D = false;\r\n        _this.REFLECTIONOVERALPHA = false;\r\n        _this.TWOSIDEDLIGHTING = false;\r\n        _this.SHADOWFLOAT = false;\r\n        _this.MORPHTARGETS = false;\r\n        _this.MORPHTARGETS_NORMAL = false;\r\n        _this.MORPHTARGETS_TANGENT = false;\r\n        _this.MORPHTARGETS_UV = false;\r\n        _this.NUM_MORPH_INFLUENCERS = 0;\r\n        _this.NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\r\n        _this.PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\r\n        _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\r\n        _this.ALPHABLEND = true;\r\n        _this.PREPASS = false;\r\n        _this.PREPASS_IRRADIANCE = false;\r\n        _this.PREPASS_IRRADIANCE_INDEX = -1;\r\n        _this.PREPASS_ALBEDO = false;\r\n        _this.PREPASS_ALBEDO_INDEX = -1;\r\n        _this.PREPASS_DEPTHNORMAL = false;\r\n        _this.PREPASS_DEPTHNORMAL_INDEX = -1;\r\n        _this.PREPASS_POSITION = false;\r\n        _this.PREPASS_POSITION_INDEX = -1;\r\n        _this.PREPASS_VELOCITY = false;\r\n        _this.PREPASS_VELOCITY_INDEX = -1;\r\n        _this.PREPASS_REFLECTIVITY = false;\r\n        _this.PREPASS_REFLECTIVITY_INDEX = -1;\r\n        _this.SCENE_MRT_COUNT = 0;\r\n        _this.RGBDLIGHTMAP = false;\r\n        _this.RGBDREFLECTION = false;\r\n        _this.RGBDREFRACTION = false;\r\n        _this.IMAGEPROCESSING = false;\r\n        _this.VIGNETTE = false;\r\n        _this.VIGNETTEBLENDMODEMULTIPLY = false;\r\n        _this.VIGNETTEBLENDMODEOPAQUE = false;\r\n        _this.TONEMAPPING = false;\r\n        _this.TONEMAPPING_ACES = false;\r\n        _this.CONTRAST = false;\r\n        _this.COLORCURVES = false;\r\n        _this.COLORGRADING = false;\r\n        _this.COLORGRADING3D = false;\r\n        _this.SAMPLER3DGREENDEPTH = false;\r\n        _this.SAMPLER3DBGRMAP = false;\r\n        _this.IMAGEPROCESSINGPOSTPROCESS = false;\r\n        _this.MULTIVIEW = false;\r\n        /**\r\n         * If the reflection texture on this material is in linear color space\r\n         * @hidden\r\n         */\r\n        _this.IS_REFLECTION_LINEAR = false;\r\n        /**\r\n         * If the refraction texture on this material is in linear color space\r\n         * @hidden\r\n         */\r\n        _this.IS_REFRACTION_LINEAR = false;\r\n        _this.EXPOSURE = false;\r\n        _this.rebuild();\r\n        return _this;\r\n    }\r\n    StandardMaterialDefines.prototype.setReflectionMode = function (modeToEnable) {\r\n        var modes = [\r\n            \"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\",\r\n            \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\",\r\n            \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\r\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"\r\n        ];\r\n        for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {\r\n            var mode = modes_1[_i];\r\n            this[mode] = (mode === modeToEnable);\r\n        }\r\n    };\r\n    return StandardMaterialDefines;\r\n}(MaterialDefines));\r\nexport { StandardMaterialDefines };\r\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/babylon101/materials\r\n */\r\nvar StandardMaterial = /** @class */ (function (_super) {\r\n    __extends(StandardMaterial, _super);\r\n    /**\r\n     * Instantiates a new standard material.\r\n     * This is the default material used in Babylon. It is the best trade off between quality\r\n     * and performances.\r\n     * @see https://doc.babylonjs.com/babylon101/materials\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    function StandardMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        _this._diffuseTexture = null;\r\n        _this._ambientTexture = null;\r\n        _this._opacityTexture = null;\r\n        _this._reflectionTexture = null;\r\n        _this._emissiveTexture = null;\r\n        _this._specularTexture = null;\r\n        _this._bumpTexture = null;\r\n        _this._lightmapTexture = null;\r\n        _this._refractionTexture = null;\r\n        /**\r\n         * The color of the material lit by the environmental background lighting.\r\n         * @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example\r\n         */\r\n        _this.ambientColor = new Color3(0, 0, 0);\r\n        /**\r\n         * The basic color of the material as viewed under a light.\r\n         */\r\n        _this.diffuseColor = new Color3(1, 1, 1);\r\n        /**\r\n         * Define how the color and intensity of the highlight given by the light in the material.\r\n         */\r\n        _this.specularColor = new Color3(1, 1, 1);\r\n        /**\r\n         * Define the color of the material as if self lit.\r\n         * This will be mixed in the final result even in the absence of light.\r\n         */\r\n        _this.emissiveColor = new Color3(0, 0, 0);\r\n        /**\r\n         * Defines how sharp are the highlights in the material.\r\n         * The bigger the value the sharper giving a more glossy feeling to the result.\r\n         * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n         */\r\n        _this.specularPower = 64;\r\n        _this._useAlphaFromDiffuseTexture = false;\r\n        _this._useEmissiveAsIllumination = false;\r\n        _this._linkEmissiveWithDiffuse = false;\r\n        _this._useSpecularOverAlpha = false;\r\n        _this._useReflectionOverAlpha = false;\r\n        _this._disableLighting = false;\r\n        _this._useObjectSpaceNormalMap = false;\r\n        _this._useParallax = false;\r\n        _this._useParallaxOcclusion = false;\r\n        /**\r\n         * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n         */\r\n        _this.parallaxScaleBias = 0.05;\r\n        _this._roughness = 0;\r\n        /**\r\n         * In case of refraction, define the value of the index of refraction.\r\n         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n         */\r\n        _this.indexOfRefraction = 0.98;\r\n        /**\r\n         * Invert the refraction texture alongside the y axis.\r\n         * It can be useful with procedural textures or probe for instance.\r\n         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n         */\r\n        _this.invertRefractionY = true;\r\n        /**\r\n         * Defines the alpha limits in alpha test mode.\r\n         */\r\n        _this.alphaCutOff = 0.4;\r\n        _this._useLightmapAsShadowmap = false;\r\n        _this._useReflectionFresnelFromSpecular = false;\r\n        _this._useGlossinessFromSpecularMapAlpha = false;\r\n        _this._maxSimultaneousLights = 4;\r\n        _this._invertNormalMapX = false;\r\n        _this._invertNormalMapY = false;\r\n        _this._twoSidedLighting = false;\r\n        /**\r\n         * Defines the detail map parameters for the material.\r\n         */\r\n        _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\r\n        _this._renderTargets = new SmartArray(16);\r\n        _this._worldViewProjectionMatrix = Matrix.Zero();\r\n        _this._globalAmbientColor = new Color3(0, 0, 0);\r\n        _this._rebuildInParallel = false;\r\n        // Setup the default processing configuration to the scene.\r\n        _this._attachImageProcessingConfiguration(null);\r\n        _this.prePassConfiguration = new PrePassConfiguration();\r\n        _this.getRenderTargetTextures = function () {\r\n            _this._renderTargets.reset();\r\n            if (StandardMaterial.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\r\n                _this._renderTargets.push(_this._reflectionTexture);\r\n            }\r\n            if (StandardMaterial.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {\r\n                _this._renderTargets.push(_this._refractionTexture);\r\n            }\r\n            return _this._renderTargets;\r\n        };\r\n        return _this;\r\n    }\r\n    Object.defineProperty(StandardMaterial.prototype, \"imageProcessingConfiguration\", {\r\n        /**\r\n         * Gets the image processing configuration used either in this material.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration;\r\n        },\r\n        /**\r\n         * Sets the Default image processing configuration used either in the this material.\r\n         *\r\n         * If sets to null, the scene one is in use.\r\n         */\r\n        set: function (value) {\r\n            this._attachImageProcessingConfiguration(value);\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    StandardMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\r\n        var _this = this;\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n        // Detaches observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n        // Pick the scene configuration if needed\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        }\r\n        else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n        // Attaches observer\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\r\n                _this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    };\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurvesEnabled\", {\r\n        /**\r\n         * Gets wether the color curves effect is enabled.\r\n         */\r\n        get: function () {\r\n            return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n        },\r\n        /**\r\n         * Sets wether the color curves effect is enabled.\r\n         */\r\n        set: function (value) {\r\n            this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingEnabled\", {\r\n        /**\r\n         * Gets wether the color grading effect is enabled.\r\n         */\r\n        get: function () {\r\n            return this.imageProcessingConfiguration.colorGradingEnabled;\r\n        },\r\n        /**\r\n         * Gets wether the color grading effect is enabled.\r\n         */\r\n        set: function (value) {\r\n            this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraToneMappingEnabled\", {\r\n        /**\r\n         * Gets wether tonemapping is enabled or not.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.toneMappingEnabled;\r\n        },\r\n        /**\r\n         * Sets wether tonemapping is enabled or not\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraExposure\", {\r\n        /**\r\n         * The camera exposure used on this material.\r\n         * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n         * This corresponds to a photographic exposure.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.exposure;\r\n        },\r\n        /**\r\n         * The camera exposure used on this material.\r\n         * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n         * This corresponds to a photographic exposure.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.exposure = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraContrast\", {\r\n        /**\r\n         * Gets The camera contrast used on this material.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.contrast;\r\n        },\r\n        /**\r\n         * Sets The camera contrast used on this material.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.contrast = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingTexture\", {\r\n        /**\r\n         * Gets the Color Grading 2D Lookup Texture.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.colorGradingTexture;\r\n        },\r\n        /**\r\n         * Sets the Color Grading 2D Lookup Texture.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.colorGradingTexture = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurves\", {\r\n        /**\r\n         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n         * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.colorCurves;\r\n        },\r\n        /**\r\n         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n         * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.colorCurves = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"canRenderToMRT\", {\r\n        /**\r\n         * Can this material render to several textures at once\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"hasRenderTargetTextures\", {\r\n        /**\r\n         * Gets a boolean indicating that current material needs to register RTT\r\n         */\r\n        get: function () {\r\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                return true;\r\n            }\r\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    StandardMaterial.prototype.getClassName = function () {\r\n        return \"StandardMaterial\";\r\n    };\r\n    Object.defineProperty(StandardMaterial.prototype, \"useLogarithmicDepth\", {\r\n        /**\r\n         * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n         * You can try switching to logarithmic depth.\r\n         * @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer\r\n         */\r\n        get: function () {\r\n            return this._useLogarithmicDepth;\r\n        },\r\n        set: function (value) {\r\n            this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n            this._markAllSubMeshesAsMiscDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    StandardMaterial.prototype.needAlphaBlending = function () {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n        return (this.alpha < 1.0) || (this._opacityTexture != null) || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\r\n    };\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    StandardMaterial.prototype.needAlphaTesting = function () {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    };\r\n    /**\r\n     * Specifies whether or not the alpha value of the diffuse texture should be used for alpha blending.\r\n     */\r\n    StandardMaterial.prototype._shouldUseAlphaFromDiffuseTexture = function () {\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\r\n    };\r\n    /**\r\n     * Specifies whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    StandardMaterial.prototype._hasAlphaChannel = function () {\r\n        return (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._opacityTexture != null;\r\n    };\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns the diffuse texture in case of the standard material.\r\n     */\r\n    StandardMaterial.prototype.getAlphaTestTexture = function () {\r\n        return this._diffuseTexture;\r\n    };\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    StandardMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\r\n        if (useInstances === void 0) { useInstances = false; }\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new StandardMaterialDefines();\r\n        }\r\n        var scene = this.getScene();\r\n        var defines = subMesh._materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n        var engine = scene.getEngine();\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n        // PrePass\r\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT);\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            defines.MAINUV1 = false;\r\n            defines.MAINUV2 = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.DIFFUSE = false;\r\n                }\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.OPACITY = false;\r\n                }\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        defines._needNormals = true;\r\n                        defines.REFLECTION = true;\r\n                        defines.ROUGHNESS = (this._roughness > 0);\r\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\r\n                        defines.INVERTCUBICMAP = (this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE);\r\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\r\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\r\n                        switch (this._reflectionTexture.coordinatesMode) {\r\n                            case Texture.EXPLICIT_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\r\n                                break;\r\n                            case Texture.PLANAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\r\n                                break;\r\n                            case Texture.PROJECTION_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\r\n                                break;\r\n                            case Texture.SKYBOX_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\r\n                                break;\r\n                            case Texture.SPHERICAL_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\r\n                                break;\r\n                            case Texture.EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.CUBIC_MODE:\r\n                            case Texture.INVCUBIC_MODE:\r\n                            default:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\r\n                                break;\r\n                        }\r\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.REFLECTION = false;\r\n                }\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\r\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.SPECULAR = false;\r\n                }\r\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                    // Bump texure can not be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n                        defines.PARALLAX = this._useParallax;\r\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\r\n                    }\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                }\r\n                else {\r\n                    defines.BUMP = false;\r\n                }\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        defines._needUVs = true;\r\n                        defines.REFRACTION = true;\r\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\r\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.REFRACTION = false;\r\n                }\r\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\r\n            }\r\n            else {\r\n                defines.DIFFUSE = false;\r\n                defines.AMBIENT = false;\r\n                defines.OPACITY = false;\r\n                defines.REFLECTION = false;\r\n                defines.EMISSIVE = false;\r\n                defines.LIGHTMAP = false;\r\n                defines.BUMP = false;\r\n                defines.REFRACTION = false;\r\n            }\r\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\r\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\r\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n            defines.PREMULTIPLYALPHA = (this.alphaMode === 7 || this.alphaMode === 8);\r\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\r\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\r\n        }\r\n        if (!this.detailMap.isReadyForSubMesh(defines, scene)) {\r\n            return false;\r\n        }\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n            defines.IS_REFLECTION_LINEAR = (this.reflectionTexture != null && !this.reflectionTexture.gammaSpace);\r\n            defines.IS_REFRACTION_LINEAR = (this.refractionTexture != null && !this.refractionTexture.gammaSpace);\r\n        }\r\n        if (defines._areFresnelDirty) {\r\n            if (StandardMaterial.FresnelEnabled) {\r\n                // Fresnel\r\n                if (this._diffuseFresnelParameters || this._opacityFresnelParameters ||\r\n                    this._emissiveFresnelParameters || this._refractionFresnelParameters ||\r\n                    this._reflectionFresnelParameters) {\r\n                    defines.DIFFUSEFRESNEL = (this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled);\r\n                    defines.OPACITYFRESNEL = (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled);\r\n                    defines.REFLECTIONFRESNEL = (this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled);\r\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\r\n                    defines.REFRACTIONFRESNEL = (this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled);\r\n                    defines.EMISSIVEFRESNEL = (this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled);\r\n                    defines._needNormals = true;\r\n                    defines.FRESNEL = true;\r\n                }\r\n            }\r\n            else {\r\n                defines.FRESNEL = false;\r\n            }\r\n        }\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n        // External config\r\n        this.detailMap.prepareDefines(defines, scene);\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            var lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.REFLECTION) {\r\n                fallbacks.addFallback(0, \"REFLECTION\");\r\n            }\r\n            if (defines.SPECULAR) {\r\n                fallbacks.addFallback(0, \"SPECULAR\");\r\n            }\r\n            if (defines.BUMP) {\r\n                fallbacks.addFallback(0, \"BUMP\");\r\n            }\r\n            if (defines.PARALLAX) {\r\n                fallbacks.addFallback(1, \"PARALLAX\");\r\n            }\r\n            if (defines.PARALLAXOCCLUSION) {\r\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\r\n            }\r\n            if (defines.SPECULAROVERALPHA) {\r\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\r\n            }\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(0, \"POINTSIZE\");\r\n            }\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n            if (defines.SPECULARTERM) {\r\n                fallbacks.addFallback(0, \"SPECULARTERM\");\r\n            }\r\n            if (defines.DIFFUSEFRESNEL) {\r\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\r\n            }\r\n            if (defines.OPACITYFRESNEL) {\r\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\r\n            }\r\n            if (defines.REFLECTIONFRESNEL) {\r\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\r\n            }\r\n            if (defines.EMISSIVEFRESNEL) {\r\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\r\n            }\r\n            if (defines.FRESNEL) {\r\n                fallbacks.addFallback(4, \"FRESNEL\");\r\n            }\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n            MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n            var shaderName = \"default\";\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\", \"visibility\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"normalMatrix\", \"lightmapMatrix\", \"refractionMatrix\",\r\n                \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\",\r\n                \"vReflectionPosition\", \"vReflectionSize\",\r\n                \"logarithmicDepthConstant\", \"vTangentSpaceParams\", \"alphaCutOff\", \"boneTextureWidth\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\",\r\n                \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\",\r\n                \"refractionCubeSampler\", \"refraction2DSampler\", \"boneSampler\"];\r\n            var uniformBuffers = [\"Material\", \"Scene\"];\r\n            DetailMapConfiguration.AddUniforms(uniforms);\r\n            DetailMapConfiguration.AddSamplers(samplers);\r\n            PrePassConfiguration.AddUniforms(uniforms);\r\n            PrePassConfiguration.AddSamplers(uniforms);\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n            MaterialHelper.PrepareUniformsAndSamplersList({\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights\r\n            });\r\n            var csnrOptions = {};\r\n            if (this.customShaderNameResolve) {\r\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n            }\r\n            var join = defines.toString();\r\n            var previousEffect = subMesh.effect;\r\n            var effect = scene.getEngine().createEffect(shaderName, {\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                multiTarget: defines.PREPASS\r\n            }, engine);\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    this._rebuildInParallel = true;\r\n                    defines.markAsUnprocessed();\r\n                    if (lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    this._rebuildInParallel = false;\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines);\r\n                    this.buildUniformLayout();\r\n                }\r\n            }\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        return true;\r\n    };\r\n    /**\r\n     * Builds the material UBO layouts.\r\n     * Used internally during the effect preparation.\r\n     */\r\n    StandardMaterial.prototype.buildUniformLayout = function () {\r\n        // Order is important !\r\n        var ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"diffuseLeftColor\", 4);\r\n        ubo.addUniform(\"diffuseRightColor\", 4);\r\n        ubo.addUniform(\"opacityParts\", 4);\r\n        ubo.addUniform(\"reflectionLeftColor\", 4);\r\n        ubo.addUniform(\"reflectionRightColor\", 4);\r\n        ubo.addUniform(\"refractionLeftColor\", 4);\r\n        ubo.addUniform(\"refractionRightColor\", 4);\r\n        ubo.addUniform(\"emissiveLeftColor\", 4);\r\n        ubo.addUniform(\"emissiveRightColor\", 4);\r\n        ubo.addUniform(\"vDiffuseInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 2);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vSpecularInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n        ubo.addUniform(\"diffuseMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"specularMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"refractionMatrix\", 16);\r\n        ubo.addUniform(\"vRefractionInfos\", 4);\r\n        ubo.addUniform(\"vSpecularColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"visibility\", 1);\r\n        ubo.addUniform(\"vDiffuseColor\", 4);\r\n        DetailMapConfiguration.PrepareUniformBuffer(ubo);\r\n        ubo.create();\r\n    };\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    StandardMaterial.prototype.unbind = function () {\r\n        if (this._activeEffect) {\r\n            var needFlag = false;\r\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"reflection2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n            if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"refraction2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n            if (needFlag) {\r\n                this._markAllSubMeshesAsTexturesDirty();\r\n            }\r\n        }\r\n        _super.prototype.unbind.call(this);\r\n    };\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    StandardMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\r\n        var scene = this.getScene();\r\n        var defines = subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCES) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        // PrePass\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n        var mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, effect);\r\n        var ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            ubo.bindToEffect(effect, \"Material\");\r\n            this.bindViewProjection(effect);\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {\r\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\r\n                    // Fresnel\r\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\r\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\r\n                    }\r\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"opacityParts\", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\r\n                    }\r\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\r\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\r\n                    }\r\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\r\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\r\n                    }\r\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\r\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\r\n                    }\r\n                }\r\n                // Textures\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\r\n                    }\r\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n                    if (this._hasAlphaChannel()) {\r\n                        effect.setFloat(\"alphaCutOff\", this.alphaCutOff);\r\n                    }\r\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\r\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\r\n                        if (this._reflectionTexture.boundingBoxSize) {\r\n                            var cubeTexture = this._reflectionTexture;\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, \"specular\");\r\n                    }\r\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\r\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        }\r\n                        else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                        var depth = 1.0;\r\n                        if (!this._refractionTexture.isCube) {\r\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\r\n                            if (this._refractionTexture.depth) {\r\n                                depth = this._refractionTexture.depth;\r\n                            }\r\n                        }\r\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n                    }\r\n                }\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n                if (defines.SPECULARTERM) {\r\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n                }\r\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\r\n                // Diffuse\r\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\r\n            }\r\n            // Visibility\r\n            ubo.updateFloat(\"visibility\", mesh.visibility);\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (this._reflectionTexture.isCube) {\r\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\r\n                    }\r\n                    else {\r\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\r\n                    }\r\n                }\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\r\n                }\r\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    var depth = 1.0;\r\n                    if (this._refractionTexture.isCube) {\r\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\r\n                    }\r\n                    else {\r\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\r\n                    }\r\n                }\r\n            }\r\n            this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(effect, scene);\r\n            // Colors\r\n            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n            effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n        }\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights, this._rebuildInParallel);\r\n            }\r\n            // View\r\n            if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {\r\n                this.bindView(effect);\r\n            }\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, effect);\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n            }\r\n            // Log. depth\r\n            if (this.useLogarithmicDepth) {\r\n                MaterialHelper.BindLogDepth(defines, effect, scene);\r\n            }\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n        ubo.update();\r\n        this._afterBind(mesh, this._activeEffect);\r\n    };\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    StandardMaterial.prototype.getAnimatables = function () {\r\n        var results = [];\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\r\n            results.push(this._specularTexture);\r\n        }\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            results.push(this._refractionTexture);\r\n        }\r\n        this.detailMap.getAnimatables(results);\r\n        return results;\r\n    };\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    StandardMaterial.prototype.getActiveTextures = function () {\r\n        var activeTextures = _super.prototype.getActiveTextures.call(this);\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n        if (this._specularTexture) {\r\n            activeTextures.push(this._specularTexture);\r\n        }\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n        this.detailMap.getActiveTextures(activeTextures);\r\n        return activeTextures;\r\n    };\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    StandardMaterial.prototype.hasTexture = function (texture) {\r\n        if (_super.prototype.hasTexture.call(this, texture)) {\r\n            return true;\r\n        }\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._specularTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n        return this.detailMap.hasTexture(texture);\r\n    };\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     */\r\n    StandardMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        if (forceDisposeTextures) {\r\n            (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();\r\n            (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\r\n            (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\r\n            (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\r\n            (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\r\n            (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();\r\n            (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();\r\n            (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();\r\n            (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();\r\n        }\r\n        this.detailMap.dispose(forceDisposeTextures);\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\r\n    };\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    StandardMaterial.prototype.clone = function (name) {\r\n        var _this = this;\r\n        var result = SerializationHelper.Clone(function () { return new StandardMaterial(name, _this.getScene()); }, this);\r\n        result.name = name;\r\n        result.id = name;\r\n        return result;\r\n    };\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    StandardMaterial.prototype.serialize = function () {\r\n        return SerializationHelper.Serialize(this);\r\n    };\r\n    /**\r\n     * Creates a standard material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new standard material\r\n     */\r\n    StandardMaterial.Parse = function (source, scene, rootUrl) {\r\n        return SerializationHelper.Parse(function () { return new StandardMaterial(source.name, scene); }, source, scene, rootUrl);\r\n    };\r\n    Object.defineProperty(StandardMaterial, \"DiffuseTextureEnabled\", {\r\n        // Flags used to enable or disable a type of texture for all Standard Materials\r\n        /**\r\n         * Are diffuse textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.DiffuseTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.DiffuseTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"DetailTextureEnabled\", {\r\n        /**\r\n         * Are detail textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.DetailTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.DetailTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"AmbientTextureEnabled\", {\r\n        /**\r\n         * Are ambient textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.AmbientTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.AmbientTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"OpacityTextureEnabled\", {\r\n        /**\r\n         * Are opacity textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.OpacityTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.OpacityTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"ReflectionTextureEnabled\", {\r\n        /**\r\n         * Are reflection textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.ReflectionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.ReflectionTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"EmissiveTextureEnabled\", {\r\n        /**\r\n         * Are emissive textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.EmissiveTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.EmissiveTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"SpecularTextureEnabled\", {\r\n        /**\r\n         * Are specular textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.SpecularTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.SpecularTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"BumpTextureEnabled\", {\r\n        /**\r\n         * Are bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.BumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.BumpTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"LightmapTextureEnabled\", {\r\n        /**\r\n         * Are lightmap textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.LightmapTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.LightmapTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"RefractionTextureEnabled\", {\r\n        /**\r\n         * Are refraction textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.RefractionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.RefractionTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"ColorGradingTextureEnabled\", {\r\n        /**\r\n         * Are color grading textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.ColorGradingTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.ColorGradingTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"FresnelEnabled\", {\r\n        /**\r\n         * Are fresnels enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.FresnelEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.FresnelEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    __decorate([\r\n        serializeAsTexture(\"diffuseTexture\")\r\n    ], StandardMaterial.prototype, \"_diffuseTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"diffuseTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"ambientTexture\")\r\n    ], StandardMaterial.prototype, \"_ambientTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"ambientTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"opacityTexture\")\r\n    ], StandardMaterial.prototype, \"_opacityTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"opacityTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"reflectionTexture\")\r\n    ], StandardMaterial.prototype, \"_reflectionTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"reflectionTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"emissiveTexture\")\r\n    ], StandardMaterial.prototype, \"_emissiveTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"emissiveTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"specularTexture\")\r\n    ], StandardMaterial.prototype, \"_specularTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"specularTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"bumpTexture\")\r\n    ], StandardMaterial.prototype, \"_bumpTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"bumpTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"lightmapTexture\")\r\n    ], StandardMaterial.prototype, \"_lightmapTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"lightmapTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"refractionTexture\")\r\n    ], StandardMaterial.prototype, \"_refractionTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"refractionTexture\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"ambient\")\r\n    ], StandardMaterial.prototype, \"ambientColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"diffuse\")\r\n    ], StandardMaterial.prototype, \"diffuseColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"specular\")\r\n    ], StandardMaterial.prototype, \"specularColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"emissive\")\r\n    ], StandardMaterial.prototype, \"emissiveColor\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"specularPower\", void 0);\r\n    __decorate([\r\n        serialize(\"useAlphaFromDiffuseTexture\")\r\n    ], StandardMaterial.prototype, \"_useAlphaFromDiffuseTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"useAlphaFromDiffuseTexture\", void 0);\r\n    __decorate([\r\n        serialize(\"useEmissiveAsIllumination\")\r\n    ], StandardMaterial.prototype, \"_useEmissiveAsIllumination\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useEmissiveAsIllumination\", void 0);\r\n    __decorate([\r\n        serialize(\"linkEmissiveWithDiffuse\")\r\n    ], StandardMaterial.prototype, \"_linkEmissiveWithDiffuse\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"linkEmissiveWithDiffuse\", void 0);\r\n    __decorate([\r\n        serialize(\"useSpecularOverAlpha\")\r\n    ], StandardMaterial.prototype, \"_useSpecularOverAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useSpecularOverAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"useReflectionOverAlpha\")\r\n    ], StandardMaterial.prototype, \"_useReflectionOverAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useReflectionOverAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"disableLighting\")\r\n    ], StandardMaterial.prototype, \"_disableLighting\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    ], StandardMaterial.prototype, \"disableLighting\", void 0);\r\n    __decorate([\r\n        serialize(\"useObjectSpaceNormalMap\")\r\n    ], StandardMaterial.prototype, \"_useObjectSpaceNormalMap\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useObjectSpaceNormalMap\", void 0);\r\n    __decorate([\r\n        serialize(\"useParallax\")\r\n    ], StandardMaterial.prototype, \"_useParallax\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useParallax\", void 0);\r\n    __decorate([\r\n        serialize(\"useParallaxOcclusion\")\r\n    ], StandardMaterial.prototype, \"_useParallaxOcclusion\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useParallaxOcclusion\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"parallaxScaleBias\", void 0);\r\n    __decorate([\r\n        serialize(\"roughness\")\r\n    ], StandardMaterial.prototype, \"_roughness\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"roughness\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"indexOfRefraction\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"invertRefractionY\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"alphaCutOff\", void 0);\r\n    __decorate([\r\n        serialize(\"useLightmapAsShadowmap\")\r\n    ], StandardMaterial.prototype, \"_useLightmapAsShadowmap\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"diffuseFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_diffuseFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"diffuseFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"opacityFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_opacityFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"opacityFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"reflectionFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_reflectionFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"reflectionFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"refractionFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_refractionFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"refractionFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"emissiveFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_emissiveFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"emissiveFresnelParameters\", void 0);\r\n    __decorate([\r\n        serialize(\"useReflectionFresnelFromSpecular\")\r\n    ], StandardMaterial.prototype, \"_useReflectionFresnelFromSpecular\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"useReflectionFresnelFromSpecular\", void 0);\r\n    __decorate([\r\n        serialize(\"useGlossinessFromSpecularMapAlpha\")\r\n    ], StandardMaterial.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"maxSimultaneousLights\")\r\n    ], StandardMaterial.prototype, \"_maxSimultaneousLights\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    ], StandardMaterial.prototype, \"maxSimultaneousLights\", void 0);\r\n    __decorate([\r\n        serialize(\"invertNormalMapX\")\r\n    ], StandardMaterial.prototype, \"_invertNormalMapX\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"invertNormalMapX\", void 0);\r\n    __decorate([\r\n        serialize(\"invertNormalMapY\")\r\n    ], StandardMaterial.prototype, \"_invertNormalMapY\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"invertNormalMapY\", void 0);\r\n    __decorate([\r\n        serialize(\"twoSidedLighting\")\r\n    ], StandardMaterial.prototype, \"_twoSidedLighting\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"twoSidedLighting\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"useLogarithmicDepth\", null);\r\n    return StandardMaterial;\r\n}(PushMaterial));\r\nexport { StandardMaterial };\r\n_TypeStore.RegisteredTypes[\"BABYLON.StandardMaterial\"] = StandardMaterial;\r\nScene.DefaultMaterialFactory = function (scene) {\r\n    return new StandardMaterial(\"default material\", scene);\r\n};\r\n//# sourceMappingURL=standardMaterial.js.map","import { __extends } from \"tslib\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from './transformNode';\r\nimport { VertexBuffer } from './buffer';\r\nimport { BoundingInfo } from '../Culling/boundingInfo';\r\nimport { Tools } from '../Misc/tools';\r\nMesh._instancedMeshFactory = function (name, mesh) {\r\n    var instance = new InstancedMesh(name, mesh);\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n        for (var key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n    return instance;\r\n};\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nvar InstancedMesh = /** @class */ (function (_super) {\r\n    __extends(InstancedMesh, _super);\r\n    function InstancedMesh(name, source) {\r\n        var _this = _super.call(this, name, source.getScene()) || this;\r\n        /** @hidden */\r\n        _this._indexInSourceMeshInstanceArray = -1;\r\n        source.addInstance(_this);\r\n        _this._sourceMesh = source;\r\n        _this._unIndexed = source._unIndexed;\r\n        _this.position.copyFrom(source.position);\r\n        _this.rotation.copyFrom(source.rotation);\r\n        _this.scaling.copyFrom(source.scaling);\r\n        if (source.rotationQuaternion) {\r\n            _this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n        _this.animations = Tools.Slice(source.animations);\r\n        for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\r\n            var range = _a[_i];\r\n            if (range != null) {\r\n                _this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n        _this.infiniteDistance = source.infiniteDistance;\r\n        _this.setPivotMatrix(source.getPivotMatrix());\r\n        _this.refreshBoundingInfo();\r\n        _this._syncSubMeshes();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    InstancedMesh.prototype.getClassName = function () {\r\n        return \"InstancedMesh\";\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\r\n        /** Gets the list of lights affecting that mesh */\r\n        get: function () {\r\n            return this._sourceMesh._lightSources;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    InstancedMesh.prototype._resyncLightSources = function () {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._resyncLightSource = function (light) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._removeLightSource = function (light, dispose) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\r\n        // Methods\r\n        /**\r\n         * If the source mesh receives shadows\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.receiveShadows;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"material\", {\r\n        /**\r\n         * The material of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.material;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\r\n        /**\r\n         * Visibility of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.visibility;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\r\n        /**\r\n         * Skeleton of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.skeleton;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\r\n        /**\r\n         * Rendering ground id of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.renderingGroupId;\r\n        },\r\n        set: function (value) {\r\n            if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n                return;\r\n            }\r\n            //no-op with warning\r\n            Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    InstancedMesh.prototype.getTotalVertices = function () {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    };\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    InstancedMesh.prototype.getTotalIndices = function () {\r\n        return this._sourceMesh.getTotalIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\r\n        /**\r\n         * The source mesh of the instance\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    InstancedMesh.prototype.createInstance = function (name) {\r\n        return this._sourceMesh.createInstance(name);\r\n    };\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    InstancedMesh.prototype.isReady = function (completeCheck) {\r\n        if (completeCheck === void 0) { completeCheck = false; }\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    };\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n     */\r\n    InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    };\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     */\r\n    InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    };\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    InstancedMesh.prototype.getIndices = function () {\r\n        return this._sourceMesh.getIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\r\n        get: function () {\r\n            return this._sourceMesh._positions;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\r\n        if (applySkeleton === void 0) { applySkeleton = false; }\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n        var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._preActivate = function () {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n        if (this._currentLOD) {\r\n            var differentSign = (this._currentLOD._getWorldMatrixDeterminant() > 0) !== (this._getWorldMatrixDeterminant() > 0);\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._postActivate = function () {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        }\r\n        else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    };\r\n    InstancedMesh.prototype.getWorldMatrix = function () {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            var tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return TmpVectors.Matrix[0];\r\n        }\r\n        return _super.prototype.getWorldMatrix.call(this);\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     */\r\n    InstancedMesh.prototype.getLOD = function (camera) {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n        var boundingInfo = this.getBoundingInfo();\r\n        this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        if (this._currentLOD === this.sourceMesh) {\r\n            return this.sourceMesh;\r\n        }\r\n        return this._currentLOD;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\r\n        return this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._syncSubMeshes = function () {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._generatePointsArray = function () {\r\n        return this._sourceMesh._generatePointsArray();\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._updateBoundingInfo = function () {\r\n        var effectiveMesh = this;\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\r\n        return this;\r\n    };\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     */\r\n    InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\r\n        if (newParent === void 0) { newParent = null; }\r\n        var result = this._sourceMesh.createInstance(name);\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(this, result, [\r\n            \"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\",\r\n            \"receiveShadows\", \"material\", \"visibility\", \"skeleton\",\r\n            \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\",\r\n            \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\",\r\n            \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\",\r\n            \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"\r\n        ], []);\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\r\n                var mesh = this.getScene().meshes[index];\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n        result.computeWorldMatrix(true);\r\n        return result;\r\n    };\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     */\r\n    InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\r\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\r\n    };\r\n    return InstancedMesh;\r\n}(AbstractMesh));\r\nexport { InstancedMesh };\r\nMesh.prototype.edgesShareWithInstances = false;\r\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\r\n    // Remove existing one\r\n    this.removeVerticesData(kind);\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n        for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\r\n            var instance = _a[_i];\r\n            instance.instancedBuffers = {};\r\n        }\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {}\r\n        };\r\n    }\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n    this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\r\n    for (var _b = 0, _c = this.instances; _b < _c.length; _b++) {\r\n        var instance = _c[_b];\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n};\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\r\n    var instanceCount = visibleInstances.length;\r\n    for (var kind in this.instancedBuffers) {\r\n        var size = this._userInstancedBuffersStorage.sizes[kind];\r\n        var stride = this._userInstancedBuffersStorage.strides[kind];\r\n        // Resize if required\r\n        var expectedSize = (instanceCount + 1) * stride;\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n        var data = this._userInstancedBuffersStorage.data[kind];\r\n        // Update data buffer\r\n        var offset = 0;\r\n        if (renderSelf) {\r\n            var value = this.instancedBuffers[kind];\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            }\r\n            else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n            offset += stride;\r\n        }\r\n        for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            var instance = visibleInstances[instanceIndex];\r\n            var value = instance.instancedBuffers[kind];\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            }\r\n            else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n            offset += stride;\r\n        }\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n            this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\r\n        }\r\n        else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n    for (var kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\r\n        }\r\n    }\r\n    this.instancedBuffers = {};\r\n};\r\n//# sourceMappingURL=instancedMesh.js.map","import { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Animation } from \"./animation\";\r\nimport { Size } from '../Maths/math.size';\r\n// Static values to help the garbage collector\r\n// Quaternion\r\nvar _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n// Vector3\r\nvar _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());\r\n// Vector2\r\nvar _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());\r\n// Size\r\nvar _staticOffsetValueSize = Object.freeze(Size.Zero());\r\n// Color3\r\nvar _staticOffsetValueColor3 = Object.freeze(Color3.Black());\r\n/**\r\n * Defines a runtime animation\r\n */\r\nvar RuntimeAnimation = /** @class */ (function () {\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    function RuntimeAnimation(target, animation, scene, host) {\r\n        var _this = this;\r\n        this._events = new Array();\r\n        /**\r\n         * The current frame of the runtime animation\r\n         */\r\n        this._currentFrame = 0;\r\n        /**\r\n         * The original value of the runtime animation\r\n         */\r\n        this._originalValue = new Array();\r\n        /**\r\n         * The original blend value of the runtime animation\r\n         */\r\n        this._originalBlendValue = null;\r\n        /**\r\n         * The offsets cache of the runtime animation\r\n         */\r\n        this._offsetsCache = {};\r\n        /**\r\n         * The high limits cache of the runtime animation\r\n         */\r\n        this._highLimitsCache = {};\r\n        /**\r\n         * Specifies if the runtime animation has been stopped\r\n         */\r\n        this._stopped = false;\r\n        /**\r\n         * The blending factor of the runtime animation\r\n         */\r\n        this._blendingFactor = 0;\r\n        /**\r\n         * The current value of the runtime animation\r\n         */\r\n        this._currentValue = null;\r\n        this._currentActiveTarget = null;\r\n        this._directTarget = null;\r\n        /**\r\n         * The target path of the runtime animation\r\n         */\r\n        this._targetPath = \"\";\r\n        /**\r\n         * The weight of the runtime animation\r\n         */\r\n        this._weight = 1.0;\r\n        /**\r\n         * The ratio offset of the runtime animation\r\n         */\r\n        this._ratioOffset = 0;\r\n        /**\r\n         * The previous delay of the runtime animation\r\n         */\r\n        this._previousDelay = 0;\r\n        /**\r\n         * The previous ratio of the runtime animation\r\n         */\r\n        this._previousRatio = 0;\r\n        this._targetIsArray = false;\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n        animation._runtimeAnimations.push(this);\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode()\r\n        };\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            var newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            var index = 0;\r\n            for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\r\n                var target_1 = _a[_i];\r\n                this._preparePath(target_1, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        }\r\n        else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n        // Cloning events locally\r\n        var events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach(function (e) {\r\n                _this._events.push(e._clone());\r\n            });\r\n        }\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"currentFrame\", {\r\n        /**\r\n         * Gets the current frame of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentFrame;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"weight\", {\r\n        /**\r\n         * Gets the weight of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._weight;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"currentValue\", {\r\n        /**\r\n         * Gets the current value of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentValue;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"targetPath\", {\r\n        /**\r\n         * Gets the target path of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._targetPath;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"target\", {\r\n        /**\r\n         * Gets the actual target of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentActiveTarget;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"isAdditive\", {\r\n        /**\r\n         * Gets the additive state of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._host && this._host.isAdditive;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    RuntimeAnimation.prototype._preparePath = function (target, targetIndex) {\r\n        if (targetIndex === void 0) { targetIndex = 0; }\r\n        var targetPropertyPath = this._animation.targetPropertyPath;\r\n        if (targetPropertyPath.length > 1) {\r\n            var property = target[targetPropertyPath[0]];\r\n            for (var index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        }\r\n        else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    };\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"animation\", {\r\n        /**\r\n         * Gets the animation from the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._animation;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    RuntimeAnimation.prototype.reset = function (restoreOriginal) {\r\n        if (restoreOriginal === void 0) { restoreOriginal = false; }\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                var index = 0;\r\n                for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\r\n                    var target = _a[_i];\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n            else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n        // Events\r\n        for (var index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    };\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    RuntimeAnimation.prototype.isStopped = function () {\r\n        return this._stopped;\r\n    };\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    RuntimeAnimation.prototype.dispose = function () {\r\n        var index = this._animation.runtimeAnimations.indexOf(this);\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    };\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    RuntimeAnimation.prototype.setValue = function (currentValue, weight) {\r\n        if (this._targetIsArray) {\r\n            for (var index = 0; index < this._target.length; index++) {\r\n                var target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    };\r\n    RuntimeAnimation.prototype._getOriginalValues = function (targetIndex) {\r\n        if (targetIndex === void 0) { targetIndex = 0; }\r\n        var originalValue;\r\n        var target = this._activeTargets[targetIndex];\r\n        if (target.getRestPose && this._targetPath === \"_matrix\") { // For bones\r\n            originalValue = target.getRestPose();\r\n        }\r\n        else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        }\r\n        else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    };\r\n    RuntimeAnimation.prototype._setValue = function (target, destination, currentValue, weight, targetIndex) {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n        this._weight = weight;\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                var originalValue = destination[this._targetPath];\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                }\r\n                else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n            if (this._originalBlendValue.m) { // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    }\r\n                    else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    }\r\n                    else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n            var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        }\r\n        else {\r\n            this._currentValue = currentValue;\r\n        }\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        }\r\n        else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    RuntimeAnimation.prototype._getCorrectLoopMode = function () {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n        return this._animation.loopMode;\r\n    };\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    RuntimeAnimation.prototype.goToFrame = function (frame) {\r\n        var keys = this._animation.getKeys();\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        }\r\n        else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n        // Need to reset animation events\r\n        var events = this._events;\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = frame;\r\n        var currentValue = this._animation._interpolate(frame, this._animationState);\r\n        this.setValue(currentValue, -1);\r\n    };\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    RuntimeAnimation.prototype._prepareForSpeedRatioChange = function (newSpeedRatio) {\r\n        var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\r\n        this._ratioOffset = this._previousRatio - newRatio;\r\n    };\r\n    /**\r\n     * Execute the current animation\r\n     * @param delay defines the delay to add to the current frame\r\n     * @param from defines the lower bound of the animation range\r\n     * @param to defines the upper bound of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @param onLoop optional callback called when animation loops\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    RuntimeAnimation.prototype.animate = function (delay, from, to, loop, speedRatio, weight) {\r\n        if (weight === void 0) { weight = -1.0; }\r\n        var animation = this._animation;\r\n        var targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n        var returnValue = true;\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n        var range = to - from;\r\n        var offsetValue;\r\n        // Compute ratio which represents the frame delta between from and to\r\n        var ratio = (delay * (animation.framePerSecond * speedRatio) / 1000.0) + this._ratioOffset;\r\n        var highLimitValue = 0;\r\n        this._previousDelay = delay;\r\n        this._previousRatio = ratio;\r\n        if (!loop && (to >= from && ratio >= range)) { // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        }\r\n        else if (!loop && (from >= to && ratio <= range)) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        }\r\n        else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            var keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\r\n                var fromValue = animation._interpolate(from, this._animationState);\r\n                var toValue = animation._interpolate(to, this._animationState);\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    default:\r\n                        break;\r\n                }\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n        // Compute value\r\n        var currentFrame;\r\n        if (this._host && this._host.syncRoot) {\r\n            var syncRoot = this._host.syncRoot;\r\n            var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + (to - from) * hostNormalizedFrame;\r\n        }\r\n        else {\r\n            currentFrame = (returnValue && range !== 0) ? from + ratio % range : to;\r\n        }\r\n        // Reset events if looping\r\n        var events = this._events;\r\n        if (range > 0 && this.currentFrame > currentFrame ||\r\n            range < 0 && this.currentFrame < currentFrame) {\r\n            this._onLoop();\r\n            // Need to reset animation events\r\n            if (events.length) {\r\n                for (var index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = range === 0 ? 0 : (ratio / range) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n        var currentValue = animation._interpolate(currentFrame, this._animationState);\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n        // Check events\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if ((range > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (range < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\r\n                    var event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already be done.\r\n                }\r\n            }\r\n        }\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n        return returnValue;\r\n    };\r\n    return RuntimeAnimation;\r\n}());\r\nexport { RuntimeAnimation };\r\n//# sourceMappingURL=runtimeAnimation.js.map","import { __extends } from \"tslib\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from '../Maths/math.axis';\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nvar Bone = /** @class */ (function (_super) {\r\n    __extends(Bone, _super);\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix\r\n     * @param restPose defines the rest pose matrix\r\n     * @param baseMatrix defines the base matrix\r\n     * @param index defines index of the bone in the hiearchy\r\n     */\r\n    function Bone(\r\n    /**\r\n     * defines the bone name\r\n     */\r\n    name, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {\r\n        if (parentBone === void 0) { parentBone = null; }\r\n        if (localMatrix === void 0) { localMatrix = null; }\r\n        if (restPose === void 0) { restPose = null; }\r\n        if (baseMatrix === void 0) { baseMatrix = null; }\r\n        if (index === void 0) { index = null; }\r\n        var _this = _super.call(this, name, skeleton.getScene()) || this;\r\n        _this.name = name;\r\n        /**\r\n         * Gets the list of child bones\r\n         */\r\n        _this.children = new Array();\r\n        /** Gets the animations associated with this bone */\r\n        _this.animations = new Array();\r\n        /**\r\n         * @hidden Internal only\r\n         * Set this value to map this bone to a different index in the transform matrices\r\n         * Set this value to -1 to exclude the bone from the transform matrices\r\n         */\r\n        _this._index = null;\r\n        _this._absoluteTransform = new Matrix();\r\n        _this._invertedAbsoluteTransform = new Matrix();\r\n        _this._scalingDeterminant = 1;\r\n        _this._worldTransform = new Matrix();\r\n        _this._needToDecompose = true;\r\n        _this._needToCompose = false;\r\n        /** @hidden */\r\n        _this._linkedTransformNode = null;\r\n        /** @hidden */\r\n        _this._waitingTransformNodeId = null;\r\n        _this._skeleton = skeleton;\r\n        _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\r\n        _this._restPose = restPose ? restPose : _this._localMatrix.clone();\r\n        _this._bindPose = _this._localMatrix.clone();\r\n        _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();\r\n        _this._index = index;\r\n        skeleton.bones.push(_this);\r\n        _this.setParent(parentBone, false);\r\n        if (baseMatrix || localMatrix) {\r\n            _this._updateDifferenceMatrix();\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Bone.prototype, \"_matrix\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            this._compose();\r\n            return this._localMatrix;\r\n        },\r\n        /** @hidden */\r\n        set: function (value) {\r\n            this._localMatrix.copyFrom(value);\r\n            this._needToDecompose = true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    Bone.prototype.getClassName = function () {\r\n        return \"Bone\";\r\n    };\r\n    // Members\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    Bone.prototype.getSkeleton = function () {\r\n        return this._skeleton;\r\n    };\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    Bone.prototype.getParent = function () {\r\n        return this._parent;\r\n    };\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    Bone.prototype.getChildren = function () {\r\n        return this.children;\r\n    };\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    Bone.prototype.getIndex = function () {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    };\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     */\r\n    Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\r\n        if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\r\n        if (this._parent === parent) {\r\n            return;\r\n        }\r\n        if (this._parent) {\r\n            var index = this._parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this._parent.children.splice(index, 1);\r\n            }\r\n        }\r\n        this._parent = parent;\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n        this.markAsDirty();\r\n    };\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getLocalMatrix = function () {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    };\r\n    /**\r\n     * Gets the base matrix (initial matrix which remains unchanged)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getBaseMatrix = function () {\r\n        return this._baseMatrix;\r\n    };\r\n    /**\r\n     * Gets the rest pose matrix\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getRestPose = function () {\r\n        return this._restPose;\r\n    };\r\n    /**\r\n     * Sets the rest pose matrix\r\n     * @param matrix the local-space rest pose to set for this bone\r\n     */\r\n    Bone.prototype.setRestPose = function (matrix) {\r\n        this._restPose.copyFrom(matrix);\r\n    };\r\n    /**\r\n     * Gets the bind pose matrix\r\n     * @returns the bind pose matrix\r\n     */\r\n    Bone.prototype.getBindPose = function () {\r\n        return this._bindPose;\r\n    };\r\n    /**\r\n     * Sets the bind pose matrix\r\n     * @param matrix the local-space bind pose to set for this bone\r\n     */\r\n    Bone.prototype.setBindPose = function (matrix) {\r\n        this._bindPose.copyFrom(matrix);\r\n    };\r\n    /**\r\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n     */\r\n    Bone.prototype.getWorldMatrix = function () {\r\n        return this._worldTransform;\r\n    };\r\n    /**\r\n     * Sets the local matrix to rest pose matrix\r\n     */\r\n    Bone.prototype.returnToRest = function () {\r\n        if (this._skeleton._numBonesWithLinkedTransformNode > 0) {\r\n            this.updateMatrix(this._restPose, false, false);\r\n        }\r\n        else {\r\n            this.updateMatrix(this._restPose, false, true);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the inverse of the absolute transform matrix.\r\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getInvertedAbsoluteTransform = function () {\r\n        return this._invertedAbsoluteTransform;\r\n    };\r\n    /**\r\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getAbsoluteTransform = function () {\r\n        return this._absoluteTransform;\r\n    };\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is copied from the transform node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    Bone.prototype.linkTransformNode = function (transformNode) {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n        this._linkedTransformNode = transformNode;\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    };\r\n    // Properties (matches AbstractMesh properties)\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    Bone.prototype.getTransformNode = function () {\r\n        return this._linkedTransformNode;\r\n    };\r\n    Object.defineProperty(Bone.prototype, \"position\", {\r\n        /** Gets or sets current position (in local space) */\r\n        get: function () {\r\n            this._decompose();\r\n            return this._localPosition;\r\n        },\r\n        set: function (newPosition) {\r\n            this._decompose();\r\n            this._localPosition.copyFrom(newPosition);\r\n            this._markAsDirtyAndCompose();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"rotation\", {\r\n        /** Gets or sets current rotation (in local space) */\r\n        get: function () {\r\n            return this.getRotation();\r\n        },\r\n        set: function (newRotation) {\r\n            this.setRotation(newRotation);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\r\n        /** Gets or sets current rotation quaternion (in local space) */\r\n        get: function () {\r\n            this._decompose();\r\n            return this._localRotation;\r\n        },\r\n        set: function (newRotation) {\r\n            this.setRotationQuaternion(newRotation);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"scaling\", {\r\n        /** Gets or sets current scaling (in local space) */\r\n        get: function () {\r\n            return this.getScale();\r\n        },\r\n        set: function (newScaling) {\r\n            this.setScale(newScaling);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"animationPropertiesOverride\", {\r\n        /**\r\n         * Gets the animation properties override\r\n         */\r\n        get: function () {\r\n            return this._skeleton.animationPropertiesOverride;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    Bone.prototype._decompose = function () {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n        this._needToDecompose = false;\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    };\r\n    Bone.prototype._compose = function () {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    };\r\n    /**\r\n     * Update the base and local matrices\r\n     * @param matrix defines the new base or local matrix\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     * @param updateLocalMatrix defines if the local matrix should be updated\r\n     */\r\n    Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix, updateLocalMatrix) {\r\n        if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\r\n        if (updateLocalMatrix === void 0) { updateLocalMatrix = true; }\r\n        this._baseMatrix.copyFrom(matrix);\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n        if (updateLocalMatrix) {\r\n            this._needToCompose = false; // in case there was a pending compose\r\n            this._localMatrix.copyFrom(matrix);\r\n            this._markAsDirtyAndDecompose();\r\n        }\r\n        else {\r\n            this.markAsDirty();\r\n        }\r\n    };\r\n    /** @hidden */\r\n    Bone.prototype._updateDifferenceMatrix = function (rootMatrix, updateChildren) {\r\n        if (updateChildren === void 0) { updateChildren = true; }\r\n        if (!rootMatrix) {\r\n            rootMatrix = this._baseMatrix;\r\n        }\r\n        if (this._parent) {\r\n            rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        }\r\n        else {\r\n            this._absoluteTransform.copyFrom(rootMatrix);\r\n        }\r\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\r\n        if (updateChildren) {\r\n            for (var index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateDifferenceMatrix();\r\n            }\r\n        }\r\n        this._scalingDeterminant = (this._absoluteTransform.determinant() < 0 ? -1 : 1);\r\n    };\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     */\r\n    Bone.prototype.markAsDirty = function () {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n    };\r\n    /** @hidden */\r\n    Bone.prototype._markAsDirtyAndCompose = function () {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    };\r\n    Bone.prototype._markAsDirtyAndDecompose = function () {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    };\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.translate = function (vec, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lm = this.getLocalMatrix();\r\n        if (space == Space.LOCAL) {\r\n            lm.addAtIndex(12, vec.x);\r\n            lm.addAtIndex(13, vec.y);\r\n            lm.addAtIndex(14, vec.z);\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            var tvec = Bone._tmpVecs[0];\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                }\r\n                else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n            }\r\n            else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n            tmat.setTranslationFromFloats(0, 0, 0);\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n            lm.addAtIndex(12, tvec.x);\r\n            lm.addAtIndex(13, tvec.y);\r\n            lm.addAtIndex(14, tvec.z);\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    /**\r\n     * Set the postion of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setPosition = function (position, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lm = this.getLocalMatrix();\r\n        if (space == Space.LOCAL) {\r\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            var vec = Bone._tmpVecs[0];\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                }\r\n                else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n                tmat.invert();\r\n            }\r\n            else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\r\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param mesh The mesh that this bone is attached to\r\n     */\r\n    Bone.prototype.setAbsolutePosition = function (position, mesh) {\r\n        this.setPosition(position, Space.WORLD, mesh);\r\n    };\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    Bone.prototype.scale = function (x, y, z, scaleChildren) {\r\n        if (scaleChildren === void 0) { scaleChildren = false; }\r\n        var locMat = this.getLocalMatrix();\r\n        // Apply new scaling on top of current local matrix\r\n        var scaleMat = Bone._tmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\r\n            var child = _a[_i];\r\n            var cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n        if (scaleChildren) {\r\n            for (var _b = 0, _c = this.children; _b < _c.length; _b++) {\r\n                var child = _c[_b];\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    Bone.prototype.setScale = function (scale) {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    };\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    Bone.prototype.getScale = function () {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    };\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    Bone.prototype.getScaleToRef = function (result) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    };\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.rotate = function (axis, amount, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var rmat = Bone._tmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setAxisAngle = function (axis, angle, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotation = function (rotation, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\r\n    };\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotationQuaternion = function (quat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n            this._markAsDirtyAndCompose();\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotationMatrix = function (rotMat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat2 = Bone._tmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n        this._rotateWithMatrix(rotMat2, space, mesh);\r\n    };\r\n    Bone.prototype._rotateWithMatrix = function (rmat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lmat = this.getLocalMatrix();\r\n        var lx = lmat.m[12];\r\n        var ly = lmat.m[13];\r\n        var lz = lmat.m[14];\r\n        var parent = this.getParent();\r\n        var parentScale = Bone._tmpMats[3];\r\n        var parentScaleInv = Bone._tmpMats[4];\r\n        if (parent && space == Space.WORLD) {\r\n            if (mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\r\n            }\r\n            else {\r\n                parentScale.copyFrom(parent.getAbsoluteTransform());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        }\r\n        else {\r\n            if (space == Space.WORLD && mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            }\r\n            else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n        this.computeAbsoluteTransforms();\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    Bone.prototype._getNegativeRotationToRef = function (rotMatInv, mesh) {\r\n        var scaleMatrix = Bone._tmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh) {\r\n            rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);\r\n        }\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n        return true;\r\n    };\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @returns The position of the bone\r\n     */\r\n    Bone.prototype.getPosition = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var pos = Vector3.Zero();\r\n        this.getPositionToRef(space, mesh, pos);\r\n        return pos;\r\n    };\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    Bone.prototype.getPositionToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space == Space.LOCAL) {\r\n            var lm = this.getLocalMatrix();\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            if (mesh && wm) {\r\n                tmat.copyFrom(this.getAbsoluteTransform());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            }\r\n            else {\r\n                tmat = this.getAbsoluteTransform();\r\n            }\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    };\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The absolute position of the bone\r\n     */\r\n    Bone.prototype.getAbsolutePosition = function (mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var pos = Vector3.Zero();\r\n        this.getPositionToRef(Space.WORLD, mesh, pos);\r\n        return pos;\r\n    };\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    Bone.prototype.getAbsolutePositionToRef = function (mesh, result) {\r\n        this.getPositionToRef(Space.WORLD, mesh, result);\r\n    };\r\n    /**\r\n     * Compute the absolute transforms of this bone and its children\r\n     */\r\n    Bone.prototype.computeAbsoluteTransforms = function () {\r\n        this._compose();\r\n        if (this._parent) {\r\n            this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        }\r\n        else {\r\n            this._absoluteTransform.copyFrom(this._localMatrix);\r\n            var poseMatrix = this._skeleton.getPoseMatrix();\r\n            if (poseMatrix) {\r\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\r\n            }\r\n        }\r\n        var children = this.children;\r\n        var len = children.length;\r\n        for (var i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteTransforms();\r\n        }\r\n    };\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world direction\r\n     */\r\n    Bone.prototype.getDirection = function (localAxis, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getDirectionToRef(localAxis, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    Bone.prototype.getDirectionToRef = function (localAxis, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var mat = Bone._tmpMats[0];\r\n        mat.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n        result.normalize();\r\n    };\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The euler rotation\r\n     */\r\n    Bone.prototype.getRotation = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getRotationToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var quat = Bone._tmpQuat;\r\n        this.getRotationQuaternionToRef(space, mesh, quat);\r\n        quat.toEulerAnglesToRef(result);\r\n    };\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The quaternion rotation\r\n     */\r\n    Bone.prototype.getRotationQuaternion = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Quaternion.Identity();\r\n        this.getRotationQuaternionToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationQuaternionToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        }\r\n        else {\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            }\r\n            else {\r\n                mat.copyFrom(amat);\r\n            }\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    };\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The rotation matrix\r\n     */\r\n    Bone.prototype.getRotationMatrix = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var result = Matrix.Identity();\r\n        this.getRotationMatrixToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationMatrixToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        }\r\n        else {\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            }\r\n            else {\r\n                mat.copyFrom(amat);\r\n            }\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    };\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world position\r\n     */\r\n    Bone.prototype.getAbsolutePositionFromLocal = function (position, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getAbsolutePositionFromLocalToRef(position, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var tmat = Bone._tmpMats[0];\r\n        if (mesh && wm) {\r\n            tmat.copyFrom(this.getAbsoluteTransform());\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n        else {\r\n            tmat = this.getAbsoluteTransform();\r\n        }\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    };\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The local position\r\n     */\r\n    Bone.prototype.getLocalPositionFromAbsolute = function (position, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var tmat = Bone._tmpMats[0];\r\n        tmat.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n        tmat.invert();\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    };\r\n    /**\r\n     * Set the current local matrix as the restPose for this bone.\r\n     */\r\n    Bone.prototype.setCurrentPoseAsRest = function () {\r\n        this.setRestPose(this.getLocalMatrix());\r\n    };\r\n    Bone._tmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    Bone._tmpQuat = Quaternion.Identity();\r\n    Bone._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\r\n    return Bone;\r\n}(Node));\r\nexport { Bone };\r\n//# sourceMappingURL=bone.js.map","import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\r\nimport { PrecisionDate } from '../Misc/precisionDate';\r\nimport { Bone } from '../Bones/bone';\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nvar Animatable = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    function Animatable(scene, \r\n    /** defines the target object */\r\n    target, \r\n    /** defines the starting frame number (default is 0) */\r\n    fromFrame, \r\n    /** defines the ending frame number (default is 100) */\r\n    toFrame, \r\n    /** defines if the animation must loop (default is false)  */\r\n    loopAnimation, speedRatio, \r\n    /** defines a callback to call when animation ends if it is not looping */\r\n    onAnimationEnd, animations, \r\n    /** defines a callback to call when animation loops */\r\n    onAnimationLoop, \r\n    /** defines whether the animation should be evaluated additively */\r\n    isAdditive) {\r\n        if (fromFrame === void 0) { fromFrame = 0; }\r\n        if (toFrame === void 0) { toFrame = 100; }\r\n        if (loopAnimation === void 0) { loopAnimation = false; }\r\n        if (speedRatio === void 0) { speedRatio = 1.0; }\r\n        if (isAdditive === void 0) { isAdditive = false; }\r\n        this.target = target;\r\n        this.fromFrame = fromFrame;\r\n        this.toFrame = toFrame;\r\n        this.loopAnimation = loopAnimation;\r\n        this.onAnimationEnd = onAnimationEnd;\r\n        this.onAnimationLoop = onAnimationLoop;\r\n        this.isAdditive = isAdditive;\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n        this._runtimeAnimations = new Array();\r\n        this._paused = false;\r\n        this._speedRatio = 1;\r\n        this._weight = -1.0;\r\n        this._syncRoot = null;\r\n        /**\r\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n         * This will only apply for non looping animation (default is true)\r\n         */\r\n        this.disposeOnEnd = true;\r\n        /**\r\n         * Gets a boolean indicating if the animation has started\r\n         */\r\n        this.animationStarted = false;\r\n        /**\r\n         * Observer raised when the animation ends\r\n         */\r\n        this.onAnimationEndObservable = new Observable();\r\n        /**\r\n         * Observer raised when the animation loops\r\n         */\r\n        this.onAnimationLoopObservable = new Observable();\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n    Object.defineProperty(Animatable.prototype, \"syncRoot\", {\r\n        /**\r\n         * Gets the root Animatable used to synchronize and normalize animations\r\n         */\r\n        get: function () {\r\n            return this._syncRoot;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"masterFrame\", {\r\n        /**\r\n         * Gets the current frame of the first RuntimeAnimation\r\n         * Used to synchronize Animatables\r\n         */\r\n        get: function () {\r\n            if (this._runtimeAnimations.length === 0) {\r\n                return 0;\r\n            }\r\n            return this._runtimeAnimations[0].currentFrame;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"weight\", {\r\n        /**\r\n         * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n         */\r\n        get: function () {\r\n            return this._weight;\r\n        },\r\n        set: function (value) {\r\n            if (value === -1) { // -1 is ok and means no weight\r\n                this._weight = -1;\r\n                return;\r\n            }\r\n            // Else weight must be in [0, 1] range\r\n            this._weight = Math.min(Math.max(value, 0), 1.0);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"speedRatio\", {\r\n        /**\r\n         * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n         */\r\n        get: function () {\r\n            return this._speedRatio;\r\n        },\r\n        set: function (value) {\r\n            for (var index = 0; index < this._runtimeAnimations.length; index++) {\r\n                var animation = this._runtimeAnimations[index];\r\n                animation._prepareForSpeedRatioChange(value);\r\n            }\r\n            this._speedRatio = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with\r\n     * @returns the current Animatable\r\n     */\r\n    Animatable.prototype.syncWith = function (root) {\r\n        this._syncRoot = root;\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    Animatable.prototype.getAnimations = function () {\r\n        return this._runtimeAnimations;\r\n    };\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    Animatable.prototype.appendAnimations = function (target, animations) {\r\n        var _this = this;\r\n        for (var index = 0; index < animations.length; index++) {\r\n            var animation = animations[index];\r\n            var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = function () {\r\n                _this.onAnimationLoopObservable.notifyObservers(_this);\r\n                if (_this.onAnimationLoop) {\r\n                    _this.onAnimationLoop();\r\n                }\r\n            };\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    Animatable.prototype.getAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    Animatable.prototype.reset = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    };\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    Animatable.prototype.enableBlending = function (blendingSpeed) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    };\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    Animatable.prototype.disableBlending = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    };\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    Animatable.prototype.goToFrame = function (frame) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        if (runtimeAnimations[0]) {\r\n            var fps = runtimeAnimations[0].animation.framePerSecond;\r\n            var currentFrame = runtimeAnimations[0].currentFrame;\r\n            var delay = this.speedRatio === 0 ? 0 : ((frame - currentFrame) / fps * 1000) / this.speedRatio;\r\n            if (this._localDelayOffset === null) {\r\n                this._localDelayOffset = 0;\r\n            }\r\n            this._localDelayOffset -= delay;\r\n        }\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n    };\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    Animatable.prototype.pause = function () {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    };\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    Animatable.prototype.restart = function () {\r\n        this._paused = false;\r\n    };\r\n    Animatable.prototype._raiseOnAnimationEnd = function () {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    };\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    Animatable.prototype.stop = function (animationName, targetMask) {\r\n        if (animationName || targetMask) {\r\n            var idx = this._scene._activeAnimatables.indexOf(this);\r\n            if (idx > -1) {\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    var runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fullfilled when the animation ends\r\n     */\r\n    Animatable.prototype.waitAsync = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.onAnimationEndObservable.add(function () {\r\n                resolve(_this);\r\n            }, undefined, undefined, _this, true);\r\n        });\r\n    };\r\n    /** @hidden */\r\n    Animatable.prototype._animate = function (delay) {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        }\r\n        else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n        if (this._weight === 0) { // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n        // Animating\r\n        var running = false;\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        var index;\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            var animation = runtimeAnimations[index];\r\n            var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n        this.animationStarted = running;\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n            this._raiseOnAnimationEnd();\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n        return running;\r\n    };\r\n    return Animatable;\r\n}());\r\nexport { Animatable };\r\nScene.prototype._animate = function () {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n    // Getting time\r\n    var now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n    var animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n    this._animationTime += this.deltaTime;\r\n    var animationTime = this._animationTime;\r\n    for (var index = 0; index < animatables.length; index++) {\r\n        var animatable = animatables[index];\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\r\n    if (weight === void 0) { weight = 1.0; }\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n    return returnedAnimatable;\r\n};\r\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n    var shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        var animatables = target.getAnimatables();\r\n        for (var index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n    animatable.reset();\r\n    return animatable;\r\n};\r\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n        var child = children_1[_i];\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n    return animatable;\r\n};\r\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\r\n        var child = children_2[_i];\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.getAnimatableByTarget = function (target) {\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n    return null;\r\n};\r\nScene.prototype.getAllAnimatablesByTarget = function (target) {\r\n    var result = [];\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\r\n    var animatables = this.getAllAnimatablesByTarget(target);\r\n    for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\r\n        var animatable = animatables_1[_i];\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function () {\r\n    if (this._activeAnimatables) {\r\n        for (var i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables = [];\r\n    }\r\n    for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\r\n        var group = _a[_i];\r\n        group.stop();\r\n    }\r\n};\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\r\n    var target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue\r\n        };\r\n    }\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    }\r\n    else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n    var normalizer = 1.0;\r\n    var finalPosition = TmpVectors.Vector3[0];\r\n    var finalScaling = TmpVectors.Vector3[1];\r\n    var finalQuaternion = TmpVectors.Quaternion[0];\r\n    var startIndex = 0;\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var scale = 1;\r\n    var skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            }\r\n            else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n        for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n            var scale = runtimeAnimation.weight / normalizer;\r\n            var currentPosition = TmpVectors.Vector3[2];\r\n            var currentScaling = TmpVectors.Vector3[3];\r\n            var currentQuaternion = TmpVectors.Quaternion[1];\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_1];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        var currentPosition = TmpVectors.Vector3[2];\r\n        var currentScaling = TmpVectors.Vector3[3];\r\n        var currentQuaternion = TmpVectors.Quaternion[1];\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n    var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var cumulativeQuaternion = refQuaternion;\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    }\r\n    else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    }\r\n    else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        var normalizer = 1.0;\r\n        var quaternions = void 0;\r\n        var weights = void 0;\r\n        if (holder.totalWeight < 1.0) {\r\n            var scale = 1.0 - holder.totalWeight;\r\n            quaternions = [];\r\n            weights = [];\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        }\r\n        else {\r\n            if (holder.animations.length === 2) { // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n        for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n        var cumulativeAmount = 0;\r\n        for (var index = 0; index < quaternions.length;) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_2];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n    return cumulativeQuaternion;\r\n};\r\nScene.prototype._processLateAnimationBindings = function () {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        var target = this._registeredForLateAnimationBindings.data[index];\r\n        for (var path in target._lateAnimationHolders) {\r\n            var holder = target._lateAnimationHolders[path];\r\n            var originalAnimation = holder.animations[0];\r\n            var originalValue = holder.originalValue;\r\n            var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n            var finalValue = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            }\r\n            else {\r\n                var quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                }\r\n                else {\r\n                    var startIndex = 0;\r\n                    var normalizer = 1.0;\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        }\r\n                        else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    }\r\n                    else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        var scale_1 = originalAnimation.weight / normalizer;\r\n                        if (scale_1 !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale_1);\r\n                            }\r\n                            else {\r\n                                finalValue = originalAnimation.currentValue * scale_1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n                        startIndex = 1;\r\n                    }\r\n                    // Add up the override animations\r\n                    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        var runtimeAnimation = holder.animations[animIndex];\r\n                        var scale = runtimeAnimation.weight / normalizer;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                    // Add up the additive animations\r\n                    for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\r\n                        var runtimeAnimation = holder.additiveAnimations[animIndex_3];\r\n                        var scale = runtimeAnimation.weight;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\r\n    if (rescaleAsRequired === void 0) { rescaleAsRequired = false; }\r\n    if (skelDimensionsRatio === void 0) { skelDimensionsRatio = null; }\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n    // get animation info / verify there is such a range from the source bone\r\n    var sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    var from = sourceRange.from;\r\n    var to = sourceRange.to;\r\n    var sourceKeys = source.animations[0].getKeys();\r\n    // rescaling prep\r\n    var sourceBoneLength = source.length;\r\n    var sourceParent = source.getParent();\r\n    var parent = this.getParent();\r\n    var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n    var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n    var destKeys = this.animations[0].getKeys();\r\n    // loop vars declaration\r\n    var orig;\r\n    var origTranslation;\r\n    var mat;\r\n    for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                }\r\n                else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                }\r\n                else {\r\n                    mat = orig.value;\r\n                }\r\n            }\r\n            else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n//# sourceMappingURL=animatable.js.map","import { Animation } from '@babylonjs/core/Animations/animation'\nimport { BoxBuilder } from '@babylonjs/core/Meshes/Builders/boxBuilder'\nimport { PlaneBuilder } from '@babylonjs/core/Meshes/Builders/planeBuilder'\nimport { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial'\n\nimport '@babylonjs/core/Meshes/instancedMesh'\nimport '@babylonjs/core/Animations/animatable'\n\nimport { HALF_PI, POINTS } from './scene.js'\n\nconst THREE = [-1, 0, 1]\nconst FACES = [\n  [[0, 0.3, 0.7], [0, -HALF_PI, 0]],\n  [[0, 0.6, 0.3], [0,  HALF_PI, 0]],\n  [[1, 1.0, 1.0], [ HALF_PI, 0, 0]],\n  [[1, 0.8, 0.0], [-HALF_PI, 0, 0]],\n  [[0.7, 0, 0.2], [0, 0, 0]],\n  [[1, 0.3, 0.0], [Math.PI, 0, 0]],\n]\n\nexport const createCubies = (scene) => {\n  const baseCubie = BoxBuilder.CreateBox('', { size: 1 }, scene)\n  const cubies = THREE.flatMap((x) => THREE.flatMap((y) => THREE.map((z) => {\n    const c = baseCubie.createInstance('')\n    c.position.set(x, y, z)\n    return c\n  })))\n\n  for (const [i, normal] of POINTS.entries()) {\n    const temPlane = PlaneBuilder.CreatePlane('', { size: 0.9 }, scene)\n    temPlane.material = new StandardMaterial('', scene)\n    temPlane.material.ambientColor.set(...FACES[i][0])\n    temPlane.isVisible = false\n\n    for (const cubie of cubies) {\n      const other = cubie.position.add(normal)\n      if (cubies.some((c) => c.position.equals(other))) continue\n      const p = temPlane.createInstance('')\n      p.parent = cubie\n      p.rotation.set(...FACES[i][1])\n      p.position.set(...normal).scaleInPlace(0.501)\n    }\n  }\n\n  return cubies\n}\n\nexport const animate = (...params) => new Promise(async (resolve) => {\n  Animation.CreateAndStartAnimation('', ...params).onAnimationEnd = resolve\n})"],"names":["name","shader"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GACb,EAAO,qBAAqBD,IAAQC,GCFpC,GAAID,IAAO,2BACPC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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CFpC,GAAID,IAAO,gBACPC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QACb,EAAO,qBAAqBD,IAAQC,GCFpC,GAAID,IAAO,mBACPC,GAAS;AAAA;AAAA,QACb,EAAO,qBAAqBD,IAAQC,GCFpC,GAAID,IAAO,cACPC,GAAS;AAAA;AAAA;AAAA,QACb,EAAO,qBAAqBD,IAAQC,GCqBpC,GAAID,IAAO,qBACPC,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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"}