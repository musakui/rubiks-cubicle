{"version":3,"file":"geometry.4a204530.js","sources":["../node_modules/@babylonjs/core/Maths/math.path.js","../node_modules/@babylonjs/core/Maths/math.size.js","../node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js","../node_modules/@babylonjs/core/Meshes/geometry.js","../node_modules/@babylonjs/core/Materials/multiMaterial.js","../node_modules/@babylonjs/core/Meshes/meshLODLevel.js","../node_modules/@babylonjs/core/Meshes/mesh.js","../node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js","../node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js","../node_modules/@babylonjs/core/Materials/prePassConfiguration.js","../node_modules/@babylonjs/core/Materials/pushMaterial.js","../node_modules/@babylonjs/core/Materials/thinMaterialHelper.js","../node_modules/@babylonjs/core/Materials/materialHelper.js","../node_modules/@babylonjs/core/Materials/Textures/thinTexture.js","../node_modules/@babylonjs/core/Materials/Textures/baseTexture.js","../node_modules/@babylonjs/core/Misc/copyTools.js","../node_modules/@babylonjs/core/Materials/Textures/texture.js","../node_modules/@babylonjs/core/Materials/materialFlags.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js","../node_modules/@babylonjs/core/Shaders/default.fragment.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js","../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js","../node_modules/@babylonjs/core/Shaders/default.vertex.js","../node_modules/@babylonjs/core/Materials/effectFallbacks.js","../node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js","../node_modules/@babylonjs/core/Materials/standardMaterial.js","../node_modules/@babylonjs/core/Animations/animationKey.js","../node_modules/@babylonjs/core/Animations/animationRange.js","../node_modules/@babylonjs/core/Animations/animation.js","../node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js","../node_modules/@babylonjs/core/Animations/easing.js","../node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js","../node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js","../node_modules/@babylonjs/core/Cameras/targetCamera.js","../node_modules/@babylonjs/core/Cameras/cameraInputsManager.js","../node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js","../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js","../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js","../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js","../node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js","../node_modules/@babylonjs/core/Cameras/arcRotateCamera.js","../node_modules/@babylonjs/core/Meshes/instancedMesh.js","../node_modules/@babylonjs/core/Animations/runtimeAnimation.js","../node_modules/@babylonjs/core/Bones/bone.js","../node_modules/@babylonjs/core/Animations/animatable.js","../src/geometry.js"],"sourcesContent":["import { Scalar } from \"./math.scalar\";\r\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\r\nimport { Epsilon } from \"./math.constants\";\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nexport var Orientation;\r\n(function (Orientation) {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    Orientation[Orientation[\"CW\"] = 0] = \"CW\";\r\n    /** Counter clockwise */\r\n    Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\r\n})(Orientation || (Orientation = {}));\r\n/** Class used to represent a Bezier curve */\r\nvar BezierCurve = /** @class */ (function () {\r\n    function BezierCurve() {\r\n    }\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    BezierCurve.Interpolate = function (t, x1, y1, x2, y2) {\r\n        // Extract X (which is equal to time here)\r\n        var f0 = 1 - 3 * x2 + 3 * x1;\r\n        var f1 = 3 * x2 - 6 * x1;\r\n        var f2 = 3 * x1;\r\n        var refinedT = t;\r\n        for (var i = 0; i < 5; i++) {\r\n            var refinedT2 = refinedT * refinedT;\r\n            var refinedT3 = refinedT2 * refinedT;\r\n            var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\r\n    };\r\n    return BezierCurve;\r\n}());\r\nexport { BezierCurve };\r\n/**\r\n * Defines angle representation\r\n */\r\nvar Angle = /** @class */ (function () {\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    function Angle(radians) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += 2.0 * Math.PI;\r\n        }\r\n    }\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    Angle.prototype.degrees = function () {\r\n        return (this._radians * 180.0) / Math.PI;\r\n    };\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    Angle.prototype.radians = function () {\r\n        return this._radians;\r\n    };\r\n    /**\r\n     * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\r\n     * @param a defines first point as the origin\r\n     * @param b defines point\r\n     * @returns a new Angle\r\n     */\r\n    Angle.BetweenTwoPoints = function (a, b) {\r\n        var delta = b.subtract(a);\r\n        var theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    };\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    Angle.FromRadians = function (radians) {\r\n        return new Angle(radians);\r\n    };\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    Angle.FromDegrees = function (degrees) {\r\n        return new Angle((degrees * Math.PI) / 180.0);\r\n    };\r\n    return Angle;\r\n}());\r\nexport { Angle };\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nvar Arc2 = /** @class */ (function () {\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the midlle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    function Arc2(\r\n    /** Defines the start point of the arc */\r\n    startPoint, \r\n    /** Defines the mid point of the arc */\r\n    midPoint, \r\n    /** Defines the end point of the arc */\r\n    endPoint) {\r\n        this.startPoint = startPoint;\r\n        this.midPoint = midPoint;\r\n        this.endPoint = endPoint;\r\n        var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\r\n        var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\r\n        var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n        var a1 = this.startAngle.degrees();\r\n        var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n    return Arc2;\r\n}());\r\nexport { Arc2 };\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nvar Path2 = /** @class */ (function () {\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    function Path2(x, y) {\r\n        this._points = new Array();\r\n        this._length = 0.0;\r\n        /**\r\n         * If the path start and end point are the same\r\n         */\r\n        this.closed = false;\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    Path2.prototype.addLineTo = function (x, y) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        var newPoint = new Vector2(x, y);\r\n        var previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\r\n        if (numberOfSegments === void 0) { numberOfSegments = 36; }\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        var startPoint = this._points[this._points.length - 1];\r\n        var midPoint = new Vector2(midX, midY);\r\n        var endPoint = new Vector2(endX, endY);\r\n        var arc = new Arc2(startPoint, midPoint, endPoint);\r\n        var increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        var currentAngle = arc.startAngle.radians() + increment;\r\n        for (var i = 0; i < numberOfSegments; i++) {\r\n            var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    Path2.prototype.close = function () {\r\n        this.closed = true;\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    Path2.prototype.length = function () {\r\n        var result = this._length;\r\n        if (this.closed) {\r\n            var lastPoint = this._points[this._points.length - 1];\r\n            var firstPoint = this._points[0];\r\n            result += firstPoint.subtract(lastPoint).length();\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    Path2.prototype.getPoints = function () {\r\n        return this._points;\r\n    };\r\n    /**\r\n     * Retreives the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retreive the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n        var lengthPosition = normalizedLengthPosition * this.length();\r\n        var previousOffset = 0;\r\n        for (var i = 0; i < this._points.length; i++) {\r\n            var j = (i + 1) % this._points.length;\r\n            var a = this._points[i];\r\n            var b = this._points[j];\r\n            var bToA = b.subtract(a);\r\n            var nextOffset = bToA.length() + previousOffset;\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                var dir = bToA.normalize();\r\n                var localOffset = lengthPosition - previousOffset;\r\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n        return Vector2.Zero();\r\n    };\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    Path2.StartingAt = function (x, y) {\r\n        return new Path2(x, y);\r\n    };\r\n    return Path2;\r\n}());\r\nexport { Path2 };\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n */\r\nvar Path3D = /** @class */ (function () {\r\n    /**\r\n     * new Path3D(path, normal, raw)\r\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n     * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\r\n     * @param path an array of Vector3, the curve axis of the Path3D\r\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n     */\r\n    function Path3D(\r\n    /**\r\n     * an array of Vector3, the curve axis of the Path3D\r\n     */\r\n    path, firstNormal, raw, alignTangentsWithPath) {\r\n        if (firstNormal === void 0) { firstNormal = null; }\r\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\r\n        this.path = path;\r\n        this._curve = new Array();\r\n        this._distances = new Array();\r\n        this._tangents = new Array();\r\n        this._normals = new Array();\r\n        this._binormals = new Array();\r\n        // holds interpolated point data\r\n        this._pointAtData = {\r\n            id: 0,\r\n            point: Vector3.Zero(),\r\n            previousPointArrayIndex: 0,\r\n            position: 0,\r\n            subPosition: 0,\r\n            interpolateReady: false,\r\n            interpolationMatrix: Matrix.Identity(),\r\n        };\r\n        for (var p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._alignTangentsWithPath = alignTangentsWithPath;\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n    }\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    Path3D.prototype.getCurve = function () {\r\n        return this._curve;\r\n    };\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    Path3D.prototype.getPoints = function () {\r\n        return this._curve;\r\n    };\r\n    /**\r\n     * @returns the computed length (float) of the path.\r\n     */\r\n    Path3D.prototype.length = function () {\r\n        return this._distances[this._distances.length - 1];\r\n    };\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    Path3D.prototype.getTangents = function () {\r\n        return this._tangents;\r\n    };\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    Path3D.prototype.getNormals = function () {\r\n        return this._normals;\r\n    };\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    Path3D.prototype.getBinormals = function () {\r\n        return this._binormals;\r\n    };\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    Path3D.prototype.getDistances = function () {\r\n        return this._distances;\r\n    };\r\n    /**\r\n     * Returns an interpolated point along this path\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns a new Vector3 as the point\r\n     */\r\n    Path3D.prototype.getPointAt = function (position) {\r\n        return this._updatePointAtData(position).point;\r\n    };\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n     */\r\n    Path3D.prototype.getTangentAt = function (position, interpolated) {\r\n        if (interpolated === void 0) { interpolated = false; }\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\r\n    };\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n     */\r\n    Path3D.prototype.getNormalAt = function (position, interpolated) {\r\n        if (interpolated === void 0) { interpolated = false; }\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\r\n    };\r\n    /**\r\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n     */\r\n    Path3D.prototype.getBinormalAt = function (position, interpolated) {\r\n        if (interpolated === void 0) { interpolated = false; }\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\r\n    };\r\n    /**\r\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n     */\r\n    Path3D.prototype.getDistanceAt = function (position) {\r\n        return this.length() * position;\r\n    };\r\n    /**\r\n     * Returns the array index of the previous point of an interpolated point along this path\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the array index\r\n     */\r\n    Path3D.prototype.getPreviousPointIndexAt = function (position) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.previousPointArrayIndex;\r\n    };\r\n    /**\r\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the sub position\r\n     */\r\n    Path3D.prototype.getSubPositionAt = function (position) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.subPosition;\r\n    };\r\n    /**\r\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n     * @param target the vector of which to get the closest position to\r\n     * @returns the position of the closest virtual point on this path to the target vector\r\n     */\r\n    Path3D.prototype.getClosestPositionTo = function (target) {\r\n        var smallestDistance = Number.MAX_VALUE;\r\n        var closestPosition = 0.0;\r\n        for (var i = 0; i < this._curve.length - 1; i++) {\r\n            var point = this._curve[i + 0];\r\n            var tangent = this._curve[i + 1].subtract(point).normalize();\r\n            var subLength = this._distances[i + 1] - this._distances[i + 0];\r\n            var subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\r\n            var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\r\n            if (distance < smallestDistance) {\r\n                smallestDistance = distance;\r\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\r\n            }\r\n        }\r\n        return closestPosition;\r\n    };\r\n    /**\r\n     * Returns a sub path (slice) of this path\r\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @returns a sub path (slice) of this path\r\n     */\r\n    Path3D.prototype.slice = function (start, end) {\r\n        if (start === void 0) { start = 0.0; }\r\n        if (end === void 0) { end = 1.0; }\r\n        if (start < 0.0) {\r\n            start = 1 - ((start * -1.0) % 1.0);\r\n        }\r\n        if (end < 0.0) {\r\n            end = 1 - ((end * -1.0) % 1.0);\r\n        }\r\n        if (start > end) {\r\n            var _start = start;\r\n            start = end;\r\n            end = _start;\r\n        }\r\n        var curvePoints = this.getCurve();\r\n        var startPoint = this.getPointAt(start);\r\n        var startIndex = this.getPreviousPointIndexAt(start);\r\n        var endPoint = this.getPointAt(end);\r\n        var endIndex = this.getPreviousPointIndexAt(end) + 1;\r\n        var slicePoints = [];\r\n        if (start !== 0.0) {\r\n            startIndex++;\r\n            slicePoints.push(startPoint);\r\n        }\r\n        slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));\r\n        if (end !== 1.0 || start === 1.0) {\r\n            slicePoints.push(endPoint);\r\n        }\r\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\r\n    };\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n     * @returns the same object updated.\r\n     */\r\n    Path3D.prototype.update = function (path, firstNormal, alignTangentsWithPath) {\r\n        if (firstNormal === void 0) { firstNormal = null; }\r\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\r\n        for (var p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n        return this;\r\n    };\r\n    // private function compute() : computes tangents, normals and binormals\r\n    Path3D.prototype._compute = function (firstNormal, alignTangentsWithPath) {\r\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\r\n        var l = this._curve.length;\r\n        if (l < 2) {\r\n            return;\r\n        }\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        var tg0 = this._tangents[0];\r\n        var pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n        // normals and binormals : next points\r\n        var prev; // previous vector (segment)\r\n        var cur; // current vector (segment)\r\n        var curTang; // current tangent\r\n        // previous normal\r\n        var prevNor; // previous normal\r\n        var prevBinor; // previous binormal\r\n        for (var i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                if (this._normals[i].length() === 0) {\r\n                    prevNor = this._normals[i - 1];\r\n                    this._normals[i] = prevNor.clone();\r\n                }\r\n                else {\r\n                    this._normals[i].normalize();\r\n                }\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n        this._pointAtData.id = NaN;\r\n    };\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    Path3D.prototype._getFirstNonNullVector = function (index) {\r\n        var i = 1;\r\n        var nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    };\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    Path3D.prototype._getLastNonNullVector = function (index) {\r\n        var i = 1;\r\n        var nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    };\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    Path3D.prototype._normalVector = function (vt, va) {\r\n        var normal0;\r\n        var tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n        if (va === undefined || va === null) {\r\n            var point;\r\n            if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\r\n                // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            }\r\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            }\r\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            }\r\n            else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        }\r\n        else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    };\r\n    /**\r\n     * Updates the point at data for an interpolated point along this curve\r\n     * @param position the position of the point along this curve, from 0.0 to 1.0\r\n     * @interpolateTNB wether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    Path3D.prototype._updatePointAtData = function (position, interpolateTNB) {\r\n        if (interpolateTNB === void 0) { interpolateTNB = false; }\r\n        // set an id for caching the result\r\n        if (this._pointAtData.id === position) {\r\n            if (!this._pointAtData.interpolateReady) {\r\n                this._updateInterpolationMatrix();\r\n            }\r\n            return this._pointAtData;\r\n        }\r\n        else {\r\n            this._pointAtData.id = position;\r\n        }\r\n        var curvePoints = this.getPoints();\r\n        // clamp position between 0.0 and 1.0\r\n        if (position <= 0.0) {\r\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\r\n        }\r\n        else if (position >= 1.0) {\r\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\r\n        }\r\n        var previousPoint = curvePoints[0];\r\n        var currentPoint;\r\n        var currentLength = 0.0;\r\n        var targetLength = position * this.length();\r\n        for (var i = 1; i < curvePoints.length; i++) {\r\n            currentPoint = curvePoints[i];\r\n            var distance = Vector3.Distance(previousPoint, currentPoint);\r\n            currentLength += distance;\r\n            if (currentLength === targetLength) {\r\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\r\n            }\r\n            else if (currentLength > targetLength) {\r\n                var toLength = currentLength - targetLength;\r\n                var diff = toLength / distance;\r\n                var dir = previousPoint.subtract(currentPoint);\r\n                var point = currentPoint.add(dir.scaleInPlace(diff));\r\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\r\n            }\r\n            previousPoint = currentPoint;\r\n        }\r\n        return this._pointAtData;\r\n    };\r\n    /**\r\n     * Updates the point at data from the specified parameters\r\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n     * @param point the interpolated point\r\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n     */\r\n    Path3D.prototype._setPointAtData = function (position, subPosition, point, parentIndex, interpolateTNB) {\r\n        this._pointAtData.point = point;\r\n        this._pointAtData.position = position;\r\n        this._pointAtData.subPosition = subPosition;\r\n        this._pointAtData.previousPointArrayIndex = parentIndex;\r\n        this._pointAtData.interpolateReady = interpolateTNB;\r\n        if (interpolateTNB) {\r\n            this._updateInterpolationMatrix();\r\n        }\r\n        return this._pointAtData;\r\n    };\r\n    /**\r\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n     */\r\n    Path3D.prototype._updateInterpolationMatrix = function () {\r\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\r\n        var parentIndex = this._pointAtData.previousPointArrayIndex;\r\n        if (parentIndex !== this._tangents.length - 1) {\r\n            var index = parentIndex + 1;\r\n            var tangentFrom = this._tangents[parentIndex].clone();\r\n            var normalFrom = this._normals[parentIndex].clone();\r\n            var binormalFrom = this._binormals[parentIndex].clone();\r\n            var tangentTo = this._tangents[index].clone();\r\n            var normalTo = this._normals[index].clone();\r\n            var binormalTo = this._binormals[index].clone();\r\n            var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\r\n            var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\r\n            var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\r\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\r\n        }\r\n    };\r\n    return Path3D;\r\n}());\r\nexport { Path3D };\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\r\n */\r\nvar Curve3 = /** @class */ (function () {\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    function Curve3(points) {\r\n        this._length = 0.0;\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        var bez = new Array();\r\n        var equation = function (t, val0, val1, val2) {\r\n            var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    };\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        var bez = new Array();\r\n        var equation = function (t, val0, val1, val2, val3) {\r\n            var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    };\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    Curve3.CreateHermiteSpline = function (p1, t1, p2, t2, nbPoints) {\r\n        var hermite = new Array();\r\n        var step = 1.0 / nbPoints;\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    };\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    Curve3.CreateCatmullRomSpline = function (points, nbPoints, closed) {\r\n        var catmullRom = new Array();\r\n        var step = 1.0 / nbPoints;\r\n        var amount = 0.0;\r\n        if (closed) {\r\n            var pointsCount = points.length;\r\n            for (var i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (var c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        }\r\n        else {\r\n            var totalPoints = new Array();\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            for (var i = 0; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (var c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    };\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    Curve3.prototype.getPoints = function () {\r\n        return this._points;\r\n    };\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    Curve3.prototype.length = function () {\r\n        return this._length;\r\n    };\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    Curve3.prototype.continue = function (curve) {\r\n        var lastPoint = this._points[this._points.length - 1];\r\n        var continuedPoints = this._points.slice();\r\n        var curvePoints = curve.getPoints();\r\n        for (var i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        var continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    };\r\n    Curve3.prototype._computeLength = function (path) {\r\n        var l = 0;\r\n        for (var i = 1; i < path.length; i++) {\r\n            l += path[i].subtract(path[i - 1]).length();\r\n        }\r\n        return l;\r\n    };\r\n    return Curve3;\r\n}());\r\nexport { Curve3 };\r\n//# sourceMappingURL=math.path.js.map","/**\r\n * Size containing widht and height\r\n */\r\nvar Size = /** @class */ (function () {\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    function Size(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    Size.prototype.toString = function () {\r\n        return \"{W: \" + this.width + \", H: \" + this.height + \"}\";\r\n    };\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    Size.prototype.getClassName = function () {\r\n        return \"Size\";\r\n    };\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    Size.prototype.getHashCode = function () {\r\n        var hash = this.width | 0;\r\n        hash = (hash * 397) ^ (this.height | 0);\r\n        return hash;\r\n    };\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    Size.prototype.copyFrom = function (src) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    };\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    Size.prototype.copyFromFloats = function (width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    Size.prototype.set = function (width, height) {\r\n        return this.copyFromFloats(width, height);\r\n    };\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    Size.prototype.multiplyByFloats = function (w, h) {\r\n        return new Size(this.width * w, this.height * h);\r\n    };\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    Size.prototype.clone = function () {\r\n        return new Size(this.width, this.height);\r\n    };\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    Size.prototype.equals = function (other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return (this.width === other.width) && (this.height === other.height);\r\n    };\r\n    Object.defineProperty(Size.prototype, \"surface\", {\r\n        /**\r\n         * The surface of the Size : width * height (float).\r\n         */\r\n        get: function () {\r\n            return this.width * this.height;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    Size.Zero = function () {\r\n        return new Size(0.0, 0.0);\r\n    };\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    Size.prototype.add = function (otherSize) {\r\n        var r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    };\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    Size.prototype.subtract = function (otherSize) {\r\n        var r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    };\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    Size.Lerp = function (start, end, amount) {\r\n        var w = start.width + ((end.width - start.width) * amount);\r\n        var h = start.height + ((end.height - start.height) * amount);\r\n        return new Size(w, h);\r\n    };\r\n    return Size;\r\n}());\r\nexport { Size };\r\n//# sourceMappingURL=math.size.js.map","/**\r\n * Class used to represent data loading progression\r\n */\r\nvar SceneLoaderFlags = /** @class */ (function () {\r\n    function SceneLoaderFlags() {\r\n    }\r\n    Object.defineProperty(SceneLoaderFlags, \"ForceFullSceneLoadingForIncremental\", {\r\n        /**\r\n         * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags._ForceFullSceneLoadingForIncremental;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags._ForceFullSceneLoadingForIncremental = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoaderFlags, \"ShowLoadingScreen\", {\r\n        /**\r\n         * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags._ShowLoadingScreen;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags._ShowLoadingScreen = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoaderFlags, \"loggingLevel\", {\r\n        /**\r\n         * Defines the current logging level (while loading the scene)\r\n         * @ignorenaming\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags._loggingLevel;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags._loggingLevel = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneLoaderFlags, \"CleanBoneMatrixWeights\", {\r\n        /**\r\n         * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n         */\r\n        get: function () {\r\n            return SceneLoaderFlags._CleanBoneMatrixWeights;\r\n        },\r\n        set: function (value) {\r\n            SceneLoaderFlags._CleanBoneMatrixWeights = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Flags\r\n    SceneLoaderFlags._ForceFullSceneLoadingForIncremental = false;\r\n    SceneLoaderFlags._ShowLoadingScreen = true;\r\n    SceneLoaderFlags._CleanBoneMatrixWeights = false;\r\n    SceneLoaderFlags._loggingLevel = 0;\r\n    return SceneLoaderFlags;\r\n}());\r\nexport { SceneLoaderFlags };\r\n//# sourceMappingURL=sceneLoaderFlags.js.map","import { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nvar Geometry = /** @class */ (function () {\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    function Geometry(id, scene, vertexData, updatable, mesh) {\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        /**\r\n         * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n         */\r\n        this.delayLoadState = 0;\r\n        this._totalVertices = 0;\r\n        this._isDisposed = false;\r\n        this._indexBufferIsUpdatable = false;\r\n        this._positionsCache = [];\r\n        /**\r\n         * If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n         * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n         */\r\n        this.useBoundingInfoFromGeometry = false;\r\n        this.id = id;\r\n        this.uniqueId = scene.getUniqueId();\r\n        this._engine = scene.getEngine();\r\n        this._meshes = [];\r\n        this._scene = scene;\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        }\r\n        else {\r\n            this._totalVertices = 0;\r\n            this._indices = [];\r\n        }\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n    Object.defineProperty(Geometry.prototype, \"boundingBias\", {\r\n        /**\r\n         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n         */\r\n        get: function () {\r\n            return this._boundingBias;\r\n        },\r\n        /**\r\n         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n         */\r\n        set: function (value) {\r\n            if (this._boundingBias) {\r\n                this._boundingBias.copyFrom(value);\r\n            }\r\n            else {\r\n                this._boundingBias = value.clone();\r\n            }\r\n            this._updateBoundingInfo(true, null);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    Geometry.CreateGeometryForMesh = function (mesh) {\r\n        var geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n        geometry.applyToMesh(mesh);\r\n        return geometry;\r\n    };\r\n    Object.defineProperty(Geometry.prototype, \"meshes\", {\r\n        /** Get the list of meshes using this geometry */\r\n        get: function () {\r\n            return this._meshes;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Geometry.prototype, \"extend\", {\r\n        /**\r\n         * Gets the current extend of the geometry\r\n         */\r\n        get: function () {\r\n            return this._extend;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    Geometry.prototype.getScene = function () {\r\n        return this._scene;\r\n    };\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    Geometry.prototype.getEngine = function () {\r\n        return this._engine;\r\n    };\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    Geometry.prototype.isReady = function () {\r\n        return this.delayLoadState === 1 || this.delayLoadState === 0;\r\n    };\r\n    Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\r\n        /**\r\n         * Gets a value indicating that the geometry should not be serialized\r\n         */\r\n        get: function () {\r\n            for (var index = 0; index < this._meshes.length; index++) {\r\n                if (!this._meshes[index].doNotSerialize) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @hidden */\r\n    Geometry.prototype._rebuild = function () {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices);\r\n        }\r\n        // Vertex buffers\r\n        for (var key in this._vertexBuffers) {\r\n            var vertexBuffer = this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    };\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this.notifyUpdate();\r\n    };\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\r\n        this.setVerticesBuffer(buffer);\r\n    };\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    Geometry.prototype.removeVerticesData = function (kind) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n    };\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     */\r\n    Geometry.prototype.setVerticesBuffer = function (buffer, totalVertices) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        var kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers[kind] = buffer;\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            var data = buffer.getData();\r\n            if (totalVertices != null) {\r\n                this._totalVertices = totalVertices;\r\n            }\r\n            else {\r\n                if (data != null) {\r\n                    this._totalVertices = data.length / (buffer.byteStride / 4);\r\n                }\r\n            }\r\n            this._updateExtend(data);\r\n            this._resetPointsArrayCache();\r\n            var meshes = this._meshes;\r\n            var numOfMeshes = meshes.length;\r\n            for (var index = 0; index < numOfMeshes; index++) {\r\n                var mesh = meshes[index];\r\n                mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(false);\r\n                mesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n        this.notifyUpdate(kind);\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n        }\r\n    };\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset, useBytes) {\r\n        if (useBytes === void 0) { useBytes = false; }\r\n        var vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this.notifyUpdate(kind);\r\n    };\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\r\n        if (updateExtends === void 0) { updateExtends = false; }\r\n        var vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n        vertexBuffer.update(data);\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this.notifyUpdate(kind);\r\n    };\r\n    Geometry.prototype._updateBoundingInfo = function (updateExtends, data) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n        this._resetPointsArrayCache();\r\n        if (updateExtends) {\r\n            var meshes = this._meshes;\r\n            for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\r\n                var mesh = meshes_1[_i];\r\n                if (mesh._boundingInfo) {\r\n                    mesh._boundingInfo.reConstruct(this._extend.minimum, this._extend.maximum);\r\n                }\r\n                else {\r\n                    mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n                var subMeshes = mesh.subMeshes;\r\n                for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {\r\n                    var subMesh = subMeshes_1[_a];\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /** @hidden */\r\n    Geometry.prototype._bind = function (effect, indexToBind) {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        var vbs = this.getVertexBuffers();\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect);\r\n            return;\r\n        }\r\n        // Using VAO\r\n        if (!this._vertexArrayObjects[effect.key]) {\r\n            this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect);\r\n        }\r\n        this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);\r\n    };\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    Geometry.prototype.getTotalVertices = function () {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._totalVertices;\r\n    };\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\r\n        var vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n        var data = vertexBuffer.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        var tightlyPackedByteStride = vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n        var count = this._totalVertices * vertexBuffer.getSize();\r\n        if (vertexBuffer.type !== VertexBuffer.FLOAT || vertexBuffer.byteStride !== tightlyPackedByteStride) {\r\n            var copy_1 = [];\r\n            vertexBuffer.forEach(count, function (value) { return copy_1.push(value); });\r\n            return copy_1;\r\n        }\r\n        if (!(data instanceof Array || data instanceof Float32Array) || vertexBuffer.byteOffset !== 0 || data.length !== count) {\r\n            if (data instanceof Array) {\r\n                var offset = vertexBuffer.byteOffset / 4;\r\n                return Tools.Slice(data, offset, offset + count);\r\n            }\r\n            else if (data instanceof ArrayBuffer) {\r\n                return new Float32Array(data, vertexBuffer.byteOffset, count);\r\n            }\r\n            else {\r\n                var offset = data.byteOffset + vertexBuffer.byteOffset;\r\n                if (forceCopy || (copyWhenShared && this._meshes.length !== 1)) {\r\n                    var result = new Float32Array(count);\r\n                    var source = new Float32Array(data.buffer, offset, count);\r\n                    result.set(source);\r\n                    return result;\r\n                }\r\n                // Portect against bad data\r\n                var remainder = offset % 4;\r\n                if (remainder) {\r\n                    offset = Math.max(0, offset - remainder);\r\n                }\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n        if (forceCopy || (copyWhenShared && this._meshes.length !== 1)) {\r\n            return Tools.Slice(data);\r\n        }\r\n        return data;\r\n    };\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    Geometry.prototype.isVertexBufferUpdatable = function (kind) {\r\n        var vb = this._vertexBuffers[kind];\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n        return vb.isUpdatable();\r\n    };\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    Geometry.prototype.getVertexBuffer = function (kind) {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    };\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @return an object holding all vertex buffers indexed by kind\r\n     */\r\n    Geometry.prototype.getVertexBuffers = function () {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    };\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    Geometry.prototype.isVerticesDataPresent = function (kind) {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    };\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    Geometry.prototype.getVerticesDataKinds = function () {\r\n        var result = [];\r\n        var kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n        else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    Geometry.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\r\n        if (gpuMemoryOnly === void 0) { gpuMemoryOnly = false; }\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        }\r\n        else {\r\n            var needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\r\n                    var mesh = _a[_i];\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    Geometry.prototype.setIndices = function (indices, totalVertices, updatable) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._disposeVertexArrayObjects();\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\r\n            var mesh = _a[_i];\r\n            mesh._createGlobalSubMesh(true);\r\n        }\r\n        this.notifyUpdate();\r\n    };\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    Geometry.prototype.getTotalIndices = function () {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    };\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    Geometry.prototype.getIndices = function (copyWhenShared, forceCopy) {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        var orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        }\r\n        else {\r\n            var len = orig.length;\r\n            var copy = [];\r\n            for (var i = 0; i < len; i++) {\r\n                copy.push(orig[i]);\r\n            }\r\n            return copy;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the index buffer\r\n     * @return the index buffer\r\n     */\r\n    Geometry.prototype.getIndexBuffer = function () {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    };\r\n    /** @hidden */\r\n    Geometry.prototype._releaseVertexArrayObject = function (effect) {\r\n        if (effect === void 0) { effect = null; }\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    };\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\r\n        var meshes = this._meshes;\r\n        var index = meshes.indexOf(mesh);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        meshes.splice(index, 1);\r\n        mesh._geometry = null;\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    };\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    Geometry.prototype.applyToMesh = function (mesh) {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n        var previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n        var meshes = this._meshes;\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        this._scene.pushGeometry(this);\r\n        meshes.push(mesh);\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        }\r\n        else {\r\n            mesh._boundingInfo = this._boundingInfo;\r\n        }\r\n    };\r\n    Geometry.prototype._updateExtend = function (data) {\r\n        if (data === void 0) { data = null; }\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        }\r\n        else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind);\r\n            }\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    };\r\n    Geometry.prototype._applyToMesh = function (mesh) {\r\n        var numOfMeshes = this._meshes.length;\r\n        // vertexBuffers\r\n        for (var kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n            var buffer = this._vertexBuffers[kind].getBuffer();\r\n            if (buffer) {\r\n                buffer.references = numOfMeshes;\r\n            }\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(false);\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices);\r\n        }\r\n        if (this._indexBuffer) {\r\n            this._indexBuffer.references = numOfMeshes;\r\n        }\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    };\r\n    Geometry.prototype.notifyUpdate = function (kind) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\r\n            var mesh = _a[_i];\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    };\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    Geometry.prototype.load = function (scene, onLoaded) {\r\n        if (this.delayLoadState === 2) {\r\n            return;\r\n        }\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n        this.delayLoadState = 2;\r\n        this._queueLoad(scene, onLoaded);\r\n    };\r\n    Geometry.prototype._queueLoad = function (scene, onLoaded) {\r\n        var _this = this;\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n        scene._addPendingData(this);\r\n        scene._loadFile(this.delayLoadingFile, function (data) {\r\n            if (!_this._delayLoadingFunction) {\r\n                return;\r\n            }\r\n            _this._delayLoadingFunction(JSON.parse(data), _this);\r\n            _this.delayLoadState = 1;\r\n            _this._delayInfo = [];\r\n            scene._removePendingData(_this);\r\n            var meshes = _this._meshes;\r\n            var numOfMeshes = meshes.length;\r\n            for (var index = 0; index < numOfMeshes; index++) {\r\n                _this._applyToMesh(meshes[index]);\r\n            }\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n        }, undefined, true);\r\n    };\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    Geometry.prototype.toLeftHanded = function () {\r\n        // Flip faces\r\n        var tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (var i = 0; i < tIndices.length; i += 3) {\r\n                var tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n        // Negate position.z\r\n        var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (var i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n        // Negate normal.z\r\n        var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (var i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    };\r\n    // Cache\r\n    /** @hidden */\r\n    Geometry.prototype._resetPointsArrayCache = function () {\r\n        this._positions = null;\r\n    };\r\n    /** @hidden */\r\n    Geometry.prototype._generatePointsArray = function () {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n        for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n        for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n        this._positions = this._positionsCache;\r\n        return true;\r\n    };\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    Geometry.prototype.isDisposed = function () {\r\n        return this._isDisposed;\r\n    };\r\n    Geometry.prototype._disposeVertexArrayObjects = function () {\r\n        if (this._vertexArrayObjects) {\r\n            for (var kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {};\r\n        }\r\n    };\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    Geometry.prototype.dispose = function () {\r\n        var meshes = this._meshes;\r\n        var numOfMeshes = meshes.length;\r\n        var index;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes = [];\r\n        this._disposeVertexArrayObjects();\r\n        for (var kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n        this.delayLoadState = 0;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n        this._boundingInfo = null;\r\n        this._scene.removeGeometry(this);\r\n        this._isDisposed = true;\r\n    };\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    Geometry.prototype.copy = function (id) {\r\n        var vertexData = new VertexData();\r\n        vertexData.indices = [];\r\n        var indices = this.getIndices();\r\n        if (indices) {\r\n            for (var index = 0; index < indices.length; index++) {\r\n                vertexData.indices.push(indices[index]);\r\n            }\r\n        }\r\n        var updatable = false;\r\n        var stopChecking = false;\r\n        var kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            var data = this.getVerticesData(kind);\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(data), kind);\r\n                }\r\n                else {\r\n                    vertexData.set(data.slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    var vb = this.getVertexBuffer(kind);\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n        return geometry;\r\n    };\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @return a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    Geometry.prototype.serialize = function () {\r\n        var serializationObject = {};\r\n        serializationObject.id = this.id;\r\n        serializationObject.updatable = this._updatable;\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        return serializationObject;\r\n    };\r\n    Geometry.prototype.toNumberArray = function (origin) {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        }\r\n        else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    };\r\n    /**\r\n     * Serialize all vertices data into a JSON oject\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    Geometry.prototype.serializeVerticeData = function () {\r\n        var serializationObject = this.serialize();\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangets = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangets._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uv2s._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uv3s._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uv4s._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uv5s._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uv6s._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n        serializationObject.indices = this.toNumberArray(this.getIndices());\r\n        return serializationObject;\r\n    };\r\n    // Statics\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    Geometry.ExtractFromMesh = function (mesh, id) {\r\n        var geometry = mesh._geometry;\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n        return geometry.copy(id);\r\n    };\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    Geometry.RandomId = function () {\r\n        return Tools.RandomId();\r\n    };\r\n    /** @hidden */\r\n    Geometry._ImportGeometry = function (parsedGeometry, mesh) {\r\n        var scene = mesh.getScene();\r\n        // Geometry\r\n        var geometryId = parsedGeometry.geometryId;\r\n        if (geometryId) {\r\n            var geometry = scene.getGeometryByID(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        }\r\n        else if (parsedGeometry instanceof ArrayBuffer) {\r\n            var binaryInfo = mesh._binaryInfo;\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                var floatIndices = [];\r\n                for (var i = 0; i < matricesIndicesData.length; i++) {\r\n                    var index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                var floatIndices = [];\r\n                for (var i = 0; i < matricesIndicesData.length; i++) {\r\n                    var index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n                mesh.subMeshes = [];\r\n                for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    var materialIndex = subMeshesData[i * 5 + 0];\r\n                    var verticesStart = subMeshesData[i * 5 + 1];\r\n                    var verticesCount = subMeshesData[i * 5 + 2];\r\n                    var indexStart = subMeshesData[i * 5 + 3];\r\n                    var indexCount = subMeshesData[i * 5 + 4];\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\r\n                }\r\n            }\r\n        }\r\n        else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    var floatIndices = [];\r\n                    for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        var matricesIndex = parsedGeometry.matricesIndices[i];\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n                else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    var floatIndices = [];\r\n                    for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n                else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n                SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\r\n            }\r\n        }\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n        scene.onMeshImportedObservable.notifyObservers(mesh);\r\n    };\r\n    Geometry._CleanMatricesWeights = function (parsedGeometry, mesh) {\r\n        var epsilon = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        var noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            var skeleton = mesh.getScene().getLastSkeletonByID(parsedGeometry.skeletonId);\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        var matricesWeights = parsedGeometry.matricesWeights;\r\n        var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        var influencers = parsedGeometry.numBoneInfluencer;\r\n        var size = matricesWeights.length;\r\n        for (var i = 0; i < size; i += 4) {\r\n            var weight = 0.0;\r\n            var firstZeroWeight = -1;\r\n            for (var j = 0; j < 4; j++) {\r\n                var w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (var j = 0; j < 4; j++) {\r\n                    var w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                var mweight = 1.0 / weight;\r\n                for (var j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (var j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                }\r\n                else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    };\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\r\n        if (scene.getGeometryByID(parsedVertexData.id)) {\r\n            return null; // null since geometry could be something else than a box...\r\n        }\r\n        var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = 4;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        }\r\n        else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n        scene.pushGeometry(geometry, true);\r\n        return geometry;\r\n    };\r\n    return Geometry;\r\n}());\r\nexport { Geometry };\r\n//# sourceMappingURL=geometry.js.map","import { __extends } from \"tslib\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\r\nvar MultiMaterial = /** @class */ (function (_super) {\r\n    __extends(MultiMaterial, _super);\r\n    /**\r\n     * Instantiates a new Multi Material\r\n     * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n     * separate meshes. This can be use to improve performances.\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     * @param name Define the name in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     */\r\n    function MultiMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene, true) || this;\r\n        scene.multiMaterials.push(_this);\r\n        _this.subMaterials = new Array();\r\n        _this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MultiMaterial.prototype, \"subMaterials\", {\r\n        /**\r\n         * Gets or Sets the list of Materials used within the multi material.\r\n         * They need to be ordered according to the submeshes order in the associated mesh\r\n         */\r\n        get: function () {\r\n            return this._subMaterials;\r\n        },\r\n        set: function (value) {\r\n            this._subMaterials = value;\r\n            this._hookArray(value);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Function used to align with Node.getChildren()\r\n     * @returns the list of Materials used within the multi material\r\n     */\r\n    MultiMaterial.prototype.getChildren = function () {\r\n        return this.subMaterials;\r\n    };\r\n    MultiMaterial.prototype._hookArray = function (array) {\r\n        var _this = this;\r\n        var oldPush = array.push;\r\n        array.push = function () {\r\n            var items = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                items[_i] = arguments[_i];\r\n            }\r\n            var result = oldPush.apply(array, items);\r\n            _this._markAllSubMeshesAsTexturesDirty();\r\n            return result;\r\n        };\r\n        var oldSplice = array.splice;\r\n        array.splice = function (index, deleteCount) {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n            _this._markAllSubMeshesAsTexturesDirty();\r\n            return deleted;\r\n        };\r\n    };\r\n    /**\r\n     * Get one of the submaterial by its index in the submaterials array\r\n     * @param index The index to look the sub material at\r\n     * @returns The Material if the index has been defined\r\n     */\r\n    MultiMaterial.prototype.getSubMaterial = function (index) {\r\n        if (index < 0 || index >= this.subMaterials.length) {\r\n            return this.getScene().defaultMaterial;\r\n        }\r\n        return this.subMaterials[index];\r\n    };\r\n    /**\r\n     * Get the list of active textures for the whole sub materials list.\r\n     * @returns All the textures that will be used during the rendering\r\n     */\r\n    MultiMaterial.prototype.getActiveTextures = function () {\r\n        var _a;\r\n        return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function (subMaterial) {\r\n            if (subMaterial) {\r\n                return subMaterial.getActiveTextures();\r\n            }\r\n            else {\r\n                return [];\r\n            }\r\n        }));\r\n    };\r\n    /**\r\n     * Specifies if any sub-materials of this multi-material use a given texture.\r\n     * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n     * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n     */\r\n    MultiMaterial.prototype.hasTexture = function (texture) {\r\n        var _a;\r\n        if (_super.prototype.hasTexture.call(this, texture)) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < this.subMaterials.length; i++) {\r\n            if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    MultiMaterial.prototype.getClassName = function () {\r\n        return \"MultiMaterial\";\r\n    };\r\n    /**\r\n     * Checks if the material is ready to render the requested sub mesh\r\n     * @param mesh Define the mesh the submesh belongs to\r\n     * @param subMesh Define the sub mesh to look readyness for\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    MultiMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial = this.subMaterials[index];\r\n            if (subMaterial) {\r\n                if (subMaterial._storeEffectOnSubMeshes) {\r\n                    if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (!subMaterial.isReady(mesh)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Clones the current material and its related sub materials\r\n     * @param name Define the name of the newly cloned material\r\n     * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n     * @returns the cloned material\r\n     */\r\n    MultiMaterial.prototype.clone = function (name, cloneChildren) {\r\n        var newMultiMaterial = new MultiMaterial(name, this.getScene());\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial = null;\r\n            var current = this.subMaterials[index];\r\n            if (cloneChildren && current) {\r\n                subMaterial = current.clone(name + \"-\" + current.name);\r\n            }\r\n            else {\r\n                subMaterial = this.subMaterials[index];\r\n            }\r\n            newMultiMaterial.subMaterials.push(subMaterial);\r\n        }\r\n        return newMultiMaterial;\r\n    };\r\n    /**\r\n     * Serializes the materials into a JSON representation.\r\n     * @returns the JSON representation\r\n     */\r\n    MultiMaterial.prototype.serialize = function () {\r\n        var serializationObject = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.materials = [];\r\n        for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\r\n            var subMat = this.subMaterials[matIndex];\r\n            if (subMat) {\r\n                serializationObject.materials.push(subMat.id);\r\n            }\r\n            else {\r\n                serializationObject.materials.push(null);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Dispose the material and release its associated resources\r\n     * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n     * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     */\r\n    MultiMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        if (forceDisposeChildren) {\r\n            for (var index = 0; index < this.subMaterials.length; index++) {\r\n                var subMaterial = this.subMaterials[index];\r\n                if (subMaterial) {\r\n                    subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\r\n                }\r\n            }\r\n        }\r\n        var index = scene.multiMaterials.indexOf(this);\r\n        if (index >= 0) {\r\n            scene.multiMaterials.splice(index, 1);\r\n        }\r\n        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\r\n    };\r\n    /**\r\n     * Creates a MultiMaterial from parsed MultiMaterial data.\r\n     * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MultiMaterial\r\n     */\r\n    MultiMaterial.ParseMultiMaterial = function (parsedMultiMaterial, scene) {\r\n        var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\r\n        multiMaterial.id = parsedMultiMaterial.id;\r\n        if (Tags) {\r\n            Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\r\n        }\r\n        for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\r\n            var subMatId = parsedMultiMaterial.materials[matIndex];\r\n            if (subMatId) {\r\n                // If the same multimaterial is loaded twice, the 2nd multimaterial needs to reference the latest material by that id which\r\n                // is why this lookup should use getLastMaterialByID instead of getMaterialByID\r\n                multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));\r\n            }\r\n            else {\r\n                multiMaterial.subMaterials.push(null);\r\n            }\r\n        }\r\n        return multiMaterial;\r\n    };\r\n    return MultiMaterial;\r\n}(Material));\r\nexport { MultiMaterial };\r\n_TypeStore.RegisteredTypes[\"BABYLON.MultiMaterial\"] = MultiMaterial;\r\n//# sourceMappingURL=multiMaterial.js.map","/**\r\n * Class used to represent a specific level of detail of a mesh\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n */\r\nvar MeshLODLevel = /** @class */ (function () {\r\n    /**\r\n     * Creates a new LOD level\r\n     * @param distance defines the distance where this level should star being displayed\r\n     * @param mesh defines the mesh to use to render this level\r\n     */\r\n    function MeshLODLevel(\r\n    /** Defines the distance where this level should start being displayed */\r\n    distance, \r\n    /** Defines the mesh to use to render this level */\r\n    mesh) {\r\n        this.distance = distance;\r\n        this.mesh = mesh;\r\n    }\r\n    return MeshLODLevel;\r\n}());\r\nexport { MeshLODLevel };\r\n//# sourceMappingURL=meshLODLevel.js.map","import { __extends } from \"tslib\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools, AsyncLoop } from \"../Misc/tools\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer } from \"./buffer\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\nimport { Buffer } from \"./buffer\";\r\nimport { Geometry } from \"./geometry\";\r\nimport { AbstractMesh } from \"./abstractMesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { MeshLODLevel } from './meshLODLevel';\r\nimport { CanvasGenerator } from '../Misc/canvasGenerator';\r\n/**\r\n * @hidden\r\n **/\r\nvar _CreationDataStorage = /** @class */ (function () {\r\n    function _CreationDataStorage() {\r\n    }\r\n    return _CreationDataStorage;\r\n}());\r\nexport { _CreationDataStorage };\r\n/**\r\n * @hidden\r\n **/\r\nvar _InstanceDataStorage = /** @class */ (function () {\r\n    function _InstanceDataStorage() {\r\n        this.visibleInstances = {};\r\n        this.batchCache = new _InstancesBatch();\r\n        this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\r\n    }\r\n    return _InstanceDataStorage;\r\n}());\r\n/**\r\n * @hidden\r\n **/\r\nvar _InstancesBatch = /** @class */ (function () {\r\n    function _InstancesBatch() {\r\n        this.mustReturn = false;\r\n        this.visibleInstances = new Array();\r\n        this.renderSelf = new Array();\r\n        this.hardwareInstancedRendering = new Array();\r\n    }\r\n    return _InstancesBatch;\r\n}());\r\nexport { _InstancesBatch };\r\n/**\r\n * @hidden\r\n **/\r\nvar _ThinInstanceDataStorage = /** @class */ (function () {\r\n    function _ThinInstanceDataStorage() {\r\n        this.instancesCount = 0;\r\n        this.matrixBuffer = null;\r\n        this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\r\n        this.boundingVectors = [];\r\n        this.worldMatrices = null;\r\n    }\r\n    return _ThinInstanceDataStorage;\r\n}());\r\n/**\r\n * @hidden\r\n **/\r\nvar _InternalMeshDataInfo = /** @class */ (function () {\r\n    function _InternalMeshDataInfo() {\r\n        this._areNormalsFrozen = false; // Will be used by ribbons mainly\r\n        // Will be used to save a source mesh reference, If any\r\n        this._source = null;\r\n        // Will be used to for fast cloned mesh lookup\r\n        this.meshMap = null;\r\n        this._preActivateId = -1;\r\n        this._LODLevels = new Array();\r\n        // Morph\r\n        this._morphTargetManager = null;\r\n    }\r\n    return _InternalMeshDataInfo;\r\n}());\r\n/**\r\n * Class used to represent renderable models\r\n */\r\nvar Mesh = /** @class */ (function (_super) {\r\n    __extends(Mesh, _super);\r\n    /**\r\n     * @constructor\r\n     * @param name The value used by scene.getMeshByName() to do a lookup.\r\n     * @param scene The scene to add this mesh to.\r\n     * @param parent The parent of this mesh, if it has one\r\n     * @param source An optional Mesh from which geometry is shared, cloned.\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     *                  When false, achieved by calling a clone(), also passing False.\r\n     *                  This will make creation of children, recursive.\r\n     * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\r\n     */\r\n    function Mesh(name, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (parent === void 0) { parent = null; }\r\n        if (source === void 0) { source = null; }\r\n        if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\r\n        var _this = _super.call(this, name, scene) || this;\r\n        // Internal data\r\n        _this._internalMeshDataInfo = new _InternalMeshDataInfo();\r\n        // Members\r\n        /**\r\n         * Gets the delay loading state of the mesh (when delay loading is turned on)\r\n         * @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system\r\n         */\r\n        _this.delayLoadState = 0;\r\n        /**\r\n         * Gets the list of instances created from this mesh\r\n         * it is not supposed to be modified manually.\r\n         * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n         */\r\n        _this.instances = new Array();\r\n        // Private\r\n        /** @hidden */\r\n        _this._creationDataStorage = null;\r\n        /** @hidden */\r\n        _this._geometry = null;\r\n        /** @hidden */\r\n        _this._instanceDataStorage = new _InstanceDataStorage();\r\n        /** @hidden */\r\n        _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\r\n        _this._effectiveMaterial = null;\r\n        /** @hidden */\r\n        _this._shouldGenerateFlatShading = false;\r\n        // Use by builder only to know what orientation were the mesh build in.\r\n        /** @hidden */\r\n        _this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\r\n        /**\r\n         * Use this property to change the original side orientation defined at construction time\r\n         */\r\n        _this.overrideMaterialSideOrientation = null;\r\n        scene = _this.getScene();\r\n        if (source) {\r\n            // Geometry\r\n            if (source._geometry) {\r\n                source._geometry.applyToMesh(_this);\r\n            }\r\n            // Deep copy\r\n            DeepCopier.DeepCopy(source, _this, [\r\n                \"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"morphTargetManager\",\r\n                \"hasInstances\", \"source\", \"worldMatrixInstancedBuffer\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\",\r\n                \"facetNb\", \"isFacetDataEnabled\", \"lightSources\", \"useBones\", \"isAnInstance\", \"collider\", \"edgesRenderer\", \"forward\",\r\n                \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"cloneMeshMap\"\r\n            ], [\"_poseMatrix\"]);\r\n            // Source mesh\r\n            _this._internalMeshDataInfo._source = source;\r\n            if (scene.useClonedMeshMap) {\r\n                if (!source._internalMeshDataInfo.meshMap) {\r\n                    source._internalMeshDataInfo.meshMap = {};\r\n                }\r\n                source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;\r\n            }\r\n            // Construction Params\r\n            // Clone parameters allowing mesh to be updated in case of parametric shapes.\r\n            _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\r\n            _this._creationDataStorage = source._creationDataStorage;\r\n            // Animation ranges\r\n            if (source._ranges) {\r\n                var ranges = source._ranges;\r\n                for (var name in ranges) {\r\n                    if (!ranges.hasOwnProperty(name)) {\r\n                        continue;\r\n                    }\r\n                    if (!ranges[name]) {\r\n                        continue;\r\n                    }\r\n                    _this.createAnimationRange(name, ranges[name].from, ranges[name].to);\r\n                }\r\n            }\r\n            // Metadata\r\n            if (source.metadata && source.metadata.clone) {\r\n                _this.metadata = source.metadata.clone();\r\n            }\r\n            else {\r\n                _this.metadata = source.metadata;\r\n            }\r\n            // Tags\r\n            if (Tags && Tags.HasTags(source)) {\r\n                Tags.AddTagsTo(_this, Tags.GetTags(source, true));\r\n            }\r\n            // Enabled\r\n            _this.setEnabled(source.isEnabled());\r\n            // Parent\r\n            _this.parent = source.parent;\r\n            // Pivot\r\n            _this.setPivotMatrix(source.getPivotMatrix());\r\n            _this.id = name + \".\" + source.id;\r\n            // Material\r\n            _this.material = source.material;\r\n            var index;\r\n            if (!doNotCloneChildren) {\r\n                // Children\r\n                var directDescendants = source.getDescendants(true);\r\n                for (var index_1 = 0; index_1 < directDescendants.length; index_1++) {\r\n                    var child = directDescendants[index_1];\r\n                    if (child.clone) {\r\n                        child.clone(name + \".\" + child.name, _this);\r\n                    }\r\n                }\r\n            }\r\n            // Morphs\r\n            if (source.morphTargetManager) {\r\n                _this.morphTargetManager = source.morphTargetManager;\r\n            }\r\n            // Physics clone\r\n            if (scene.getPhysicsEngine) {\r\n                var physicsEngine = scene.getPhysicsEngine();\r\n                if (clonePhysicsImpostor && physicsEngine) {\r\n                    var impostor = physicsEngine.getImpostorForPhysicsObject(source);\r\n                    if (impostor) {\r\n                        _this.physicsImpostor = impostor.clone(_this);\r\n                    }\r\n                }\r\n            }\r\n            // Particles\r\n            for (index = 0; index < scene.particleSystems.length; index++) {\r\n                var system = scene.particleSystems[index];\r\n                if (system.emitter === source) {\r\n                    system.clone(system.name, _this);\r\n                }\r\n            }\r\n            _this.refreshBoundingInfo();\r\n            _this.computeWorldMatrix(true);\r\n        }\r\n        // Parent\r\n        if (parent !== null) {\r\n            _this.parent = parent;\r\n        }\r\n        _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Gets the default side orientation.\r\n     * @param orientation the orientation to value to attempt to get\r\n     * @returns the default orientation\r\n     * @hidden\r\n     */\r\n    Mesh._GetDefaultSideOrientation = function (orientation) {\r\n        return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"computeBonesUsingShaders\", {\r\n        get: function () {\r\n            return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n        },\r\n        set: function (value) {\r\n            if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n                return;\r\n            }\r\n            if (value && this._internalMeshDataInfo._sourcePositions) {\r\n                // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\r\n                this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions.slice(), true);\r\n                if (this._internalMeshDataInfo._sourceNormals) {\r\n                    this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals.slice(), true);\r\n                }\r\n            }\r\n            this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n            this._markSubMeshesAsAttributesDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"onBeforeRenderObservable\", {\r\n        /**\r\n         * An event triggered before rendering the mesh\r\n         */\r\n        get: function () {\r\n            if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\r\n                this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\r\n            }\r\n            return this._internalMeshDataInfo._onBeforeRenderObservable;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"onBeforeBindObservable\", {\r\n        /**\r\n         * An event triggered before binding the mesh\r\n         */\r\n        get: function () {\r\n            if (!this._internalMeshDataInfo._onBeforeBindObservable) {\r\n                this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\r\n            }\r\n            return this._internalMeshDataInfo._onBeforeBindObservable;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"onAfterRenderObservable\", {\r\n        /**\r\n        * An event triggered after rendering the mesh\r\n        */\r\n        get: function () {\r\n            if (!this._internalMeshDataInfo._onAfterRenderObservable) {\r\n                this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\r\n            }\r\n            return this._internalMeshDataInfo._onAfterRenderObservable;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"onBeforeDrawObservable\", {\r\n        /**\r\n        * An event triggered before drawing the mesh\r\n        */\r\n        get: function () {\r\n            if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\r\n                this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\r\n            }\r\n            return this._internalMeshDataInfo._onBeforeDrawObservable;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"onBeforeDraw\", {\r\n        /**\r\n         * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\r\n         */\r\n        set: function (callback) {\r\n            if (this._onBeforeDrawObserver) {\r\n                this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\r\n            }\r\n            this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"hasInstances\", {\r\n        get: function () {\r\n            return this.instances.length > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"hasThinInstances\", {\r\n        get: function () {\r\n            var _a;\r\n            return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"morphTargetManager\", {\r\n        /**\r\n         * Gets or sets the morph target manager\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n         */\r\n        get: function () {\r\n            return this._internalMeshDataInfo._morphTargetManager;\r\n        },\r\n        set: function (value) {\r\n            if (this._internalMeshDataInfo._morphTargetManager === value) {\r\n                return;\r\n            }\r\n            this._internalMeshDataInfo._morphTargetManager = value;\r\n            this._syncGeometryWithMorphTargetManager();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"source\", {\r\n        /**\r\n         * Gets the source mesh (the one used to clone this one from)\r\n         */\r\n        get: function () {\r\n            return this._internalMeshDataInfo._source;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"cloneMeshMap\", {\r\n        /**\r\n         * Gets the list of clones of this mesh\r\n         * The scene must have been constructed with useClonedMeshMap=true for this to work!\r\n         * Note that useClonedMeshMap=true is the default setting\r\n         */\r\n        get: function () {\r\n            return this._internalMeshDataInfo.meshMap;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"isUnIndexed\", {\r\n        /**\r\n         * Gets or sets a boolean indicating that this mesh does not use index buffer\r\n         */\r\n        get: function () {\r\n            return this._unIndexed;\r\n        },\r\n        set: function (value) {\r\n            if (this._unIndexed !== value) {\r\n                this._unIndexed = value;\r\n                this._markSubMeshesAsAttributesDirty();\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"worldMatrixInstancedBuffer\", {\r\n        /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\r\n        get: function () {\r\n            return this._instanceDataStorage.instancesData;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mesh.prototype, \"manualUpdateOfWorldMatrixInstancedBuffer\", {\r\n        /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\r\n        get: function () {\r\n            return this._instanceDataStorage.manualUpdate;\r\n        },\r\n        set: function (value) {\r\n            this._instanceDataStorage.manualUpdate = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    Mesh.prototype.instantiateHierarchy = function (newParent, options, onNewNodeCreated) {\r\n        if (newParent === void 0) { newParent = null; }\r\n        var instance = (this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate)) ? this.createInstance(\"instance of \" + (this.name || this.id)) : this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\r\n        if (instance) {\r\n            instance.parent = newParent || this.parent;\r\n            instance.position = this.position.clone();\r\n            instance.scaling = this.scaling.clone();\r\n            if (this.rotationQuaternion) {\r\n                instance.rotationQuaternion = this.rotationQuaternion.clone();\r\n            }\r\n            else {\r\n                instance.rotation = this.rotation.clone();\r\n            }\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, instance);\r\n            }\r\n        }\r\n        for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {\r\n            var child = _a[_i];\r\n            child.instantiateHierarchy(instance, options, onNewNodeCreated);\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"Mesh\".\r\n     */\r\n    Mesh.prototype.getClassName = function () {\r\n        return \"Mesh\";\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"_isMesh\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns a description of this mesh\r\n     * @param fullDetails define if full details about this mesh must be used\r\n     * @returns a descriptive string representing this mesh\r\n     */\r\n    Mesh.prototype.toString = function (fullDetails) {\r\n        var ret = _super.prototype.toString.call(this, fullDetails);\r\n        ret += \", n vertices: \" + this.getTotalVertices();\r\n        ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : (this.parent ? this.parent.name : \"NONE\"));\r\n        if (this.animations) {\r\n            for (var i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        if (fullDetails) {\r\n            if (this._geometry) {\r\n                var ib = this.getIndices();\r\n                var vb = this.getVerticesData(VertexBuffer.PositionKind);\r\n                if (vb && ib) {\r\n                    ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\r\n                }\r\n            }\r\n            else {\r\n                ret += \", flat shading: UNKNOWN\";\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._unBindEffect = function () {\r\n        _super.prototype._unBindEffect.call(this);\r\n        for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\r\n            var instance = _a[_i];\r\n            instance._unBindEffect();\r\n        }\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"hasLODLevels\", {\r\n        /**\r\n         * Gets a boolean indicating if this mesh has LOD\r\n         */\r\n        get: function () {\r\n            return this._internalMeshDataInfo._LODLevels.length > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the list of MeshLODLevel associated with the current mesh\r\n     * @returns an array of MeshLODLevel\r\n     */\r\n    Mesh.prototype.getLODLevels = function () {\r\n        return this._internalMeshDataInfo._LODLevels;\r\n    };\r\n    Mesh.prototype._sortLODLevels = function () {\r\n        this._internalMeshDataInfo._LODLevels.sort(function (a, b) {\r\n            if (a.distance < b.distance) {\r\n                return 1;\r\n            }\r\n            if (a.distance > b.distance) {\r\n                return -1;\r\n            }\r\n            return 0;\r\n        });\r\n    };\r\n    /**\r\n     * Add a mesh as LOD level triggered at the given distance.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param distance The distance from the center of the object to show this level\r\n     * @param mesh The mesh to be added as LOD level (can be null)\r\n     * @return This mesh (for chaining)\r\n     */\r\n    Mesh.prototype.addLODLevel = function (distance, mesh) {\r\n        if (mesh && mesh._masterMesh) {\r\n            Logger.Warn(\"You cannot use a mesh as LOD level twice\");\r\n            return this;\r\n        }\r\n        var level = new MeshLODLevel(distance, mesh);\r\n        this._internalMeshDataInfo._LODLevels.push(level);\r\n        if (mesh) {\r\n            mesh._masterMesh = this;\r\n        }\r\n        this._sortLODLevels();\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns the LOD level mesh at the passed distance or null if not found.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param distance The distance from the center of the object to show this level\r\n     * @returns a Mesh or `null`\r\n     */\r\n    Mesh.prototype.getLODLevelAtDistance = function (distance) {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            var level = internalDataInfo._LODLevels[index];\r\n            if (level.distance === distance) {\r\n                return level.mesh;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Remove a mesh from the LOD array\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param mesh defines the mesh to be removed\r\n     * @return This mesh (for chaining)\r\n     */\r\n    Mesh.prototype.removeLODLevel = function (mesh) {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            if (internalDataInfo._LODLevels[index].mesh === mesh) {\r\n                internalDataInfo._LODLevels.splice(index, 1);\r\n                if (mesh) {\r\n                    mesh._masterMesh = null;\r\n                }\r\n            }\r\n        }\r\n        this._sortLODLevels();\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param camera defines the camera to use to compute distance\r\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\r\n     * @return This mesh (for chaining)\r\n     */\r\n    Mesh.prototype.getLOD = function (camera, boundingSphere) {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\r\n            return this;\r\n        }\r\n        var bSphere;\r\n        if (boundingSphere) {\r\n            bSphere = boundingSphere;\r\n        }\r\n        else {\r\n            var boundingInfo = this.getBoundingInfo();\r\n            bSphere = boundingInfo.boundingSphere;\r\n        }\r\n        var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();\r\n        if (internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distance > distanceToCamera) {\r\n            if (this.onLODLevelSelection) {\r\n                this.onLODLevelSelection(distanceToCamera, this, this);\r\n            }\r\n            return this;\r\n        }\r\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            var level = internalDataInfo._LODLevels[index];\r\n            if (level.distance < distanceToCamera) {\r\n                if (level.mesh) {\r\n                    if (level.mesh.delayLoadState === 4) {\r\n                        level.mesh._checkDelayState();\r\n                        return this;\r\n                    }\r\n                    if (level.mesh.delayLoadState === 2) {\r\n                        return this;\r\n                    }\r\n                    level.mesh._preActivate();\r\n                    level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n                }\r\n                if (this.onLODLevelSelection) {\r\n                    this.onLODLevelSelection(distanceToCamera, this, level.mesh);\r\n                }\r\n                return level.mesh;\r\n            }\r\n        }\r\n        if (this.onLODLevelSelection) {\r\n            this.onLODLevelSelection(distanceToCamera, this, this);\r\n        }\r\n        return this;\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"geometry\", {\r\n        /**\r\n         * Gets the mesh internal Geometry object\r\n         */\r\n        get: function () {\r\n            return this._geometry;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\r\n     * @returns the total number of vertices\r\n     */\r\n    Mesh.prototype.getTotalVertices = function () {\r\n        if (this._geometry === null || this._geometry === undefined) {\r\n            return 0;\r\n        }\r\n        return this._geometry.getTotalVertices();\r\n    };\r\n    /**\r\n     * Returns the content of an associated vertex buffer\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\r\n     */\r\n    Mesh.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\r\n        if (!this._geometry) {\r\n            return null;\r\n        }\r\n        return this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    };\r\n    /**\r\n     * Returns the mesh VertexBuffer object from the requested `kind`\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\r\n     */\r\n    Mesh.prototype.getVertexBuffer = function (kind) {\r\n        if (!this._geometry) {\r\n            return null;\r\n        }\r\n        return this._geometry.getVertexBuffer(kind);\r\n    };\r\n    /**\r\n     * Tests if a specific vertex buffer is associated with this mesh\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a boolean\r\n     */\r\n    Mesh.prototype.isVerticesDataPresent = function (kind) {\r\n        if (!this._geometry) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._geometry.isVerticesDataPresent(kind);\r\n    };\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a boolean\r\n     */\r\n    Mesh.prototype.isVertexBufferUpdatable = function (kind) {\r\n        if (!this._geometry) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._geometry.isVertexBufferUpdatable(kind);\r\n    };\r\n    /**\r\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns an array of strings\r\n     */\r\n    Mesh.prototype.getVerticesDataKinds = function () {\r\n        if (!this._geometry) {\r\n            var result = new Array();\r\n            if (this._delayInfo) {\r\n                this._delayInfo.forEach(function (kind) {\r\n                    result.push(kind);\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        return this._geometry.getVerticesDataKinds();\r\n    };\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    Mesh.prototype.getTotalIndices = function () {\r\n        if (!this._geometry) {\r\n            return 0;\r\n        }\r\n        return this._geometry.getTotalIndices();\r\n    };\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    Mesh.prototype.getIndices = function (copyWhenShared, forceCopy) {\r\n        if (!this._geometry) {\r\n            return [];\r\n        }\r\n        return this._geometry.getIndices(copyWhenShared, forceCopy);\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"isBlocked\", {\r\n        get: function () {\r\n            return this._masterMesh !== null && this._masterMesh !== undefined;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Determine if the current mesh is ready to be rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\r\n     * @returns true if all associated assets are ready (material, textures, shaders)\r\n     */\r\n    Mesh.prototype.isReady = function (completeCheck, forceInstanceSupport) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        if (completeCheck === void 0) { completeCheck = false; }\r\n        if (forceInstanceSupport === void 0) { forceInstanceSupport = false; }\r\n        if (this.delayLoadState === 2) {\r\n            return false;\r\n        }\r\n        if (!_super.prototype.isReady.call(this, completeCheck)) {\r\n            return false;\r\n        }\r\n        if (!this.subMeshes || this.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n        if (!completeCheck) {\r\n            return true;\r\n        }\r\n        var engine = this.getEngine();\r\n        var scene = this.getScene();\r\n        var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);\r\n        this.computeWorldMatrix();\r\n        var mat = this.material || scene.defaultMaterial;\r\n        if (mat) {\r\n            if (mat._storeEffectOnSubMeshes) {\r\n                for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {\r\n                    var subMesh = _g[_i];\r\n                    var effectiveMaterial = subMesh.getMaterial();\r\n                    if (effectiveMaterial) {\r\n                        if (effectiveMaterial._storeEffectOnSubMeshes) {\r\n                            if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (!mat.isReady(this, hardwareInstancedRendering)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        // Shadows\r\n        for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {\r\n            var light = _j[_h];\r\n            var generator = light.getShadowGenerator();\r\n            if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {\r\n                for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {\r\n                    var subMesh = _l[_k];\r\n                    if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // LOD\r\n        for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {\r\n            var lod = _o[_m];\r\n            if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"areNormalsFrozen\", {\r\n        /**\r\n         * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\r\n         */\r\n        get: function () {\r\n            return this._internalMeshDataInfo._areNormalsFrozen;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.freezeNormals = function () {\r\n        this._internalMeshDataInfo._areNormalsFrozen = true;\r\n        return this;\r\n    };\r\n    /**\r\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.unfreezeNormals = function () {\r\n        this._internalMeshDataInfo._areNormalsFrozen = false;\r\n        return this;\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"overridenInstanceCount\", {\r\n        /**\r\n         * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\r\n         */\r\n        set: function (count) {\r\n            this._instanceDataStorage.overridenInstanceCount = count;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    /** @hidden */\r\n    Mesh.prototype._preActivate = function () {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        var sceneRenderId = this.getScene().getRenderId();\r\n        if (internalDataInfo._preActivateId === sceneRenderId) {\r\n            return this;\r\n        }\r\n        internalDataInfo._preActivateId = sceneRenderId;\r\n        this._instanceDataStorage.visibleInstances = null;\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._preActivateForIntermediateRendering = function (renderId) {\r\n        if (this._instanceDataStorage.visibleInstances) {\r\n            this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._registerInstanceForRenderId = function (instance, renderId) {\r\n        if (!this._instanceDataStorage.visibleInstances) {\r\n            this._instanceDataStorage.visibleInstances = {\r\n                defaultRenderId: renderId,\r\n                selfDefaultRenderId: this._renderId\r\n            };\r\n        }\r\n        if (!this._instanceDataStorage.visibleInstances[renderId]) {\r\n            if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\r\n                this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\r\n            }\r\n            this._instanceDataStorage.previousRenderId = renderId;\r\n            this._instanceDataStorage.visibleInstances[renderId] = new Array();\r\n        }\r\n        this._instanceDataStorage.visibleInstances[renderId].push(instance);\r\n        return this;\r\n    };\r\n    Mesh.prototype._afterComputeWorldMatrix = function () {\r\n        _super.prototype._afterComputeWorldMatrix.call(this);\r\n        if (!this.hasThinInstances) {\r\n            return;\r\n        }\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._postActivate = function () {\r\n        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\r\n            this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\r\n            this.edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        }\r\n    };\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.refreshBoundingInfo = function (applySkeleton) {\r\n        if (applySkeleton === void 0) { applySkeleton = false; }\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n        var bias = this.geometry ? this.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._createGlobalSubMesh = function (force) {\r\n        var totalVertices = this.getTotalVertices();\r\n        if (!totalVertices || !this.getIndices()) {\r\n            return null;\r\n        }\r\n        // Check if we need to recreate the submeshes\r\n        if (this.subMeshes && this.subMeshes.length > 0) {\r\n            var ib = this.getIndices();\r\n            if (!ib) {\r\n                return null;\r\n            }\r\n            var totalIndices = ib.length;\r\n            var needToRecreate = false;\r\n            if (force) {\r\n                needToRecreate = true;\r\n            }\r\n            else {\r\n                for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\r\n                    var submesh = _a[_i];\r\n                    if (submesh.indexStart + submesh.indexCount > totalIndices) {\r\n                        needToRecreate = true;\r\n                        break;\r\n                    }\r\n                    if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\r\n                        needToRecreate = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!needToRecreate) {\r\n                return this.subMeshes[0];\r\n            }\r\n        }\r\n        this.releaseSubMeshes();\r\n        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\r\n    };\r\n    /**\r\n     * This function will subdivide the mesh into multiple submeshes\r\n     * @param count defines the expected number of submeshes\r\n     */\r\n    Mesh.prototype.subdivide = function (count) {\r\n        if (count < 1) {\r\n            return;\r\n        }\r\n        var totalIndices = this.getTotalIndices();\r\n        var subdivisionSize = (totalIndices / count) | 0;\r\n        var offset = 0;\r\n        // Ensure that subdivisionSize is a multiple of 3\r\n        while (subdivisionSize % 3 !== 0) {\r\n            subdivisionSize++;\r\n        }\r\n        this.releaseSubMeshes();\r\n        for (var index = 0; index < count; index++) {\r\n            if (offset >= totalIndices) {\r\n                break;\r\n            }\r\n            SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\r\n            offset += subdivisionSize;\r\n        }\r\n        this.synchronizeInstances();\r\n    };\r\n    /**\r\n     * Copy a FloatArray into a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\r\n     * @param stride defines the data stride size (can be null)\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (!this._geometry) {\r\n            var vertexData = new VertexData();\r\n            vertexData.set(data, kind);\r\n            var scene = this.getScene();\r\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\r\n        }\r\n        else {\r\n            this._geometry.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Delete a vertex buffer associated with this mesh\r\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     */\r\n    Mesh.prototype.removeVerticesData = function (kind) {\r\n        if (!this._geometry) {\r\n            return;\r\n        }\r\n        this._geometry.removeVerticesData(kind);\r\n    };\r\n    /**\r\n     * Flags an associated vertex buffer as updatable\r\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\r\n     */\r\n    Mesh.prototype.markVerticesDataAsUpdatable = function (kind, updatable) {\r\n        if (updatable === void 0) { updatable = true; }\r\n        var vb = this.getVertexBuffer(kind);\r\n        if (!vb || vb.isUpdatable() === updatable) {\r\n            return;\r\n        }\r\n        this.setVerticesData(kind, this.getVerticesData(kind), updatable);\r\n    };\r\n    /**\r\n     * Sets the mesh global Vertex Buffer\r\n     * @param buffer defines the buffer to use\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.setVerticesBuffer = function (buffer) {\r\n        if (!this._geometry) {\r\n            this._geometry = Geometry.CreateGeometryForMesh(this);\r\n        }\r\n        this._geometry.setVerticesBuffer(buffer);\r\n        return this;\r\n    };\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        if (!makeItUnique) {\r\n            this._geometry.updateVerticesData(kind, data, updateExtends);\r\n        }\r\n        else {\r\n            this.makeGeometryUnique();\r\n            this.updateVerticesData(kind, data, updateExtends, false);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions\r\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\r\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.updateMeshPositions = function (positionFunction, computeNormals) {\r\n        if (computeNormals === void 0) { computeNormals = true; }\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n        positionFunction(positions);\r\n        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (computeNormals) {\r\n            var indices = this.getIndices();\r\n            var normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!normals) {\r\n                return this;\r\n            }\r\n            VertexData.ComputeNormals(positions, indices, normals);\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Creates a un-shared specific occurence of the geometry for the mesh.\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.makeGeometryUnique = function () {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        if (this._geometry.meshes.length === 1) {\r\n            return this;\r\n        }\r\n        var oldGeometry = this._geometry;\r\n        var geometry = this._geometry.copy(Geometry.RandomId());\r\n        oldGeometry.releaseForMesh(this, true);\r\n        geometry.applyToMesh(this);\r\n        return this;\r\n    };\r\n    /**\r\n     * Set the index buffer of this mesh\r\n     * @param indices defines the source data\r\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\r\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.setIndices = function (indices, totalVertices, updatable) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (!this._geometry) {\r\n            var vertexData = new VertexData();\r\n            vertexData.indices = indices;\r\n            var scene = this.getScene();\r\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\r\n        }\r\n        else {\r\n            this._geometry.setIndices(indices, totalVertices, updatable);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Update the current index buffer\r\n     * @param indices defines the source data\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\r\n        if (gpuMemoryOnly === void 0) { gpuMemoryOnly = false; }\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\r\n        return this;\r\n    };\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.toLeftHanded = function () {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        this._geometry.toLeftHanded();\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._bind = function (subMesh, effect, fillMode) {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        var engine = this.getScene().getEngine();\r\n        // Wireframe\r\n        var indexToBind;\r\n        if (this._unIndexed) {\r\n            indexToBind = null;\r\n        }\r\n        else {\r\n            switch (fillMode) {\r\n                case Material.PointFillMode:\r\n                    indexToBind = null;\r\n                    break;\r\n                case Material.WireFrameFillMode:\r\n                    indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\r\n                    break;\r\n                default:\r\n                case Material.TriangleFillMode:\r\n                    indexToBind = this._geometry.getIndexBuffer();\r\n                    break;\r\n            }\r\n        }\r\n        // VBOs\r\n        this._geometry._bind(effect, indexToBind);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n        if (this._internalMeshDataInfo._onBeforeDrawObservable) {\r\n            this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\r\n        }\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n        if (this._unIndexed || fillMode == Material.PointFillMode) {\r\n            // or triangles as points\r\n            engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        }\r\n        else if (fillMode == Material.WireFrameFillMode) {\r\n            // Triangles as wireframe\r\n            engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, instancesCount);\r\n        }\r\n        else {\r\n            engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers for this mesh a javascript function called just before the rendering process\r\n     * @param func defines the function to call before rendering this mesh\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.registerBeforeRender = function (func) {\r\n        this.onBeforeRenderObservable.add(func);\r\n        return this;\r\n    };\r\n    /**\r\n     * Disposes a previously registered javascript function called before the rendering\r\n     * @param func defines the function to remove\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.unregisterBeforeRender = function (func) {\r\n        this.onBeforeRenderObservable.removeCallback(func);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers for this mesh a javascript function called just after the rendering is complete\r\n     * @param func defines the function to call after rendering this mesh\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.registerAfterRender = function (func) {\r\n        this.onAfterRenderObservable.add(func);\r\n        return this;\r\n    };\r\n    /**\r\n     * Disposes a previously registered javascript function called after the rendering.\r\n     * @param func defines the function to remove\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.unregisterAfterRender = function (func) {\r\n        this.onAfterRenderObservable.removeCallback(func);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._getInstancesRenderList = function (subMeshId, isReplacementMode) {\r\n        if (isReplacementMode === void 0) { isReplacementMode = false; }\r\n        if (this._instanceDataStorage.isFrozen && this._instanceDataStorage.previousBatch) {\r\n            return this._instanceDataStorage.previousBatch;\r\n        }\r\n        var scene = this.getScene();\r\n        var isInIntermediateRendering = scene._isInIntermediateRendering();\r\n        var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;\r\n        var batchCache = this._instanceDataStorage.batchCache;\r\n        batchCache.mustReturn = false;\r\n        batchCache.renderSelf[subMeshId] = isReplacementMode || (!onlyForInstances && this.isEnabled() && this.isVisible);\r\n        batchCache.visibleInstances[subMeshId] = null;\r\n        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\r\n            var visibleInstances = this._instanceDataStorage.visibleInstances;\r\n            var currentRenderId = scene.getRenderId();\r\n            var defaultRenderId = (isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId);\r\n            batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\r\n            if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\r\n                batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\r\n            }\r\n        }\r\n        batchCache.hardwareInstancedRendering[subMeshId] =\r\n            !isReplacementMode &&\r\n                this._instanceDataStorage.hardwareInstancedRendering\r\n                && (batchCache.visibleInstances[subMeshId] !== null)\r\n                && (batchCache.visibleInstances[subMeshId] !== undefined);\r\n        this._instanceDataStorage.previousBatch = batchCache;\r\n        return batchCache;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._renderWithInstances = function (subMesh, fillMode, batch, effect, engine) {\r\n        var visibleInstances = batch.visibleInstances[subMesh._id];\r\n        if (!visibleInstances) {\r\n            return this;\r\n        }\r\n        var instanceStorage = this._instanceDataStorage;\r\n        var currentInstancesBufferSize = instanceStorage.instancesBufferSize;\r\n        var instancesBuffer = instanceStorage.instancesBuffer;\r\n        var matricesCount = visibleInstances.length + 1;\r\n        var bufferSize = matricesCount * 16 * 4;\r\n        while (instanceStorage.instancesBufferSize < bufferSize) {\r\n            instanceStorage.instancesBufferSize *= 2;\r\n        }\r\n        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\r\n            instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\r\n        }\r\n        var offset = 0;\r\n        var instancesCount = 0;\r\n        var renderSelf = batch.renderSelf[subMesh._id];\r\n        var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize;\r\n        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\r\n            var world = this._effectiveMesh.getWorldMatrix();\r\n            if (renderSelf) {\r\n                world.copyToArray(instanceStorage.instancesData, offset);\r\n                offset += 16;\r\n                instancesCount++;\r\n            }\r\n            if (visibleInstances) {\r\n                for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\r\n                    var instance = visibleInstances[instanceIndex];\r\n                    instance.getWorldMatrix().copyToArray(instanceStorage.instancesData, offset);\r\n                    offset += 16;\r\n                    instancesCount++;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;\r\n        }\r\n        if (needUpdateBuffer) {\r\n            if (instancesBuffer) {\r\n                instancesBuffer.dispose();\r\n            }\r\n            instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\r\n            instanceStorage.instancesBuffer = instancesBuffer;\r\n            this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world0\", 0, 4));\r\n            this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world1\", 4, 4));\r\n            this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world2\", 8, 4));\r\n            this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world3\", 12, 4));\r\n        }\r\n        else {\r\n            if (!this._instanceDataStorage.isFrozen) {\r\n                instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\r\n            }\r\n        }\r\n        this._processInstancedBuffers(visibleInstances, renderSelf);\r\n        // Stats\r\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\r\n        // Draw\r\n        this._bind(subMesh, effect, fillMode);\r\n        this._draw(subMesh, fillMode, instancesCount);\r\n        engine.unbindInstanceAttributes();\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._renderWithThinInstances = function (subMesh, fillMode, effect, engine) {\r\n        var _a, _b;\r\n        // Stats\r\n        var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\r\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\r\n        // Draw\r\n        this._bind(subMesh, effect, fillMode);\r\n        this._draw(subMesh, fillMode, instancesCount);\r\n        engine.unbindInstanceAttributes();\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\r\n        // Do nothing\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._processRendering = function (renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\r\n            this._renderWithThinInstances(subMesh, fillMode, effect, engine);\r\n            return this;\r\n        }\r\n        if (hardwareInstancedRendering) {\r\n            this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\r\n        }\r\n        else {\r\n            var instanceCount = 0;\r\n            if (batch.renderSelf[subMesh._id]) {\r\n                // Draw\r\n                if (onBeforeDraw) {\r\n                    onBeforeDraw(false, renderingMesh._effectiveMesh.getWorldMatrix(), effectiveMaterial);\r\n                }\r\n                instanceCount++;\r\n                this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\r\n            }\r\n            var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\r\n            if (visibleInstancesForSubMesh) {\r\n                var visibleInstanceCount = visibleInstancesForSubMesh.length;\r\n                instanceCount += visibleInstanceCount;\r\n                // Stats\r\n                for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\r\n                    var instance = visibleInstancesForSubMesh[instanceIndex];\r\n                    // World\r\n                    var world = instance.getWorldMatrix();\r\n                    if (onBeforeDraw) {\r\n                        onBeforeDraw(true, world, effectiveMaterial);\r\n                    }\r\n                    // Draw\r\n                    this._draw(subMesh, fillMode);\r\n                }\r\n            }\r\n            // Stats\r\n            scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._rebuild = function () {\r\n        if (this._instanceDataStorage.instancesBuffer) {\r\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\r\n            this._instanceDataStorage.instancesBuffer.dispose();\r\n            this._instanceDataStorage.instancesBuffer = null;\r\n        }\r\n        _super.prototype._rebuild.call(this);\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._freeze = function () {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n        // Prepare batches\r\n        for (var index = 0; index < this.subMeshes.length; index++) {\r\n            this._getInstancesRenderList(index);\r\n        }\r\n        this._effectiveMaterial = null;\r\n        this._instanceDataStorage.isFrozen = true;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._unFreeze = function () {\r\n        this._instanceDataStorage.isFrozen = false;\r\n        this._instanceDataStorage.previousBatch = null;\r\n    };\r\n    /**\r\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\r\n     * @param subMesh defines the subMesh to render\r\n     * @param enableAlphaMode defines if alpha mode can be changed\r\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.render = function (subMesh, enableAlphaMode, effectiveMeshReplacement) {\r\n        var scene = this.getScene();\r\n        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n            this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n        }\r\n        else {\r\n            this._internalAbstractMeshDataInfo._isActive = false;\r\n        }\r\n        if (this._checkOcclusionQuery()) {\r\n            return this;\r\n        }\r\n        // Managing instances\r\n        var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\r\n        if (batch.mustReturn) {\r\n            return this;\r\n        }\r\n        // Checking geometry state\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n        if (this._internalMeshDataInfo._onBeforeRenderObservable) {\r\n            this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\r\n        }\r\n        var engine = scene.getEngine();\r\n        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;\r\n        var instanceDataStorage = this._instanceDataStorage;\r\n        var material = subMesh.getMaterial();\r\n        if (!material) {\r\n            return this;\r\n        }\r\n        // Material\r\n        if (!instanceDataStorage.isFrozen || !this._effectiveMaterial || this._effectiveMaterial !== material) {\r\n            if (material._storeEffectOnSubMeshes) {\r\n                if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\r\n                    return this;\r\n                }\r\n            }\r\n            else if (!material.isReady(this, hardwareInstancedRendering)) {\r\n                return this;\r\n            }\r\n            this._effectiveMaterial = material;\r\n        }\r\n        // Alpha mode\r\n        if (enableAlphaMode) {\r\n            engine.setAlphaMode(this._effectiveMaterial.alphaMode);\r\n        }\r\n        var effect;\r\n        if (this._effectiveMaterial._storeEffectOnSubMeshes) {\r\n            effect = subMesh.effect;\r\n        }\r\n        else {\r\n            effect = this._effectiveMaterial.getEffect();\r\n        }\r\n        for (var _i = 0, _a = scene._beforeRenderingMeshStage; _i < _a.length; _i++) {\r\n            var step = _a[_i];\r\n            step.action(this, subMesh, batch, effect);\r\n        }\r\n        if (!effect) {\r\n            return this;\r\n        }\r\n        var effectiveMesh = effectiveMeshReplacement || this._effectiveMesh;\r\n        var sideOrientation;\r\n        if (!instanceDataStorage.isFrozen &&\r\n            (this._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\r\n            var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n            sideOrientation = this.overrideMaterialSideOrientation;\r\n            if (sideOrientation == null) {\r\n                sideOrientation = this._effectiveMaterial.sideOrientation;\r\n            }\r\n            if (mainDeterminant < 0) {\r\n                sideOrientation = (sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation);\r\n            }\r\n            instanceDataStorage.sideOrientation = sideOrientation;\r\n        }\r\n        else {\r\n            sideOrientation = instanceDataStorage.sideOrientation;\r\n        }\r\n        var reverse = this._effectiveMaterial._preBind(effect, sideOrientation);\r\n        if (this._effectiveMaterial.forceDepthWrite) {\r\n            engine.setDepthWrite(true);\r\n        }\r\n        // Bind\r\n        var fillMode = scene.forcePointsCloud ? Material.PointFillMode : (scene.forceWireframe ? Material.WireFrameFillMode : this._effectiveMaterial.fillMode);\r\n        if (this._internalMeshDataInfo._onBeforeBindObservable) {\r\n            this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\r\n        }\r\n        if (!hardwareInstancedRendering) { // Binding will be done later because we need to add more info to the VB\r\n            this._bind(subMesh, effect, fillMode);\r\n        }\r\n        var world = effectiveMesh.getWorldMatrix();\r\n        if (this._effectiveMaterial._storeEffectOnSubMeshes) {\r\n            this._effectiveMaterial.bindForSubMesh(world, this, subMesh);\r\n        }\r\n        else {\r\n            this._effectiveMaterial.bind(world, this);\r\n        }\r\n        if (!this._effectiveMaterial.backFaceCulling && this._effectiveMaterial.separateCullingPass) {\r\n            engine.setState(true, this._effectiveMaterial.zOffset, false, !reverse);\r\n            this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._effectiveMaterial);\r\n            engine.setState(true, this._effectiveMaterial.zOffset, false, reverse);\r\n        }\r\n        // Draw\r\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._effectiveMaterial);\r\n        // Unbind\r\n        this._effectiveMaterial.unbind();\r\n        for (var _b = 0, _c = scene._afterRenderingMeshStage; _b < _c.length; _b++) {\r\n            var step = _c[_b];\r\n            step.action(this, subMesh, batch, effect);\r\n        }\r\n        if (this._internalMeshDataInfo._onAfterRenderObservable) {\r\n            this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\r\n        }\r\n        return this;\r\n    };\r\n    Mesh.prototype._onBeforeDraw = function (isInstance, world, effectiveMaterial) {\r\n        if (isInstance && effectiveMaterial) {\r\n            effectiveMaterial.bindOnlyWorldMatrix(world);\r\n        }\r\n    };\r\n    /**\r\n     *   Renormalize the mesh and patch it up if there are no weights\r\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\r\n     *   However in the case of zero weights then we set just a single influence to 1.\r\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\r\n     */\r\n    Mesh.prototype.cleanMatrixWeights = function () {\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n                this.normalizeSkinWeightsAndExtra();\r\n            }\r\n            else {\r\n                this.normalizeSkinFourWeights();\r\n            }\r\n        }\r\n    };\r\n    // faster 4 weight version.\r\n    Mesh.prototype.normalizeSkinFourWeights = function () {\r\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        var numWeights = matricesWeights.length;\r\n        for (var a = 0; a < numWeights; a += 4) {\r\n            // accumulate weights\r\n            var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                matricesWeights[a] = 1;\r\n            }\r\n            else {\r\n                // renormalize so everything adds to 1 use reciprical\r\n                var recip = 1 / t;\r\n                matricesWeights[a] *= recip;\r\n                matricesWeights[a + 1] *= recip;\r\n                matricesWeights[a + 2] *= recip;\r\n                matricesWeights[a + 3] *= recip;\r\n            }\r\n        }\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\r\n    };\r\n    // handle special case of extra verts.  (in theory gltf can handle 12 influences)\r\n    Mesh.prototype.normalizeSkinWeightsAndExtra = function () {\r\n        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\r\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        var numWeights = matricesWeights.length;\r\n        for (var a = 0; a < numWeights; a += 4) {\r\n            // accumulate weights\r\n            var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\r\n            t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                matricesWeights[a] = 1;\r\n            }\r\n            else {\r\n                // renormalize so everything adds to 1 use reciprical\r\n                var recip = 1 / t;\r\n                matricesWeights[a] *= recip;\r\n                matricesWeights[a + 1] *= recip;\r\n                matricesWeights[a + 2] *= recip;\r\n                matricesWeights[a + 3] *= recip;\r\n                // same goes for extras\r\n                matricesWeightsExtra[a] *= recip;\r\n                matricesWeightsExtra[a + 1] *= recip;\r\n                matricesWeightsExtra[a + 2] *= recip;\r\n                matricesWeightsExtra[a + 3] *= recip;\r\n            }\r\n        }\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\r\n    };\r\n    /**\r\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\r\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\r\n     * the user know there was an issue with importing the mesh\r\n     * @returns a validation object with skinned, valid and report string\r\n     */\r\n    Mesh.prototype.validateSkinning = function () {\r\n        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\r\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        if (matricesWeights === null || this.skeleton == null) {\r\n            return { skinned: false, valid: true, report: \"not skinned\" };\r\n        }\r\n        var numWeights = matricesWeights.length;\r\n        var numberNotSorted = 0;\r\n        var missingWeights = 0;\r\n        var maxUsedWeights = 0;\r\n        var numberNotNormalized = 0;\r\n        var numInfluences = matricesWeightsExtra === null ? 4 : 8;\r\n        var usedWeightCounts = new Array();\r\n        for (var a = 0; a <= numInfluences; a++) {\r\n            usedWeightCounts[a] = 0;\r\n        }\r\n        var toleranceEpsilon = 0.001;\r\n        for (var a = 0; a < numWeights; a += 4) {\r\n            var lastWeight = matricesWeights[a];\r\n            var t = lastWeight;\r\n            var usedWeights = t === 0 ? 0 : 1;\r\n            for (var b = 1; b < numInfluences; b++) {\r\n                var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\r\n                if (d > lastWeight) {\r\n                    numberNotSorted++;\r\n                }\r\n                if (d !== 0) {\r\n                    usedWeights++;\r\n                }\r\n                t += d;\r\n                lastWeight = d;\r\n            }\r\n            // count the buffer weights usage\r\n            usedWeightCounts[usedWeights]++;\r\n            // max influences\r\n            if (usedWeights > maxUsedWeights) {\r\n                maxUsedWeights = usedWeights;\r\n            }\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                missingWeights++;\r\n            }\r\n            else {\r\n                // renormalize so everything adds to 1 use reciprical\r\n                var recip = 1 / t;\r\n                var tolerance = 0;\r\n                for (b = 0; b < numInfluences; b++) {\r\n                    if (b < 4) {\r\n                        tolerance += Math.abs(matricesWeights[a + b] - (matricesWeights[a + b] * recip));\r\n                    }\r\n                    else {\r\n                        tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - (matricesWeightsExtra[a + b - 4] * recip));\r\n                    }\r\n                }\r\n                // arbitary epsilon value for dicdating not normalized\r\n                if (tolerance > toleranceEpsilon) {\r\n                    numberNotNormalized++;\r\n                }\r\n            }\r\n        }\r\n        // validate bone indices are in range of the skeleton\r\n        var numBones = this.skeleton.bones.length;\r\n        var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        var numBadBoneIndices = 0;\r\n        for (var a = 0; a < numWeights; a += 4) {\r\n            for (var b = 0; b < numInfluences; b++) {\r\n                var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\r\n                if (index >= numBones || index < 0) {\r\n                    numBadBoneIndices++;\r\n                }\r\n            }\r\n        }\r\n        // log mesh stats\r\n        var output = \"Number of Weights = \" + numWeights / 4 + \"\\nMaximum influences = \" + maxUsedWeights +\r\n            \"\\nMissing Weights = \" + missingWeights + \"\\nNot Sorted = \" + numberNotSorted +\r\n            \"\\nNot Normalized = \" + numberNotNormalized + \"\\nWeightCounts = [\" + usedWeightCounts + \"]\" +\r\n            \"\\nNumber of bones = \" + numBones + \"\\nBad Bone Indices = \" + numBadBoneIndices;\r\n        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._checkDelayState = function () {\r\n        var scene = this.getScene();\r\n        if (this._geometry) {\r\n            this._geometry.load(scene);\r\n        }\r\n        else if (this.delayLoadState === 4) {\r\n            this.delayLoadState = 2;\r\n            this._queueLoad(scene);\r\n        }\r\n        return this;\r\n    };\r\n    Mesh.prototype._queueLoad = function (scene) {\r\n        var _this = this;\r\n        scene._addPendingData(this);\r\n        var getBinaryData = (this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1);\r\n        Tools.LoadFile(this.delayLoadingFile, function (data) {\r\n            if (data instanceof ArrayBuffer) {\r\n                _this._delayLoadingFunction(data, _this);\r\n            }\r\n            else {\r\n                _this._delayLoadingFunction(JSON.parse(data), _this);\r\n            }\r\n            _this.instances.forEach(function (instance) {\r\n                instance.refreshBoundingInfo();\r\n                instance._syncSubMeshes();\r\n            });\r\n            _this.delayLoadState = 1;\r\n            scene._removePendingData(_this);\r\n        }, function () { }, scene.offlineProvider, getBinaryData);\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    Mesh.prototype.isInFrustum = function (frustumPlanes) {\r\n        if (this.delayLoadState === 2) {\r\n            return false;\r\n        }\r\n        if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {\r\n            return false;\r\n        }\r\n        this._checkDelayState();\r\n        return true;\r\n    };\r\n    /**\r\n     * Sets the mesh material by the material or multiMaterial `id` property\r\n     * @param id is a string identifying the material or the multiMaterial\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.setMaterialByID = function (id) {\r\n        var materials = this.getScene().materials;\r\n        var index;\r\n        for (index = materials.length - 1; index > -1; index--) {\r\n            if (materials[index].id === id) {\r\n                this.material = materials[index];\r\n                return this;\r\n            }\r\n        }\r\n        // Multi\r\n        var multiMaterials = this.getScene().multiMaterials;\r\n        for (index = multiMaterials.length - 1; index > -1; index--) {\r\n            if (multiMaterials[index].id === id) {\r\n                this.material = multiMaterials[index];\r\n                return this;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\r\n     * @returns an array of IAnimatable\r\n     */\r\n    Mesh.prototype.getAnimatables = function () {\r\n        var results = new Array();\r\n        if (this.material) {\r\n            results.push(this.material);\r\n        }\r\n        if (this.skeleton) {\r\n            results.push(this.skeleton);\r\n        }\r\n        return results;\r\n    };\r\n    /**\r\n     * Modifies the mesh geometry according to the passed transformation matrix.\r\n     * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.\r\n     * The mesh normals are modified using the same transformation.\r\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\r\n     * @param transform defines the transform matrix to use\r\n     * @see https://doc.babylonjs.com/resources/baking_transformations\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.bakeTransformIntoVertices = function (transform) {\r\n        // Position\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            return this;\r\n        }\r\n        var submeshes = this.subMeshes.splice(0);\r\n        this._resetPointsArrayCache();\r\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\r\n        var temp = new Array();\r\n        var index;\r\n        for (index = 0; index < data.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);\r\n        }\r\n        this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\r\n        // Normals\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            data = this.getVerticesData(VertexBuffer.NormalKind);\r\n            temp = [];\r\n            for (index = 0; index < data.length; index += 3) {\r\n                Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\r\n        }\r\n        // flip faces?\r\n        if (transform.m[0] * transform.m[5] * transform.m[10] < 0) {\r\n            this.flipFaces();\r\n        }\r\n        // Restore submeshes\r\n        this.releaseSubMeshes();\r\n        this.subMeshes = submeshes;\r\n        return this;\r\n    };\r\n    /**\r\n     * Modifies the mesh geometry according to its own current World Matrix.\r\n     * The mesh World Matrix is then reset.\r\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\r\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\r\n     * @see https://doc.babylonjs.com/resources/baking_transformations\r\n     * @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.bakeCurrentTransformIntoVertices = function (bakeIndependenlyOfChildren) {\r\n        if (bakeIndependenlyOfChildren === void 0) { bakeIndependenlyOfChildren = true; }\r\n        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\r\n        this.resetLocalMatrix(bakeIndependenlyOfChildren);\r\n        return this;\r\n    };\r\n    Object.defineProperty(Mesh.prototype, \"_positions\", {\r\n        // Cache\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._geometry) {\r\n                return this._geometry._positions;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @hidden */\r\n    Mesh.prototype._resetPointsArrayCache = function () {\r\n        if (this._geometry) {\r\n            this._geometry._resetPointsArrayCache();\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._generatePointsArray = function () {\r\n        if (this._geometry) {\r\n            return this._geometry._generatePointsArray();\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Returns a new Mesh object generated from the current mesh properties.\r\n     * This method must not get confused with createInstance()\r\n     * @param name is a string, the name given to the new mesh\r\n     * @param newParent can be any Node object (default `null`)\r\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\r\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\r\n     * @returns a new mesh\r\n     */\r\n    Mesh.prototype.clone = function (name, newParent, doNotCloneChildren, clonePhysicsImpostor) {\r\n        if (name === void 0) { name = \"\"; }\r\n        if (newParent === void 0) { newParent = null; }\r\n        if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\r\n        return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\r\n    };\r\n    /**\r\n     * Releases resources associated with this mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    Mesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\r\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\r\n        this.morphTargetManager = null;\r\n        if (this._geometry) {\r\n            this._geometry.releaseForMesh(this, true);\r\n        }\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        if (internalDataInfo._onBeforeDrawObservable) {\r\n            internalDataInfo._onBeforeDrawObservable.clear();\r\n        }\r\n        if (internalDataInfo._onBeforeBindObservable) {\r\n            internalDataInfo._onBeforeBindObservable.clear();\r\n        }\r\n        if (internalDataInfo._onBeforeRenderObservable) {\r\n            internalDataInfo._onBeforeRenderObservable.clear();\r\n        }\r\n        if (internalDataInfo._onAfterRenderObservable) {\r\n            internalDataInfo._onAfterRenderObservable.clear();\r\n        }\r\n        // Sources\r\n        if (this._scene.useClonedMeshMap) {\r\n            if (internalDataInfo.meshMap) {\r\n                for (var uniqueId in internalDataInfo.meshMap) {\r\n                    var mesh = internalDataInfo.meshMap[uniqueId];\r\n                    if (mesh) {\r\n                        mesh._internalMeshDataInfo._source = null;\r\n                        internalDataInfo.meshMap[uniqueId] = undefined;\r\n                    }\r\n                }\r\n            }\r\n            if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\r\n                internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        }\r\n        else {\r\n            var meshes = this.getScene().meshes;\r\n            for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\r\n                var abstractMesh = meshes_1[_i];\r\n                var mesh = abstractMesh;\r\n                if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\r\n                    mesh._internalMeshDataInfo._source = null;\r\n                }\r\n            }\r\n        }\r\n        internalDataInfo._source = null;\r\n        // Instances\r\n        this._disposeInstanceSpecificData();\r\n        // Thin instances\r\n        this._disposeThinInstanceSpecificData();\r\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._disposeInstanceSpecificData = function () {\r\n        // Do nothing\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._disposeThinInstanceSpecificData = function () {\r\n        // Do nothing\r\n    };\r\n    /**\r\n     * Modifies the mesh geometry according to a displacement map.\r\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\r\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\r\n     * @param url is a string, the URL from the image file is to be downloaded.\r\n     * @param minHeight is the lower limit of the displacement.\r\n     * @param maxHeight is the upper limit of the displacement.\r\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\r\n     * @param uvOffset is an optional vector2 used to offset UV.\r\n     * @param uvScale is an optional vector2 used to scale UV.\r\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\r\n     * @returns the Mesh.\r\n     */\r\n    Mesh.prototype.applyDisplacementMap = function (url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {\r\n        var _this = this;\r\n        if (forceUpdate === void 0) { forceUpdate = false; }\r\n        var scene = this.getScene();\r\n        var onload = function (img) {\r\n            // Getting height map data\r\n            var heightMapWidth = img.width;\r\n            var heightMapHeight = img.height;\r\n            var canvas = CanvasGenerator.CreateCanvas(heightMapWidth, heightMapHeight);\r\n            var context = canvas.getContext(\"2d\");\r\n            context.drawImage(img, 0, 0);\r\n            // Create VertexData from map data\r\n            //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\r\n            _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\r\n            //execute success callback, if set\r\n            if (onSuccess) {\r\n                onSuccess(_this);\r\n            }\r\n        };\r\n        Tools.LoadImage(url, onload, function () { }, scene.offlineProvider);\r\n        return this;\r\n    };\r\n    /**\r\n     * Modifies the mesh geometry according to a displacementMap buffer.\r\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\r\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\r\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\r\n     * @param heightMapWidth is the width of the buffer image.\r\n     * @param heightMapHeight is the height of the buffer image.\r\n     * @param minHeight is the lower limit of the displacement.\r\n     * @param maxHeight is the upper limit of the displacement.\r\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\r\n     * @param uvOffset is an optional vector2 used to offset UV.\r\n     * @param uvScale is an optional vector2 used to scale UV.\r\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\r\n     * @returns the Mesh.\r\n     */\r\n    Mesh.prototype.applyDisplacementMapFromBuffer = function (buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {\r\n        if (forceUpdate === void 0) { forceUpdate = false; }\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)\r\n            || !this.isVerticesDataPresent(VertexBuffer.NormalKind)\r\n            || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\r\n            return this;\r\n        }\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\r\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        var uvs = this.getVerticesData(VertexBuffer.UVKind);\r\n        var position = Vector3.Zero();\r\n        var normal = Vector3.Zero();\r\n        var uv = Vector2.Zero();\r\n        uvOffset = uvOffset || Vector2.Zero();\r\n        uvScale = uvScale || new Vector2(1, 1);\r\n        for (var index = 0; index < positions.length; index += 3) {\r\n            Vector3.FromArrayToRef(positions, index, position);\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector2.FromArrayToRef(uvs, (index / 3) * 2, uv);\r\n            // Compute height\r\n            var u = ((Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1)) % heightMapWidth) | 0;\r\n            var v = ((Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1)) % heightMapHeight) | 0;\r\n            var pos = (u + v * heightMapWidth) * 4;\r\n            var r = buffer[pos] / 255.0;\r\n            var g = buffer[pos + 1] / 255.0;\r\n            var b = buffer[pos + 2] / 255.0;\r\n            var gradient = r * 0.3 + g * 0.59 + b * 0.11;\r\n            normal.normalize();\r\n            normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\r\n            position = position.add(normal);\r\n            position.toArray(positions, index);\r\n        }\r\n        VertexData.ComputeNormals(positions, this.getIndices(), normals);\r\n        if (forceUpdate) {\r\n            this.setVerticesData(VertexBuffer.PositionKind, positions);\r\n            this.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        }\r\n        else {\r\n            this.updateVerticesData(VertexBuffer.PositionKind, positions);\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normals);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Modify the mesh to get a flat shading rendering.\r\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\r\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\r\n     * @returns current mesh\r\n     */\r\n    Mesh.prototype.convertToFlatShadedMesh = function () {\r\n        var kinds = this.getVerticesDataKinds();\r\n        var vbs = {};\r\n        var data = {};\r\n        var newdata = {};\r\n        var updatableNormals = false;\r\n        var kindIndex;\r\n        var kind;\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            var vertexBuffer = this.getVertexBuffer(kind);\r\n            if (kind === VertexBuffer.NormalKind) {\r\n                updatableNormals = vertexBuffer.isUpdatable();\r\n                kinds.splice(kindIndex, 1);\r\n                kindIndex--;\r\n                continue;\r\n            }\r\n            vbs[kind] = vertexBuffer;\r\n            data[kind] = vbs[kind].getData();\r\n            newdata[kind] = [];\r\n        }\r\n        // Save previous submeshes\r\n        var previousSubmeshes = this.subMeshes.slice(0);\r\n        var indices = this.getIndices();\r\n        var totalIndices = this.getTotalIndices();\r\n        // Generating unique vertices per face\r\n        var index;\r\n        for (index = 0; index < totalIndices; index++) {\r\n            var vertexIndex = indices[index];\r\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n                kind = kinds[kindIndex];\r\n                var stride = vbs[kind].getStrideSize();\r\n                for (var offset = 0; offset < stride; offset++) {\r\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\r\n                }\r\n            }\r\n        }\r\n        // Updating faces & normal\r\n        var normals = [];\r\n        var positions = newdata[VertexBuffer.PositionKind];\r\n        for (index = 0; index < totalIndices; index += 3) {\r\n            indices[index] = index;\r\n            indices[index + 1] = index + 1;\r\n            indices[index + 2] = index + 2;\r\n            var p1 = Vector3.FromArray(positions, index * 3);\r\n            var p2 = Vector3.FromArray(positions, (index + 1) * 3);\r\n            var p3 = Vector3.FromArray(positions, (index + 2) * 3);\r\n            var p1p2 = p1.subtract(p2);\r\n            var p3p2 = p3.subtract(p2);\r\n            var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\r\n            // Store same normals for every vertex\r\n            for (var localIndex = 0; localIndex < 3; localIndex++) {\r\n                normals.push(normal.x);\r\n                normals.push(normal.y);\r\n                normals.push(normal.z);\r\n            }\r\n        }\r\n        this.setIndices(indices);\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\r\n        // Updating vertex buffers\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\r\n        }\r\n        // Updating submeshes\r\n        this.releaseSubMeshes();\r\n        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\r\n            var previousOne = previousSubmeshes[submeshIndex];\r\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\r\n        }\r\n        this.synchronizeInstances();\r\n        return this;\r\n    };\r\n    /**\r\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\r\n     * In other words, more vertices, no more indices and a single bigger VBO.\r\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\r\n     * @returns current mesh\r\n     */\r\n    Mesh.prototype.convertToUnIndexedMesh = function () {\r\n        var kinds = this.getVerticesDataKinds();\r\n        var vbs = {};\r\n        var data = {};\r\n        var newdata = {};\r\n        var kindIndex;\r\n        var kind;\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            var vertexBuffer = this.getVertexBuffer(kind);\r\n            vbs[kind] = vertexBuffer;\r\n            data[kind] = vbs[kind].getData();\r\n            newdata[kind] = [];\r\n        }\r\n        // Save previous submeshes\r\n        var previousSubmeshes = this.subMeshes.slice(0);\r\n        var indices = this.getIndices();\r\n        var totalIndices = this.getTotalIndices();\r\n        // Generating unique vertices per face\r\n        var index;\r\n        for (index = 0; index < totalIndices; index++) {\r\n            var vertexIndex = indices[index];\r\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n                kind = kinds[kindIndex];\r\n                var stride = vbs[kind].getStrideSize();\r\n                for (var offset = 0; offset < stride; offset++) {\r\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\r\n                }\r\n            }\r\n        }\r\n        // Updating indices\r\n        for (index = 0; index < totalIndices; index += 3) {\r\n            indices[index] = index;\r\n            indices[index + 1] = index + 1;\r\n            indices[index + 2] = index + 2;\r\n        }\r\n        this.setIndices(indices);\r\n        // Updating vertex buffers\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\r\n        }\r\n        // Updating submeshes\r\n        this.releaseSubMeshes();\r\n        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\r\n            var previousOne = previousSubmeshes[submeshIndex];\r\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\r\n        }\r\n        this._unIndexed = true;\r\n        this.synchronizeInstances();\r\n        return this;\r\n    };\r\n    /**\r\n     * Inverses facet orientations.\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     * @param flipNormals will also inverts the normals\r\n     * @returns current mesh\r\n     */\r\n    Mesh.prototype.flipFaces = function (flipNormals) {\r\n        if (flipNormals === void 0) { flipNormals = false; }\r\n        var vertex_data = VertexData.ExtractFromMesh(this);\r\n        var i;\r\n        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\r\n            for (i = 0; i < vertex_data.normals.length; i++) {\r\n                vertex_data.normals[i] *= -1;\r\n            }\r\n        }\r\n        if (vertex_data.indices) {\r\n            var temp;\r\n            for (i = 0; i < vertex_data.indices.length; i += 3) {\r\n                // reassign indices\r\n                temp = vertex_data.indices[i + 1];\r\n                vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\r\n                vertex_data.indices[i + 2] = temp;\r\n            }\r\n        }\r\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        return this;\r\n    };\r\n    /**\r\n     * Increase the number of facets and hence vertices in a mesh\r\n     * Vertex normals are interpolated from existing vertex normals\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\r\n     */\r\n    Mesh.prototype.increaseVertices = function (numberPerEdge) {\r\n        var vertex_data = VertexData.ExtractFromMesh(this);\r\n        var uvs = vertex_data.uvs;\r\n        var currentIndices = vertex_data.indices;\r\n        var positions = vertex_data.positions;\r\n        var normals = vertex_data.normals;\r\n        if (!currentIndices || !positions || !normals || !uvs) {\r\n            Logger.Warn(\"VertexData contains null entries\");\r\n        }\r\n        else {\r\n            var segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\r\n            var tempIndices = new Array();\r\n            for (var i = 0; i < segments + 1; i++) {\r\n                tempIndices[i] = new Array();\r\n            }\r\n            var a; //vertex index of one end of a side\r\n            var b; //vertex index of other end of the side\r\n            var deltaPosition = new Vector3(0, 0, 0);\r\n            var deltaNormal = new Vector3(0, 0, 0);\r\n            var deltaUV = new Vector2(0, 0);\r\n            var indices = new Array();\r\n            var vertexIndex = new Array();\r\n            var side = new Array();\r\n            var len;\r\n            var positionPtr = positions.length;\r\n            var uvPtr = uvs.length;\r\n            for (var i = 0; i < currentIndices.length; i += 3) {\r\n                vertexIndex[0] = currentIndices[i];\r\n                vertexIndex[1] = currentIndices[i + 1];\r\n                vertexIndex[2] = currentIndices[i + 2];\r\n                for (var j = 0; j < 3; j++) {\r\n                    a = vertexIndex[j];\r\n                    b = vertexIndex[(j + 1) % 3];\r\n                    if (side[a] === undefined && side[b] === undefined) {\r\n                        side[a] = new Array();\r\n                        side[b] = new Array();\r\n                    }\r\n                    else {\r\n                        if (side[a] === undefined) {\r\n                            side[a] = new Array();\r\n                        }\r\n                        if (side[b] === undefined) {\r\n                            side[b] = new Array();\r\n                        }\r\n                    }\r\n                    if (side[a][b] === undefined && side[b][a] === undefined) {\r\n                        side[a][b] = [];\r\n                        deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\r\n                        deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\r\n                        deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\r\n                        deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\r\n                        deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\r\n                        deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\r\n                        deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\r\n                        deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\r\n                        side[a][b].push(a);\r\n                        for (var k = 1; k < segments; k++) {\r\n                            side[a][b].push(positions.length / 3);\r\n                            positions[positionPtr] = positions[3 * a] + k * deltaPosition.x;\r\n                            normals[positionPtr++] = normals[3 * a] + k * deltaNormal.x;\r\n                            positions[positionPtr] = positions[3 * a + 1] + k * deltaPosition.y;\r\n                            normals[positionPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\r\n                            positions[positionPtr] = positions[3 * a + 2] + k * deltaPosition.z;\r\n                            normals[positionPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\r\n                            uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\r\n                            uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\r\n                        }\r\n                        side[a][b].push(b);\r\n                        side[b][a] = new Array();\r\n                        len = side[a][b].length;\r\n                        for (var idx = 0; idx < len; idx++) {\r\n                            side[b][a][idx] = side[a][b][len - 1 - idx];\r\n                        }\r\n                    }\r\n                }\r\n                //Calculate positions, normals and uvs of new internal vertices\r\n                tempIndices[0][0] = currentIndices[i];\r\n                tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\r\n                tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\r\n                for (var k = 2; k < segments; k++) {\r\n                    tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\r\n                    tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\r\n                    deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\r\n                    deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\r\n                    deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\r\n                    deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\r\n                    deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\r\n                    deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\r\n                    deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\r\n                    deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\r\n                    for (var j = 1; j < k; j++) {\r\n                        tempIndices[k][j] = positions.length / 3;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\r\n                        uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\r\n                        uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\r\n                    }\r\n                }\r\n                tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\r\n                // reform indices\r\n                indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\r\n                for (var k = 1; k < segments; k++) {\r\n                    for (var j = 0; j < k; j++) {\r\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\r\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\r\n                    }\r\n                    indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\r\n                }\r\n            }\r\n            vertex_data.indices = indices;\r\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        }\r\n    };\r\n    /**\r\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\r\n     * This will undo any application of covertToFlatShadedMesh\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     */\r\n    Mesh.prototype.forceSharedVertices = function () {\r\n        var vertex_data = VertexData.ExtractFromMesh(this);\r\n        var currentUVs = vertex_data.uvs;\r\n        var currentIndices = vertex_data.indices;\r\n        var currentPositions = vertex_data.positions;\r\n        var currentColors = vertex_data.colors;\r\n        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\r\n            Logger.Warn(\"VertexData contains empty entries\");\r\n        }\r\n        else {\r\n            var positions = new Array();\r\n            var indices = new Array();\r\n            var uvs = new Array();\r\n            var colors = new Array();\r\n            var pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\r\n            var indexPtr = 0; // pointer to next available index value\r\n            var uniquePositions = {}; // unique vertex positions\r\n            var ptr; // pointer to element in uniquePositions\r\n            var facet;\r\n            for (var i = 0; i < currentIndices.length; i += 3) {\r\n                facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\r\n                pstring = new Array();\r\n                for (var j = 0; j < 3; j++) {\r\n                    pstring[j] = \"\";\r\n                    for (var k = 0; k < 3; k++) {\r\n                        //small values make 0\r\n                        if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\r\n                            currentPositions[3 * facet[j] + k] = 0;\r\n                        }\r\n                        pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\r\n                    }\r\n                }\r\n                //check facet vertices to see that none are repeated\r\n                // do not process any facet that has a repeated vertex, ie is a line\r\n                if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\r\n                    //for each facet position check if already listed in uniquePositions\r\n                    // if not listed add to uniquePositions and set index pointer\r\n                    // if listed use its index in uniquePositions and new index pointer\r\n                    for (var j = 0; j < 3; j++) {\r\n                        ptr = uniquePositions[pstring[j]];\r\n                        if (ptr === undefined) {\r\n                            uniquePositions[pstring[j]] = indexPtr;\r\n                            ptr = indexPtr++;\r\n                            //not listed so add individual x, y, z coordinates to positions\r\n                            for (var k = 0; k < 3; k++) {\r\n                                positions.push(currentPositions[3 * facet[j] + k]);\r\n                            }\r\n                            if (currentColors !== null && currentColors !== void 0) {\r\n                                for (var k = 0; k < 4; k++) {\r\n                                    colors.push(currentColors[4 * facet[j] + k]);\r\n                                }\r\n                            }\r\n                            if (currentUVs !== null && currentUVs !== void 0) {\r\n                                for (var k = 0; k < 2; k++) {\r\n                                    uvs.push(currentUVs[2 * facet[j] + k]);\r\n                                }\r\n                            }\r\n                        }\r\n                        // add new index pointer to indices array\r\n                        indices.push(ptr);\r\n                    }\r\n                }\r\n            }\r\n            var normals = new Array();\r\n            VertexData.ComputeNormals(positions, indices, normals);\r\n            //create new vertex data object and update\r\n            vertex_data.positions = positions;\r\n            vertex_data.indices = indices;\r\n            vertex_data.normals = normals;\r\n            if (currentUVs !== null && currentUVs !== void 0) {\r\n                vertex_data.uvs = uvs;\r\n            }\r\n            if (currentColors !== null && currentColors !== void 0) {\r\n                vertex_data.colors = colors;\r\n            }\r\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        }\r\n    };\r\n    // Instances\r\n    /** @hidden */\r\n    Mesh._instancedMeshFactory = function (name, mesh) {\r\n        throw _DevTools.WarnImport(\"InstancedMesh\");\r\n    };\r\n    /** @hidden */\r\n    Mesh._PhysicsImpostorParser = function (scene, physicObject, jsonObject) {\r\n        throw _DevTools.WarnImport(\"PhysicsImpostor\");\r\n    };\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    Mesh.prototype.createInstance = function (name) {\r\n        var geometry = this.geometry;\r\n        if (geometry && geometry.meshes.length > 1) {\r\n            var others = geometry.meshes.slice(0);\r\n            for (var _i = 0, others_1 = others; _i < others_1.length; _i++) {\r\n                var other = others_1[_i];\r\n                if (other === this) {\r\n                    continue;\r\n                }\r\n                other.makeGeometryUnique();\r\n            }\r\n        }\r\n        return Mesh._instancedMeshFactory(name, this);\r\n    };\r\n    /**\r\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\r\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.synchronizeInstances = function () {\r\n        if (this._geometry && this._geometry.meshes.length !== 1 && this.instances.length) {\r\n            this.makeGeometryUnique();\r\n        }\r\n        for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\r\n            var instance = this.instances[instanceIndex];\r\n            instance._syncSubMeshes();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\r\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\r\n     * This should be used together with the simplification to avoid disappearing triangles.\r\n     * @param successCallback an optional success callback to be called after the optimization finished.\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.optimizeIndices = function (successCallback) {\r\n        var _this = this;\r\n        var indices = this.getIndices();\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!positions || !indices) {\r\n            return this;\r\n        }\r\n        var vectorPositions = new Array();\r\n        for (var pos = 0; pos < positions.length; pos = pos + 3) {\r\n            vectorPositions.push(Vector3.FromArray(positions, pos));\r\n        }\r\n        var dupes = new Array();\r\n        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function (iteration) {\r\n            var realPos = vectorPositions.length - 1 - iteration;\r\n            var testedPosition = vectorPositions[realPos];\r\n            for (var j = 0; j < realPos; ++j) {\r\n                var againstPosition = vectorPositions[j];\r\n                if (testedPosition.equals(againstPosition)) {\r\n                    dupes[realPos] = j;\r\n                    break;\r\n                }\r\n            }\r\n        }, function () {\r\n            for (var i = 0; i < indices.length; ++i) {\r\n                indices[i] = dupes[indices[i]] || indices[i];\r\n            }\r\n            //indices are now reordered\r\n            var originalSubMeshes = _this.subMeshes.slice(0);\r\n            _this.setIndices(indices);\r\n            _this.subMeshes = originalSubMeshes;\r\n            if (successCallback) {\r\n                successCallback(_this);\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    Mesh.prototype.serialize = function (serializationObject) {\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.type = this.getClassName();\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.position = this.position.asArray();\r\n        if (this.rotationQuaternion) {\r\n            serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\r\n        }\r\n        else if (this.rotation) {\r\n            serializationObject.rotation = this.rotation.asArray();\r\n        }\r\n        serializationObject.scaling = this.scaling.asArray();\r\n        if (this._postMultiplyPivotMatrix) {\r\n            serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\r\n        }\r\n        else {\r\n            serializationObject.localMatrix = this.getPivotMatrix().asArray();\r\n        }\r\n        serializationObject.isEnabled = this.isEnabled(false);\r\n        serializationObject.isVisible = this.isVisible;\r\n        serializationObject.infiniteDistance = this.infiniteDistance;\r\n        serializationObject.pickable = this.isPickable;\r\n        serializationObject.receiveShadows = this.receiveShadows;\r\n        serializationObject.billboardMode = this.billboardMode;\r\n        serializationObject.visibility = this.visibility;\r\n        serializationObject.checkCollisions = this.checkCollisions;\r\n        serializationObject.isBlocker = this.isBlocker;\r\n        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.id;\r\n        }\r\n        // Geometry\r\n        serializationObject.isUnIndexed = this.isUnIndexed;\r\n        var geometry = this._geometry;\r\n        if (geometry) {\r\n            var geometryId = geometry.id;\r\n            serializationObject.geometryId = geometryId;\r\n            // SubMeshes\r\n            serializationObject.subMeshes = [];\r\n            for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\r\n                var subMesh = this.subMeshes[subIndex];\r\n                serializationObject.subMeshes.push({\r\n                    materialIndex: subMesh.materialIndex,\r\n                    verticesStart: subMesh.verticesStart,\r\n                    verticesCount: subMesh.verticesCount,\r\n                    indexStart: subMesh.indexStart,\r\n                    indexCount: subMesh.indexCount\r\n                });\r\n            }\r\n        }\r\n        // Material\r\n        if (this.material) {\r\n            if (!this.material.doNotSerialize) {\r\n                serializationObject.materialId = this.material.id;\r\n            }\r\n        }\r\n        else {\r\n            this.material = null;\r\n        }\r\n        // Morph targets\r\n        if (this.morphTargetManager) {\r\n            serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\r\n        }\r\n        // Skeleton\r\n        if (this.skeleton) {\r\n            serializationObject.skeletonId = this.skeleton.id;\r\n            serializationObject.numBoneInfluencers = this.numBoneInfluencers;\r\n        }\r\n        // Physics\r\n        //TODO implement correct serialization for physics impostors.\r\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\r\n            var impostor = this.getPhysicsImpostor();\r\n            if (impostor) {\r\n                serializationObject.physicsMass = impostor.getParam(\"mass\");\r\n                serializationObject.physicsFriction = impostor.getParam(\"friction\");\r\n                serializationObject.physicsRestitution = impostor.getParam(\"mass\");\r\n                serializationObject.physicsImpostor = impostor.type;\r\n            }\r\n        }\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n        // Instances\r\n        serializationObject.instances = [];\r\n        for (var index = 0; index < this.instances.length; index++) {\r\n            var instance = this.instances[index];\r\n            if (instance.doNotSerialize) {\r\n                continue;\r\n            }\r\n            var serializationInstance = {\r\n                name: instance.name,\r\n                id: instance.id,\r\n                isEnabled: instance.isEnabled(false),\r\n                isVisible: instance.isVisible,\r\n                isPickable: instance.isPickable,\r\n                checkCollisions: instance.checkCollisions,\r\n                position: instance.position.asArray(),\r\n                scaling: instance.scaling.asArray()\r\n            };\r\n            if (instance.parent) {\r\n                serializationInstance.parentId = instance.parent.id;\r\n            }\r\n            if (instance.rotationQuaternion) {\r\n                serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\r\n            }\r\n            else if (instance.rotation) {\r\n                serializationInstance.rotation = instance.rotation.asArray();\r\n            }\r\n            // Physics\r\n            //TODO implement correct serialization for physics impostors.\r\n            if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\r\n                var impostor = instance.getPhysicsImpostor();\r\n                if (impostor) {\r\n                    serializationInstance.physicsMass = impostor.getParam(\"mass\");\r\n                    serializationInstance.physicsFriction = impostor.getParam(\"friction\");\r\n                    serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\r\n                    serializationInstance.physicsImpostor = impostor.type;\r\n                }\r\n            }\r\n            // Metadata\r\n            if (instance.metadata) {\r\n                serializationInstance.metadata = instance.metadata;\r\n            }\r\n            serializationObject.instances.push(serializationInstance);\r\n            // Animations\r\n            SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\r\n            serializationInstance.ranges = instance.serializeAnimationRanges();\r\n        }\r\n        // Thin instances\r\n        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\r\n            serializationObject.thinInstances = {\r\n                instancesCount: this._thinInstanceDataStorage.instancesCount,\r\n                matrixData: Tools.SliceToArray(this._thinInstanceDataStorage.matrixData),\r\n                matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\r\n            };\r\n            if (this._userThinInstanceBuffersStorage) {\r\n                var userThinInstance = {\r\n                    data: {},\r\n                    sizes: {},\r\n                    strides: {},\r\n                };\r\n                for (var kind in this._userThinInstanceBuffersStorage.data) {\r\n                    userThinInstance.data[kind] = Tools.SliceToArray(this._userThinInstanceBuffersStorage.data[kind]);\r\n                    userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\r\n                    userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\r\n                }\r\n                serializationObject.thinInstances.userThinInstance = userThinInstance;\r\n            }\r\n        }\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n        // Layer mask\r\n        serializationObject.layerMask = this.layerMask;\r\n        // Alpha\r\n        serializationObject.alphaIndex = this.alphaIndex;\r\n        serializationObject.hasVertexAlpha = this.hasVertexAlpha;\r\n        // Overlay\r\n        serializationObject.overlayAlpha = this.overlayAlpha;\r\n        serializationObject.overlayColor = this.overlayColor.asArray();\r\n        serializationObject.renderOverlay = this.renderOverlay;\r\n        // Fog\r\n        serializationObject.applyFog = this.applyFog;\r\n        // Action Manager\r\n        if (this.actionManager) {\r\n            serializationObject.actions = this.actionManager.serialize(this.name);\r\n        }\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype._syncGeometryWithMorphTargetManager = function () {\r\n        if (!this.geometry) {\r\n            return;\r\n        }\r\n        this._markSubMeshesAsAttributesDirty();\r\n        var morphTargetManager = this._internalMeshDataInfo._morphTargetManager;\r\n        if (morphTargetManager && morphTargetManager.vertexCount) {\r\n            if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\r\n                Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\r\n                this.morphTargetManager = null;\r\n                return;\r\n            }\r\n            for (var index = 0; index < morphTargetManager.numInfluencers; index++) {\r\n                var morphTarget = morphTargetManager.getActiveTarget(index);\r\n                var positions = morphTarget.getPositions();\r\n                if (!positions) {\r\n                    Logger.Error(\"Invalid morph target. Target must have positions.\");\r\n                    return;\r\n                }\r\n                this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\r\n                var normals = morphTarget.getNormals();\r\n                if (normals) {\r\n                    this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\r\n                }\r\n                var tangents = morphTarget.getTangents();\r\n                if (tangents) {\r\n                    this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\r\n                }\r\n                var uvs = morphTarget.getUVs();\r\n                if (uvs) {\r\n                    this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var index = 0;\r\n            // Positions\r\n            while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\r\n                this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\r\n                }\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\r\n                }\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a new Mesh object parsed from the source provided.\r\n     * @param parsedMesh is the source\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.Parse = function (parsedMesh, scene, rootUrl) {\r\n        var mesh;\r\n        if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\r\n            mesh = Mesh._GroundMeshParser(parsedMesh, scene);\r\n        }\r\n        else {\r\n            mesh = new Mesh(parsedMesh.name, scene);\r\n        }\r\n        mesh.id = parsedMesh.id;\r\n        if (Tags) {\r\n            Tags.AddTagsTo(mesh, parsedMesh.tags);\r\n        }\r\n        mesh.position = Vector3.FromArray(parsedMesh.position);\r\n        if (parsedMesh.metadata !== undefined) {\r\n            mesh.metadata = parsedMesh.metadata;\r\n        }\r\n        if (parsedMesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\r\n        }\r\n        else if (parsedMesh.rotation) {\r\n            mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\r\n        }\r\n        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\r\n        if (parsedMesh.localMatrix) {\r\n            mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\r\n        }\r\n        else if (parsedMesh.pivotMatrix) {\r\n            mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\r\n        }\r\n        mesh.setEnabled(parsedMesh.isEnabled);\r\n        mesh.isVisible = parsedMesh.isVisible;\r\n        mesh.infiniteDistance = parsedMesh.infiniteDistance;\r\n        mesh.showBoundingBox = parsedMesh.showBoundingBox;\r\n        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\r\n        if (parsedMesh.applyFog !== undefined) {\r\n            mesh.applyFog = parsedMesh.applyFog;\r\n        }\r\n        if (parsedMesh.pickable !== undefined) {\r\n            mesh.isPickable = parsedMesh.pickable;\r\n        }\r\n        if (parsedMesh.alphaIndex !== undefined) {\r\n            mesh.alphaIndex = parsedMesh.alphaIndex;\r\n        }\r\n        mesh.receiveShadows = parsedMesh.receiveShadows;\r\n        mesh.billboardMode = parsedMesh.billboardMode;\r\n        if (parsedMesh.visibility !== undefined) {\r\n            mesh.visibility = parsedMesh.visibility;\r\n        }\r\n        mesh.checkCollisions = parsedMesh.checkCollisions;\r\n        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\r\n        if (parsedMesh.isBlocker !== undefined) {\r\n            mesh.isBlocker = parsedMesh.isBlocker;\r\n        }\r\n        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\r\n        // freezeWorldMatrix\r\n        if (parsedMesh.freezeWorldMatrix) {\r\n            mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\r\n        }\r\n        // Parent\r\n        if (parsedMesh.parentId) {\r\n            mesh._waitingParentId = parsedMesh.parentId;\r\n        }\r\n        // Actions\r\n        if (parsedMesh.actions !== undefined) {\r\n            mesh._waitingData.actions = parsedMesh.actions;\r\n        }\r\n        // Overlay\r\n        if (parsedMesh.overlayAlpha !== undefined) {\r\n            mesh.overlayAlpha = parsedMesh.overlayAlpha;\r\n        }\r\n        if (parsedMesh.overlayColor !== undefined) {\r\n            mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\r\n        }\r\n        if (parsedMesh.renderOverlay !== undefined) {\r\n            mesh.renderOverlay = parsedMesh.renderOverlay;\r\n        }\r\n        // Geometry\r\n        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\r\n        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\r\n        if (parsedMesh.delayLoadingFile) {\r\n            mesh.delayLoadState = 4;\r\n            mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\r\n            mesh._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\r\n            if (parsedMesh._binaryInfo) {\r\n                mesh._binaryInfo = parsedMesh._binaryInfo;\r\n            }\r\n            mesh._delayInfo = [];\r\n            if (parsedMesh.hasUVs) {\r\n                mesh._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n            if (parsedMesh.hasUVs2) {\r\n                mesh._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n            if (parsedMesh.hasUVs3) {\r\n                mesh._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n            if (parsedMesh.hasUVs4) {\r\n                mesh._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n            if (parsedMesh.hasUVs5) {\r\n                mesh._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n            if (parsedMesh.hasUVs6) {\r\n                mesh._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n            if (parsedMesh.hasColors) {\r\n                mesh._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n            if (parsedMesh.hasMatricesIndices) {\r\n                mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n            if (parsedMesh.hasMatricesWeights) {\r\n                mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n            mesh._delayLoadingFunction = Geometry._ImportGeometry;\r\n            if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\r\n                mesh._checkDelayState();\r\n            }\r\n        }\r\n        else {\r\n            Geometry._ImportGeometry(parsedMesh, mesh);\r\n        }\r\n        // Material\r\n        if (parsedMesh.materialId) {\r\n            mesh.setMaterialByID(parsedMesh.materialId);\r\n        }\r\n        else {\r\n            mesh.material = null;\r\n        }\r\n        // Morph targets\r\n        if (parsedMesh.morphTargetManagerId > -1) {\r\n            mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\r\n        }\r\n        // Skeleton\r\n        if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\r\n            mesh.skeleton = scene.getLastSkeletonByID(parsedMesh.skeletonId);\r\n            if (parsedMesh.numBoneInfluencers) {\r\n                mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\r\n            }\r\n        }\r\n        // Animations\r\n        if (parsedMesh.animations) {\r\n            for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\r\n                var parsedAnimation = parsedMesh.animations[animationIndex];\r\n                var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    mesh.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(mesh, parsedMesh, scene);\r\n        }\r\n        if (parsedMesh.autoAnimate) {\r\n            scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\r\n        }\r\n        // Layer Mask\r\n        if (parsedMesh.layerMask && (!isNaN(parsedMesh.layerMask))) {\r\n            mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\r\n        }\r\n        else {\r\n            mesh.layerMask = 0x0FFFFFFF;\r\n        }\r\n        // Physics\r\n        if (parsedMesh.physicsImpostor) {\r\n            Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\r\n        }\r\n        // Levels\r\n        if (parsedMesh.lodMeshIds) {\r\n            mesh._waitingData.lods = {\r\n                ids: parsedMesh.lodMeshIds,\r\n                distances: (parsedMesh.lodDistances) ? parsedMesh.lodDistances : null,\r\n                coverages: (parsedMesh.lodCoverages) ? parsedMesh.lodCoverages : null\r\n            };\r\n        }\r\n        // Instances\r\n        if (parsedMesh.instances) {\r\n            for (var index = 0; index < parsedMesh.instances.length; index++) {\r\n                var parsedInstance = parsedMesh.instances[index];\r\n                var instance = mesh.createInstance(parsedInstance.name);\r\n                if (parsedInstance.id) {\r\n                    instance.id = parsedInstance.id;\r\n                }\r\n                if (Tags) {\r\n                    if (parsedInstance.tags) {\r\n                        Tags.AddTagsTo(instance, parsedInstance.tags);\r\n                    }\r\n                    else {\r\n                        Tags.AddTagsTo(instance, parsedMesh.tags);\r\n                    }\r\n                }\r\n                instance.position = Vector3.FromArray(parsedInstance.position);\r\n                if (parsedInstance.metadata !== undefined) {\r\n                    instance.metadata = parsedInstance.metadata;\r\n                }\r\n                if (parsedInstance.parentId) {\r\n                    instance._waitingParentId = parsedInstance.parentId;\r\n                }\r\n                if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\r\n                    instance.setEnabled(parsedInstance.isEnabled);\r\n                }\r\n                if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\r\n                    instance.isVisible = parsedInstance.isVisible;\r\n                }\r\n                if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\r\n                    instance.isPickable = parsedInstance.isPickable;\r\n                }\r\n                if (parsedInstance.rotationQuaternion) {\r\n                    instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\r\n                }\r\n                else if (parsedInstance.rotation) {\r\n                    instance.rotation = Vector3.FromArray(parsedInstance.rotation);\r\n                }\r\n                instance.scaling = Vector3.FromArray(parsedInstance.scaling);\r\n                if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\r\n                    instance.checkCollisions = parsedInstance.checkCollisions;\r\n                }\r\n                if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\r\n                    instance.isPickable = parsedInstance.pickable;\r\n                }\r\n                if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\r\n                    instance.showBoundingBox = parsedInstance.showBoundingBox;\r\n                }\r\n                if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\r\n                    instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\r\n                }\r\n                if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\r\n                    instance.alphaIndex = parsedInstance.alphaIndex;\r\n                }\r\n                // Physics\r\n                if (parsedInstance.physicsImpostor) {\r\n                    Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\r\n                }\r\n                // Animation\r\n                if (parsedInstance.animations) {\r\n                    for (animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\r\n                        parsedAnimation = parsedInstance.animations[animationIndex];\r\n                        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                        if (internalClass) {\r\n                            instance.animations.push(internalClass.Parse(parsedAnimation));\r\n                        }\r\n                    }\r\n                    Node.ParseAnimationRanges(instance, parsedInstance, scene);\r\n                    if (parsedInstance.autoAnimate) {\r\n                        scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Thin instances\r\n        if (parsedMesh.thinInstances) {\r\n            var thinInstances = parsedMesh.thinInstances;\r\n            if (thinInstances.matrixData) {\r\n                mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\r\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\r\n                mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\r\n            }\r\n            else {\r\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\r\n            }\r\n            if (parsedMesh.thinInstances.userThinInstance) {\r\n                var userThinInstance = parsedMesh.thinInstances.userThinInstance;\r\n                for (var kind in userThinInstance.data) {\r\n                    mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\r\n                    mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\r\n                }\r\n            }\r\n        }\r\n        return mesh;\r\n    };\r\n    /**\r\n     * Creates a ribbon mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @param name defines the name of the mesh to create\r\n     * @param pathArray is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.\r\n     * @param closeArray creates a seam between the first and the last paths of the path array (default is false)\r\n     * @param closePath creates a seam between the first and the last points of each path of the path array\r\n     * @param offset is taken in account only if the `pathArray` is containing a single path\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param instance defines an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#ribbon)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n      * Creates a plane polygonal mesh.  By default, this is a disc. Please consider using the same method from the MeshBuilder class instead\r\n      * @param name defines the name of the mesh to create\r\n      * @param radius sets the radius size (float) of the polygon (default 0.5)\r\n      * @param tessellation sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n      * @param scene defines the hosting scene\r\n      * @param updatable defines if the mesh must be flagged as updatable\r\n      * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n      * @returns a new Mesh\r\n      */\r\n    Mesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\r\n        if (scene === void 0) { scene = null; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a box mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param size sets the size (float) of each box side (default 1)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\r\n        if (scene === void 0) { scene = null; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n      * Creates a sphere mesh. Please consider using the same method from the MeshBuilder class instead\r\n      * @param name defines the name of the mesh to create\r\n      * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)\r\n      * @param diameter sets the diameter size (float) of the sphere (default 1)\r\n      * @param scene defines the hosting scene\r\n      * @param updatable defines if the mesh must be flagged as updatable\r\n      * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n      * @returns a new Mesh\r\n      */\r\n    Mesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n      * Creates a hemisphere mesh. Please consider using the same method from the MeshBuilder class instead\r\n      * @param name defines the name of the mesh to create\r\n      * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)\r\n      * @param diameter sets the diameter size (float) of the sphere (default 1)\r\n      * @param scene defines the hosting scene\r\n      * @returns a new Mesh\r\n      */\r\n    Mesh.CreateHemisphere = function (name, segments, diameter, scene) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a cylinder or a cone mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param height sets the height size (float) of the cylinder/cone (float, default 2)\r\n     * @param diameterTop set the top cap diameter (floats, default 1)\r\n     * @param diameterBottom set the bottom cap diameter (floats, default 1). This value can't be zero\r\n     * @param tessellation sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance\r\n     * @param subdivisions sets the number of rings along the cylinder height (positive integer, default 1)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    // Torus  (Code from SharpDX.org)\r\n    /**\r\n     * Creates a torus mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param diameter sets the diameter size (float) of the torus (default 1)\r\n     * @param thickness sets the diameter size of the tube of the torus (float, default 0.5)\r\n     * @param tessellation sets the number of torus sides (postive integer, default 16)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateTorus = function (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a torus knot mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param radius sets the global radius size (float) of the torus knot (default 2)\r\n     * @param tube sets the diameter size of the tube of the torus (float, default 0.5)\r\n     * @param radialSegments sets the number of sides on each tube segments (positive integer, default 32)\r\n     * @param tubularSegments sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n     * @param p the number of windings on X axis (positive integers, default 2)\r\n     * @param q the number of windings on Y axis (positive integers, default 3)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a line mesh. Please consider using the same method from the MeshBuilder class instead.\r\n     * @param name defines the name of the mesh to create\r\n     * @param points is an array successive Vector3\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines).\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateLines = function (name, points, scene, updatable, instance) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (updatable === void 0) { updatable = false; }\r\n        if (instance === void 0) { instance = null; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a dashed line mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param points is an array successive Vector3\r\n     * @param dashSize is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * @param gapSize is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * @param dashNb is the intended total number of dashes (positive integer, default 200)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\r\n        if (scene === void 0) { scene = null; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a polygon mesh.Please consider using the same method from the MeshBuilder class instead\r\n     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.\r\n     * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.\r\n     * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * Remember you can only change the shape positions, not their number when updating a polygon.\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\r\n     * @param name defines the name of the mesh to create\r\n     * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * @param scene defines the hosting scene\r\n     * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates an extruded polygon mesh, with depth in the Y direction. Please consider using the same method from the MeshBuilder class instead.\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-non-regular-polygon\r\n     * @param name defines the name of the mesh to create\r\n     * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * @param depth defines the height of extrusion\r\n     * @param scene defines the hosting scene\r\n     * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates an extruded shape mesh.\r\n     * The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters. Please consider using the same method from the MeshBuilder class instead\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     * @param name defines the name of the mesh to create\r\n     * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis\r\n     * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along\r\n     * @param scale is the value to scale the shape\r\n     * @param rotation is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve\r\n     * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#extruded-shape)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\r\n        if (scene === void 0) { scene = null; }\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape.\r\n     * It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     * @param name defines the name of the mesh to create\r\n     * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis\r\n     * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along\r\n     * @param scaleFunction is a custom Javascript function called on each path point\r\n     * @param rotationFunction is a custom Javascript function called on each path point\r\n     * @param ribbonCloseArray forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * @param ribbonClosePath forces the extrusion underlying ribbon to close its `pathArray`\r\n     * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates lathe mesh.\r\n     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param shape is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n     * @param radius is the radius value of the lathe\r\n     * @param tessellation is the side number of the lathe.\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a plane mesh. Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param size sets the size (float) of both sides of the plane at once (default 1)\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreatePlane = function (name, size, scene, updatable, sideOrientation) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a ground mesh.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param width set the width of the ground\r\n     * @param height set the height of the ground\r\n     * @param subdivisions sets the number of subdivisions per side\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a tiled ground mesh.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @param name defines the name of the mesh to create\r\n     * @param xmin set the ground minimum X coordinate\r\n     * @param zmin set the ground minimum Y coordinate\r\n     * @param xmax set the ground maximum X coordinate\r\n     * @param zmax set the ground maximum Z coordinate\r\n     * @param subdivisions is an object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * @param precision is an object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a ground mesh from a height map.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @param name defines the name of the mesh to create\r\n     * @param url sets the URL of the height map image resource\r\n     * @param width set the ground width size\r\n     * @param height set the ground height size\r\n     * @param subdivisions sets the number of subdivision per side\r\n     * @param minHeight is the minimum altitude on the ground\r\n     * @param maxHeight is the maximum altitude on the ground\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param onReady  is a callback function that will be called  once the mesh is built (the height map download can last some time)\r\n     * @param alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a tube mesh.\r\n     * The tube is a parametric shape.\r\n     * It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * Please consider using the same method from the MeshBuilder class instead\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @param name defines the name of the mesh to create\r\n     * @param path is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n     * @param radius sets the tube radius size\r\n     * @param tessellation is the number of sides on the tubular surface\r\n     * @param radiusFunction is a custom function. If it is not null, it overwrittes the parameter `radius`. This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path\r\n     * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL\r\n     * @param scene defines the hosting scene\r\n     * @param updatable defines if the mesh must be flagged as updatable\r\n     * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)\r\n     * @param instance is an instance of an existing Tube object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#tube)\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n      * Creates a polyhedron mesh.\r\n      * Please consider using the same method from the MeshBuilder class instead.\r\n      * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n      * * The parameter `size` (positive float, default 1) sets the polygon size\r\n      * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n      * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`\r\n      * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n      * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n      * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n      * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n      * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n      * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n      * @param name defines the name of the mesh to create\r\n      * @param options defines the options used to create the mesh\r\n      * @param scene defines the hosting scene\r\n      * @returns a new Mesh\r\n      */\r\n    Mesh.CreatePolyhedron = function (name, options, scene) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n     * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n     * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)\r\n     * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n     * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n     * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns a new Mesh\r\n     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere\r\n     */\r\n    Mesh.CreateIcoSphere = function (name, options, scene) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /**\r\n     * Creates a decal mesh.\r\n     * Please consider using the same method from the MeshBuilder class instead.\r\n     * A decal is a mesh usually applied as a model onto the surface of another mesh\r\n     * @param name  defines the name of the mesh\r\n     * @param sourceMesh defines the mesh receiving the decal\r\n     * @param position sets the position of the decal in world coordinates\r\n     * @param normal sets the normal of the mesh where the decal is applied onto in world coordinates\r\n     * @param size sets the decal scaling\r\n     * @param angle sets the angle to rotate the decal\r\n     * @returns a new Mesh\r\n     */\r\n    Mesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    /** Creates a Capsule Mesh\r\n     * @param name defines the name of the mesh.\r\n     * @param options the constructors options used to shape the mesh.\r\n     * @param scene defines the scene the mesh is scoped to.\r\n     * @returns the capsule mesh\r\n     * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n     */\r\n    Mesh.CreateCapsule = function (name, options, scene) {\r\n        throw _DevTools.WarnImport(\"MeshBuilder\");\r\n    };\r\n    // Skeletons\r\n    /**\r\n     * Prepare internal position array for software CPU skinning\r\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\r\n     */\r\n    Mesh.prototype.setPositionsForCPUSkinning = function () {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._sourcePositions) {\r\n            var source = this.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!source) {\r\n                return internalDataInfo._sourcePositions;\r\n            }\r\n            internalDataInfo._sourcePositions = new Float32Array(source);\r\n            if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                this.setVerticesData(VertexBuffer.PositionKind, source, true);\r\n            }\r\n        }\r\n        return internalDataInfo._sourcePositions;\r\n    };\r\n    /**\r\n     * Prepare internal normal array for software CPU skinning\r\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\r\n     */\r\n    Mesh.prototype.setNormalsForCPUSkinning = function () {\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._sourceNormals) {\r\n            var source = this.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!source) {\r\n                return internalDataInfo._sourceNormals;\r\n            }\r\n            internalDataInfo._sourceNormals = new Float32Array(source);\r\n            if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                this.setVerticesData(VertexBuffer.NormalKind, source, true);\r\n            }\r\n        }\r\n        return internalDataInfo._sourceNormals;\r\n    };\r\n    /**\r\n     * Updates the vertex buffer by applying transformation from the bones\r\n     * @param skeleton defines the skeleton to apply to current mesh\r\n     * @returns the current mesh\r\n     */\r\n    Mesh.prototype.applySkeleton = function (skeleton) {\r\n        if (!this.geometry) {\r\n            return this;\r\n        }\r\n        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\r\n            return this;\r\n        }\r\n        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            return this;\r\n        }\r\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            return this;\r\n        }\r\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            return this;\r\n        }\r\n        var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n        var internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._sourcePositions) {\r\n            var submeshes = this.subMeshes.slice();\r\n            this.setPositionsForCPUSkinning();\r\n            this.subMeshes = submeshes;\r\n        }\r\n        if (hasNormals && !internalDataInfo._sourceNormals) {\r\n            this.setNormalsForCPUSkinning();\r\n        }\r\n        // positionsData checks for not being Float32Array will only pass at most once\r\n        var positionsData = this.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!positionsData) {\r\n            return this;\r\n        }\r\n        if (!(positionsData instanceof Float32Array)) {\r\n            positionsData = new Float32Array(positionsData);\r\n        }\r\n        // normalsData checks for not being Float32Array will only pass at most once\r\n        var normalsData = this.getVerticesData(VertexBuffer.NormalKind);\r\n        if (hasNormals) {\r\n            if (!normalsData) {\r\n                return this;\r\n            }\r\n            if (!(normalsData instanceof Float32Array)) {\r\n                normalsData = new Float32Array(normalsData);\r\n            }\r\n        }\r\n        var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        if (!matricesWeightsData || !matricesIndicesData) {\r\n            return this;\r\n        }\r\n        var needExtras = this.numBoneInfluencers > 4;\r\n        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n        var skeletonMatrices = skeleton.getTransformMatrices(this);\r\n        var tempVector3 = Vector3.Zero();\r\n        var finalMatrix = new Matrix();\r\n        var tempMatrix = new Matrix();\r\n        var matWeightIdx = 0;\r\n        var inf;\r\n        for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\r\n            var weight;\r\n            for (inf = 0; inf < 4; inf++) {\r\n                weight = matricesWeightsData[matWeightIdx + inf];\r\n                if (weight > 0) {\r\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                    finalMatrix.addToSelf(tempMatrix);\r\n                }\r\n            }\r\n            if (needExtras) {\r\n                for (inf = 0; inf < 4; inf++) {\r\n                    weight = matricesWeightsExtraData[matWeightIdx + inf];\r\n                    if (weight > 0) {\r\n                        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                        finalMatrix.addToSelf(tempMatrix);\r\n                    }\r\n                }\r\n            }\r\n            Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\r\n            tempVector3.toArray(positionsData, index);\r\n            if (hasNormals) {\r\n                Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\r\n                tempVector3.toArray(normalsData, index);\r\n            }\r\n            finalMatrix.reset();\r\n        }\r\n        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\r\n        if (hasNormals) {\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\r\n        }\r\n        return this;\r\n    };\r\n    // Tools\r\n    /**\r\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\r\n     * @param meshes defines the list of meshes to scan\r\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\r\n     */\r\n    Mesh.MinMax = function (meshes) {\r\n        var minVector = null;\r\n        var maxVector = null;\r\n        meshes.forEach(function (mesh) {\r\n            var boundingInfo = mesh.getBoundingInfo();\r\n            var boundingBox = boundingInfo.boundingBox;\r\n            if (!minVector || !maxVector) {\r\n                minVector = boundingBox.minimumWorld;\r\n                maxVector = boundingBox.maximumWorld;\r\n            }\r\n            else {\r\n                minVector.minimizeInPlace(boundingBox.minimumWorld);\r\n                maxVector.maximizeInPlace(boundingBox.maximumWorld);\r\n            }\r\n        });\r\n        if (!minVector || !maxVector) {\r\n            return {\r\n                min: Vector3.Zero(),\r\n                max: Vector3.Zero()\r\n            };\r\n        }\r\n        return {\r\n            min: minVector,\r\n            max: maxVector\r\n        };\r\n    };\r\n    /**\r\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\r\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\r\n     * @returns a vector3\r\n     */\r\n    Mesh.Center = function (meshesOrMinMaxVector) {\r\n        var minMaxVector = (meshesOrMinMaxVector instanceof Array) ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\r\n        return Vector3.Center(minMaxVector.min, minMaxVector.max);\r\n    };\r\n    /**\r\n     * Merge the array of meshes into a single mesh for performance reasons.\r\n     * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty\r\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes\r\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true\r\n     * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\r\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.\r\n     * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.\r\n     * @returns a new mesh\r\n     */\r\n    Mesh.MergeMeshes = function (meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {\r\n        if (disposeSource === void 0) { disposeSource = true; }\r\n        var index;\r\n        if (!allow32BitsIndices) {\r\n            var totalVertices = 0;\r\n            // Counting vertices\r\n            for (index = 0; index < meshes.length; index++) {\r\n                if (meshes[index]) {\r\n                    totalVertices += meshes[index].getTotalVertices();\r\n                    if (totalVertices >= 65536) {\r\n                        Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (multiMultiMaterials) {\r\n            var newMultiMaterial = null;\r\n            var subIndex;\r\n            var matIndex;\r\n            subdivideWithSubMeshes = false;\r\n        }\r\n        var materialArray = new Array();\r\n        var materialIndexArray = new Array();\r\n        // Merge\r\n        var vertexData = null;\r\n        var otherVertexData;\r\n        var indiceArray = new Array();\r\n        var source = null;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                var mesh = meshes[index];\r\n                if (mesh.isAnInstance) {\r\n                    Logger.Warn(\"Cannot merge instance meshes.\");\r\n                    return null;\r\n                }\r\n                var wm = mesh.computeWorldMatrix(true);\r\n                otherVertexData = VertexData.ExtractFromMesh(mesh, true, true);\r\n                otherVertexData.transform(wm);\r\n                if (vertexData) {\r\n                    vertexData.merge(otherVertexData, allow32BitsIndices);\r\n                }\r\n                else {\r\n                    vertexData = otherVertexData;\r\n                    source = mesh;\r\n                }\r\n                if (subdivideWithSubMeshes) {\r\n                    indiceArray.push(mesh.getTotalIndices());\r\n                }\r\n                if (multiMultiMaterials) {\r\n                    if (mesh.material) {\r\n                        var material = mesh.material;\r\n                        if (material instanceof MultiMaterial) {\r\n                            for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\r\n                                if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\r\n                                    materialArray.push(material.subMaterials[matIndex]);\r\n                                }\r\n                            }\r\n                            for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                                materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\r\n                                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (materialArray.indexOf(material) < 0) {\r\n                                materialArray.push(material);\r\n                            }\r\n                            for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                                materialIndexArray.push(materialArray.indexOf(material));\r\n                                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                            materialIndexArray.push(0);\r\n                            indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        source = source;\r\n        if (!meshSubclass) {\r\n            meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\r\n        }\r\n        vertexData.applyToMesh(meshSubclass);\r\n        // Setting properties\r\n        meshSubclass.checkCollisions = source.checkCollisions;\r\n        meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\r\n        // Cleaning\r\n        if (disposeSource) {\r\n            for (index = 0; index < meshes.length; index++) {\r\n                if (meshes[index]) {\r\n                    meshes[index].dispose();\r\n                }\r\n            }\r\n        }\r\n        // Subdivide\r\n        if (subdivideWithSubMeshes || multiMultiMaterials) {\r\n            //-- removal of global submesh\r\n            meshSubclass.releaseSubMeshes();\r\n            index = 0;\r\n            var offset = 0;\r\n            //-- apply subdivision according to index table\r\n            while (index < indiceArray.length) {\r\n                SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass);\r\n                offset += indiceArray[index];\r\n                index++;\r\n            }\r\n        }\r\n        if (multiMultiMaterials) {\r\n            newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\r\n            newMultiMaterial.subMaterials = materialArray;\r\n            for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\r\n                meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\r\n            }\r\n            meshSubclass.material = newMultiMaterial;\r\n        }\r\n        else {\r\n            meshSubclass.material = source.material;\r\n        }\r\n        return meshSubclass;\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype.addInstance = function (instance) {\r\n        instance._indexInSourceMeshInstanceArray = this.instances.length;\r\n        this.instances.push(instance);\r\n    };\r\n    /** @hidden */\r\n    Mesh.prototype.removeInstance = function (instance) {\r\n        // Remove from mesh\r\n        var index = instance._indexInSourceMeshInstanceArray;\r\n        if (index != -1) {\r\n            if (index !== this.instances.length - 1) {\r\n                var last = this.instances[this.instances.length - 1];\r\n                this.instances[index] = last;\r\n                last._indexInSourceMeshInstanceArray = index;\r\n            }\r\n            instance._indexInSourceMeshInstanceArray = -1;\r\n            this.instances.pop();\r\n        }\r\n    };\r\n    // Consts\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    Mesh.FRONTSIDE = VertexData.FRONTSIDE;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    Mesh.BACKSIDE = VertexData.BACKSIDE;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    Mesh.DOUBLESIDE = VertexData.DOUBLESIDE;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    Mesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\r\n    /**\r\n     * Mesh cap setting : no cap\r\n     */\r\n    Mesh.NO_CAP = 0;\r\n    /**\r\n     * Mesh cap setting : one cap at the beginning of the mesh\r\n     */\r\n    Mesh.CAP_START = 1;\r\n    /**\r\n     * Mesh cap setting : one cap at the end of the mesh\r\n     */\r\n    Mesh.CAP_END = 2;\r\n    /**\r\n     * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\r\n     */\r\n    Mesh.CAP_ALL = 3;\r\n    /**\r\n     * Mesh pattern setting : no flip or rotate\r\n     */\r\n    Mesh.NO_FLIP = 0;\r\n    /**\r\n     * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\r\n     */\r\n    Mesh.FLIP_TILE = 1;\r\n    /**\r\n     * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\r\n     */\r\n    Mesh.ROTATE_TILE = 2;\r\n    /**\r\n     * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\r\n     */\r\n    Mesh.FLIP_ROW = 3;\r\n    /**\r\n     * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\r\n     */\r\n    Mesh.ROTATE_ROW = 4;\r\n    /**\r\n     * Mesh pattern setting : flip and rotate alternate tiles on each row or column\r\n     */\r\n    Mesh.FLIP_N_ROTATE_TILE = 5;\r\n    /**\r\n     * Mesh pattern setting : rotate pattern and rotate\r\n     */\r\n    Mesh.FLIP_N_ROTATE_ROW = 6;\r\n    /**\r\n     * Mesh tile positioning : part tiles same on left/right or top/bottom\r\n     */\r\n    Mesh.CENTER = 0;\r\n    /**\r\n     * Mesh tile positioning : part tiles on left\r\n     */\r\n    Mesh.LEFT = 1;\r\n    /**\r\n     * Mesh tile positioning : part tiles on right\r\n     */\r\n    Mesh.RIGHT = 2;\r\n    /**\r\n     * Mesh tile positioning : part tiles on top\r\n     */\r\n    Mesh.TOP = 3;\r\n    /**\r\n     * Mesh tile positioning : part tiles on bottom\r\n     */\r\n    Mesh.BOTTOM = 4;\r\n    // Statics\r\n    /** @hidden */\r\n    Mesh._GroundMeshParser = function (parsedMesh, scene) {\r\n        throw _DevTools.WarnImport(\"GroundMesh\");\r\n    };\r\n    return Mesh;\r\n}(AbstractMesh));\r\nexport { Mesh };\r\n_TypeStore.RegisteredTypes[\"BABYLON.Mesh\"] = Mesh;\r\n//# sourceMappingURL=mesh.js.map","import { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nVertexData.CreateBox = function (options) {\r\n    var nbFaces = 6;\r\n    var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\r\n    var uvs = [];\r\n    var positions = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var depth = options.depth || options.size || 1;\r\n    var wrap = options.wrap || false;\r\n    var topBaseAt = (options.topBaseAt === void 0) ? 1 : options.topBaseAt;\r\n    var bottomBaseAt = (options.bottomBaseAt === void 0) ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    var topOrder = [2, 0, 3, 1];\r\n    var bottomOrder = [2, 0, 1, 3];\r\n    var topIndex = topOrder[topBaseAt];\r\n    var bottomIndex = bottomOrder[bottomBaseAt];\r\n    var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\r\n        var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\r\n        var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\r\n        var topFaceOrder = [17, 18, 19, 16];\r\n        var bottomFaceOrder = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    var scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce(function (accumulator, currentValue, currentIndex) { return accumulator.concat(currentValue * scaleArray[currentIndex % 3]); }, []);\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var faceUV = options.faceUV || new Array(6);\r\n    var faceColors = options.faceColors;\r\n    var colors = [];\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    // Create each face in turn.\r\n    for (var index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].y);\r\n        uvs.push(faceUV[index].z, faceUV[index].y);\r\n        if (faceColors) {\r\n            for (var c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n    return vertexData;\r\n};\r\nMesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        size: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return BoxBuilder.CreateBox(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar BoxBuilder = /** @class */ (function () {\r\n    function BoxBuilder() {\r\n    }\r\n    /**\r\n     * Creates a box mesh\r\n     * * The parameter `size` sets the size (float) of each box side (default 1)\r\n     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    BoxBuilder.CreateBox = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var box = new Mesh(name, scene);\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        box._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreateBox(options);\r\n        vertexData.applyToMesh(box, options.updatable);\r\n        return box;\r\n    };\r\n    return BoxBuilder;\r\n}());\r\nexport { BoxBuilder };\r\n//# sourceMappingURL=boxBuilder.js.map","import { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nVertexData.CreatePlane = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    // Vertices\r\n    var halfWidth = width / 2.0;\r\n    var halfHeight = height / 2.0;\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 0.0);\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 0.0);\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 1.0);\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 1.0);\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\nMesh.CreatePlane = function (name, size, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        size: size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return PlaneBuilder.CreatePlane(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar PlaneBuilder = /** @class */ (function () {\r\n    function PlaneBuilder() {\r\n    }\r\n    /**\r\n     * Creates a plane mesh\r\n     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n     */\r\n    PlaneBuilder.CreatePlane = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var plane = new Mesh(name, scene);\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        plane._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreatePlane(options);\r\n        vertexData.applyToMesh(plane, options.updatable);\r\n        if (options.sourcePlane) {\r\n            plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n            plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n        }\r\n        return plane;\r\n    };\r\n    return PlaneBuilder;\r\n}());\r\nexport { PlaneBuilder };\r\n//# sourceMappingURL=planeBuilder.js.map","import { Matrix } from \"../Maths/math.vector\";\r\n/**\r\n * Configuration needed for prepass-capable materials\r\n */\r\nvar PrePassConfiguration = /** @class */ (function () {\r\n    function PrePassConfiguration() {\r\n        /**\r\n         * Previous world matrices of meshes carrying this material\r\n         * Used for computing velocity\r\n         */\r\n        this.previousWorldMatrices = {};\r\n        /**\r\n         * Previous bones of meshes carrying this material\r\n         * Used for computing velocity\r\n         */\r\n        this.previousBones = {};\r\n    }\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    PrePassConfiguration.AddUniforms = function (uniforms) {\r\n        uniforms.push(\"previousWorld\", \"previousViewProjection\");\r\n    };\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    PrePassConfiguration.AddSamplers = function (samplers) {\r\n        // pass\r\n    };\r\n    /**\r\n     * Binds the material data.\r\n     * @param effect defines the effect to update\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param mesh The mesh\r\n     * @param world World matrix of this mesh\r\n     * @param isFrozen Is the material frozen\r\n     */\r\n    PrePassConfiguration.prototype.bindForSubMesh = function (effect, scene, mesh, world, isFrozen) {\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled) {\r\n            if (scene.prePassRenderer.getIndex(2) !== -1) {\r\n                if (!this.previousWorldMatrices[mesh.uniqueId]) {\r\n                    this.previousWorldMatrices[mesh.uniqueId] = Matrix.Identity();\r\n                }\r\n                if (!this.previousViewProjection) {\r\n                    this.previousViewProjection = scene.getTransformMatrix();\r\n                }\r\n                effect.setMatrix(\"previousWorld\", this.previousWorldMatrices[mesh.uniqueId]);\r\n                effect.setMatrix(\"previousViewProjection\", this.previousViewProjection);\r\n                this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n                this.previousViewProjection = scene.getTransformMatrix().clone();\r\n            }\r\n        }\r\n    };\r\n    return PrePassConfiguration;\r\n}());\r\nexport { PrePassConfiguration };\r\n//# sourceMappingURL=prePassConfiguration.js.map","import { __extends } from \"tslib\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Material } from \"../Materials/material\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\r\nvar PushMaterial = /** @class */ (function (_super) {\r\n    __extends(PushMaterial, _super);\r\n    function PushMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        _this._normalMatrix = new Matrix();\r\n        _this._storeEffectOnSubMeshes = true;\r\n        return _this;\r\n    }\r\n    PushMaterial.prototype.getEffect = function () {\r\n        return this._activeEffect;\r\n    };\r\n    PushMaterial.prototype.isReady = function (mesh, useInstances) {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    };\r\n    PushMaterial.prototype._isReadyForSubMesh = function (subMesh) {\r\n        var defines = subMesh._materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n    * Binds the given world matrix to the active effect\r\n    *\r\n    * @param world the matrix to bind\r\n    */\r\n    PushMaterial.prototype.bindOnlyWorldMatrix = function (world) {\r\n        this._activeEffect.setMatrix(\"world\", world);\r\n    };\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    PushMaterial.prototype.bindOnlyNormalMatrix = function (normalMatrix) {\r\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\r\n    };\r\n    PushMaterial.prototype.bind = function (world, mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    };\r\n    PushMaterial.prototype._afterBind = function (mesh, effect) {\r\n        if (effect === void 0) { effect = null; }\r\n        _super.prototype._afterBind.call(this, mesh);\r\n        this.getScene()._cachedEffect = effect;\r\n    };\r\n    PushMaterial.prototype._mustRebind = function (scene, effect, visibility) {\r\n        if (visibility === void 0) { visibility = 1; }\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    };\r\n    return PushMaterial;\r\n}(Material));\r\nexport { PushMaterial };\r\n//# sourceMappingURL=pushMaterial.js.map","/**\r\n * \"Static Class\" containing a few commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It is complementary with MaterialHelper but provides completely independent functions (for tree shaking sake)\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nvar ThinMaterialHelper = /** @class */ (function () {\r\n    function ThinMaterialHelper() {\r\n    }\r\n    /**\r\n     * Binds the clip plane information from the holder to the effect.\r\n     * @param effect The effect we are binding the data to\r\n     * @param holder The entity containing the clip plane information\r\n     */\r\n    ThinMaterialHelper.BindClipPlane = function (effect, holder) {\r\n        if (holder.clipPlane) {\r\n            var clipPlane = holder.clipPlane;\r\n            effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane2) {\r\n            var clipPlane = holder.clipPlane2;\r\n            effect.setFloat4(\"vClipPlane2\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane3) {\r\n            var clipPlane = holder.clipPlane3;\r\n            effect.setFloat4(\"vClipPlane3\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane4) {\r\n            var clipPlane = holder.clipPlane4;\r\n            effect.setFloat4(\"vClipPlane4\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane5) {\r\n            var clipPlane = holder.clipPlane5;\r\n            effect.setFloat4(\"vClipPlane5\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (holder.clipPlane6) {\r\n            var clipPlane = holder.clipPlane6;\r\n            effect.setFloat4(\"vClipPlane6\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n    };\r\n    return ThinMaterialHelper;\r\n}());\r\nexport { ThinMaterialHelper };\r\n//# sourceMappingURL=thinMaterialHelper.js.map","import { Logger } from \"../Misc/logger\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { ThinMaterialHelper } from './thinMaterialHelper';\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nvar MaterialHelper = /** @class */ (function () {\r\n    function MaterialHelper() {\r\n    }\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param scene The scene the eyes position is used from\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    MaterialHelper.BindEyePosition = function (effect, scene, variableName) {\r\n        if (variableName === void 0) { variableName = \"vEyePosition\"; }\r\n        if (scene._forcedViewPosition) {\r\n            effect.setVector3(variableName, scene._forcedViewPosition);\r\n            return;\r\n        }\r\n        var globalPosition = scene.activeCamera.globalPosition;\r\n        if (!globalPosition) {\r\n            // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\r\n            globalPosition = scene.activeCamera.devicePosition;\r\n        }\r\n        effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\r\n    };\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can accross channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            if (texture.coordinatesIndex === 0) {\r\n                defines[\"MAINUV1\"] = true;\r\n            }\r\n            else {\r\n                defines[\"MAINUV2\"] = true;\r\n            }\r\n        }\r\n        else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Binds a texture matrix value to its corrsponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receivin the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\r\n        var matrix = texture.getTextureMatrix();\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    };\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    MaterialHelper.GetFogState = function (mesh, scene) {\r\n        return (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE);\r\n    };\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    };\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, useClipPlane, useThinInstances) {\r\n        if (useClipPlane === void 0) { useClipPlane = null; }\r\n        if (useThinInstances === void 0) { useThinInstances = false; }\r\n        var changed = false;\r\n        var useClipPlane1 = false;\r\n        var useClipPlane2 = false;\r\n        var useClipPlane3 = false;\r\n        var useClipPlane4 = false;\r\n        var useClipPlane5 = false;\r\n        var useClipPlane6 = false;\r\n        useClipPlane1 = useClipPlane == null ? (scene.clipPlane !== undefined && scene.clipPlane !== null) : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? (scene.clipPlane2 !== undefined && scene.clipPlane2 !== null) : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? (scene.clipPlane3 !== undefined && scene.clipPlane3 !== null) : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? (scene.clipPlane4 !== undefined && scene.clipPlane4 !== null) : useClipPlane;\r\n        useClipPlane5 = useClipPlane == null ? (scene.clipPlane5 !== undefined && scene.clipPlane5 !== null) : useClipPlane;\r\n        useClipPlane6 = useClipPlane == null ? (scene.clipPlane6 !== undefined && scene.clipPlane6 !== null) : useClipPlane;\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\r\n            defines[\"CLIPPLANE5\"] = useClipPlane5;\r\n            changed = true;\r\n        }\r\n        if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\r\n            defines[\"CLIPPLANE6\"] = useClipPlane6;\r\n            changed = true;\r\n        }\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForBones = function (mesh, defines) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n            var materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            }\r\n            else {\r\n                defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n                var prePassRenderer = mesh.getScene().prePassRenderer;\r\n                if (prePassRenderer && prePassRenderer.enabled) {\r\n                    var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                    defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForMorphTargets = function (mesh, defines) {\r\n        var manager = mesh.morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n        }\r\n        else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha) {\r\n        if (useMorphTargets === void 0) { useMorphTargets = false; }\r\n        if (useVertexAlpha === void 0) { useVertexAlpha = true; }\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n        defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n        if (defines._needUVs) {\r\n            defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n            defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\r\n        }\r\n        else {\r\n            defines[\"UV1\"] = false;\r\n            defines[\"UV2\"] = false;\r\n        }\r\n        if (useVertexColor) {\r\n            var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    MaterialHelper.PrepareDefinesForMultiview = function (scene, defines) {\r\n        if (scene.activeCamera) {\r\n            var previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = (scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1);\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    MaterialHelper.PrepareDefinesForPrePass = function (scene, defines, canRenderToMRT) {\r\n        var previousPrePass = defines.PREPASS;\r\n        if (!defines._arePrePassDirty) {\r\n            return;\r\n        }\r\n        var texturesList = [\r\n            {\r\n                type: 1,\r\n                define: \"PREPASS_POSITION\",\r\n                index: \"PREPASS_POSITION_INDEX\",\r\n            },\r\n            {\r\n                type: 2,\r\n                define: \"PREPASS_VELOCITY\",\r\n                index: \"PREPASS_VELOCITY_INDEX\",\r\n            },\r\n            {\r\n                type: 3,\r\n                define: \"PREPASS_REFLECTIVITY\",\r\n                index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n            },\r\n            {\r\n                type: 0,\r\n                define: \"PREPASS_IRRADIANCE\",\r\n                index: \"PREPASS_IRRADIANCE_INDEX\",\r\n            },\r\n            {\r\n                type: 6,\r\n                define: \"PREPASS_ALBEDO\",\r\n                index: \"PREPASS_ALBEDO_INDEX\",\r\n            },\r\n            {\r\n                type: 5,\r\n                define: \"PREPASS_DEPTHNORMAL\",\r\n                index: \"PREPASS_DEPTHNORMAL_INDEX\",\r\n            }\r\n        ];\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n            for (var i = 0; i < texturesList.length; i++) {\r\n                var index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n                if (index !== -1) {\r\n                    defines[texturesList[i].define] = true;\r\n                    defines[texturesList[i].index] = index;\r\n                }\r\n                else {\r\n                    defines[texturesList[i].define] = false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.PREPASS = false;\r\n            for (var i = 0; i < texturesList.length; i++) {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     */\r\n    MaterialHelper.PrepareDefinesForLight = function (scene, mesh, light, lightIndex, defines, specularSupported, state) {\r\n        state.needNormals = true;\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n        switch (light.falloffType) {\r\n            case Light.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            var shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                var shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY);\r\n        }\r\n        else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (disableLighting === void 0) { disableLighting = false; }\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n        var lightIndex = 0;\r\n        var state = {\r\n            needNormals: false,\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false\r\n        };\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {\r\n                var light = _a[_i];\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n        // Resetting all other lights if any\r\n        for (var index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCLOSEESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n        var caps = scene.getEngine().getCaps();\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n        defines[\"SHADOWFLOAT\"] = state.shadowEnabled &&\r\n            ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\r\n                (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n        return state.needNormals;\r\n    };\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    MaterialHelper.PrepareUniformsAndSamplersForLight = function (lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {\r\n        if (uniformBuffersList === void 0) { uniformBuffersList = null; }\r\n        if (updateOnlyBuffersList === void 0) { updateOnlyBuffersList = false; }\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n        if (updateOnlyBuffersList) {\r\n            return;\r\n        }\r\n        uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n        uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n     */\r\n    MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        var uniformsList;\r\n        var uniformBuffersList = null;\r\n        if (uniformsListOrOptions.uniformsNames) {\r\n            var options = uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        }\r\n        else {\r\n            uniformsList = uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n    };\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights, rank) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (rank === void 0) { rank = 0; }\r\n        var lightFallbackRank = 0;\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n                if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    MaterialHelper.PrepareAttributesForMorphTargetsInfluencers = function (attribs, mesh, influencers) {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\r\n        var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            var manager = mesh.morphTargetManager;\r\n            var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            var uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (var index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current efffect fallback strategy\r\n     */\r\n    MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs);\r\n        }\r\n    };\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     */\r\n    MaterialHelper.PushAttributesForInstances = function (attribs) {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n    };\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    };\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    MaterialHelper.BindLight = function (light, lightIndex, scene, effect, useSpecular, rebuildInParallel) {\r\n        if (rebuildInParallel === void 0) { rebuildInParallel = false; }\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\r\n    };\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights, rebuildInParallel) {\r\n        if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\r\n        if (rebuildInParallel === void 0) { rebuildInParallel = false; }\r\n        var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n        for (var i = 0; i < len; i++) {\r\n            var light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\r\n        }\r\n    };\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    MaterialHelper.BindFogParameters = function (scene, mesh, effect, linearSpace) {\r\n        if (linearSpace === void 0) { linearSpace = false; }\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._tempFogColor);\r\n            }\r\n            else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    MaterialHelper.BindBonesParameters = function (mesh, effect, prePassConfiguration) {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            var skeleton = mesh.skeleton;\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                var boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            }\r\n            else {\r\n                var matrices = skeleton.getTransformMatrices(mesh);\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                    if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\r\n                        if (prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                        }\r\n                        MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    MaterialHelper._CopyBonesTransformationMatrices = function (source, target) {\r\n        target.set(source);\r\n        return target;\r\n    };\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\r\n        var manager = abstractMesh.morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    };\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    MaterialHelper.BindLogDepth = function (defines, effect, scene) {\r\n        if (defines[\"LOGARITHMICDEPTH\"]) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n    };\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param scene The scene the clip plane information are extracted from\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    MaterialHelper.BindClipPlane = function (effect, scene) {\r\n        ThinMaterialHelper.BindClipPlane(effect, scene);\r\n    };\r\n    MaterialHelper._TmpMorphInfluencers = { \"NUM_MORPH_INFLUENCERS\": 0 };\r\n    MaterialHelper._tempFogColor = Color3.Black();\r\n    return MaterialHelper;\r\n}());\r\nexport { MaterialHelper };\r\n//# sourceMappingURL=materialHelper.js.map","import { Size } from '../../Maths/math.size';\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nvar ThinTexture = /** @class */ (function () {\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap\r\n     */\r\n    function ThinTexture(internalTexture) {\r\n        this._wrapU = 1;\r\n        this._wrapV = 1;\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        this.wrapR = 1;\r\n        /**\r\n         * With compliant hardware and browser (supporting anisotropic filtering)\r\n         * this defines the level of anisotropic filtering in the texture.\r\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n         */\r\n        this.anisotropicFilteringLevel = 4;\r\n        /**\r\n         * Define the current state of the loading sequence when in delayed load mode.\r\n         */\r\n        this.delayLoadState = 0;\r\n        /** @hidden */\r\n        this._texture = null;\r\n        this._engine = null;\r\n        this._cachedSize = Size.Zero();\r\n        this._cachedBaseSize = Size.Zero();\r\n        this._texture = internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n    Object.defineProperty(ThinTexture.prototype, \"wrapU\", {\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        get: function () {\r\n            return this._wrapU;\r\n        },\r\n        set: function (value) {\r\n            this._wrapU = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"wrapV\", {\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        get: function () {\r\n            return this._wrapV;\r\n        },\r\n        set: function (value) {\r\n            this._wrapV = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"coordinatesMode\", {\r\n        /**\r\n         * How a texture is mapped.\r\n         * Unused in thin texture mode.\r\n         */\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"isCube\", {\r\n        /**\r\n         * Define if the texture is a cube texture or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.isCube;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.isCube = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"is3D\", {\r\n        /**\r\n         * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is3D;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is3D = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ThinTexture.prototype, \"is2DArray\", {\r\n        /**\r\n         * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is2DArray;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is2DArray = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    ThinTexture.prototype.getClassName = function () {\r\n        return \"ThinTexture\";\r\n    };\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    ThinTexture.prototype.isReady = function () {\r\n        if (this.delayLoadState === 4) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    ThinTexture.prototype.delayLoad = function () {\r\n    };\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the insternal texture\r\n     */\r\n    ThinTexture.prototype.getInternalTexture = function () {\r\n        return this._texture;\r\n    };\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    ThinTexture.prototype.getSize = function () {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n        return this._cachedSize;\r\n    };\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    ThinTexture.prototype.getBaseSize = function () {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    };\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    ThinTexture.prototype.updateSamplingMode = function (samplingMode) {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    ThinTexture.prototype.releaseInternalTexture = function () {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    ThinTexture.prototype.dispose = function () {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    };\r\n    return ThinTexture;\r\n}());\r\nexport { ThinTexture };\r\n//# sourceMappingURL=thinTexture.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { GUID } from '../../Misc/guid';\r\nimport \"../../Misc/fileTools\";\r\nimport { ThinTexture } from './thinTexture';\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nvar BaseTexture = /** @class */ (function (_super) {\r\n    __extends(BaseTexture, _super);\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture blongs to\r\n     */\r\n    function BaseTexture(sceneOrEngine) {\r\n        var _this = _super.call(this, null) || this;\r\n        /**\r\n         * Gets or sets an object used to store user defined information.\r\n         */\r\n        _this.metadata = null;\r\n        /**\r\n         * For internal use only. Please do not use.\r\n         */\r\n        _this.reservedDataStore = null;\r\n        _this._hasAlpha = false;\r\n        /**\r\n         * Defines if the alpha value should be determined via the rgb values.\r\n         * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n         */\r\n        _this.getAlphaFromRGB = false;\r\n        /**\r\n         * Intensity or strength of the texture.\r\n         * It is commonly used by materials to fine tune the intensity of the texture\r\n         */\r\n        _this.level = 1;\r\n        /**\r\n         * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n         * This is part of the texture as textures usually maps to one uv set.\r\n         */\r\n        _this.coordinatesIndex = 0;\r\n        _this._coordinatesMode = 0;\r\n        /**\r\n        * | Value | Type               | Description |\r\n        * | ----- | ------------------ | ----------- |\r\n        * | 0     | CLAMP_ADDRESSMODE  |             |\r\n        * | 1     | WRAP_ADDRESSMODE   |             |\r\n        * | 2     | MIRROR_ADDRESSMODE |             |\r\n        */\r\n        _this.wrapR = 1;\r\n        /**\r\n         * With compliant hardware and browser (supporting anisotropic filtering)\r\n         * this defines the level of anisotropic filtering in the texture.\r\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n         */\r\n        _this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n        _this._isCube = false;\r\n        _this._gammaSpace = true;\r\n        /**\r\n         * Is Z inverted in the texture (useful in a cube texture).\r\n         */\r\n        _this.invertZ = false;\r\n        /**\r\n         * @hidden\r\n         */\r\n        _this.lodLevelInAlpha = false;\r\n        /**\r\n         * Define if the texture is a render target.\r\n         */\r\n        _this.isRenderTarget = false;\r\n        /** @hidden */\r\n        _this._prefiltered = false;\r\n        /**\r\n         * Define the list of animation attached to the texture.\r\n         */\r\n        _this.animations = new Array();\r\n        /**\r\n        * An event triggered when the texture is disposed.\r\n        */\r\n        _this.onDisposeObservable = new Observable();\r\n        _this._onDisposeObserver = null;\r\n        _this._scene = null;\r\n        /** @hidden */\r\n        _this._texture = null;\r\n        _this._uid = null;\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._isScene(sceneOrEngine)) {\r\n                _this._scene = sceneOrEngine;\r\n            }\r\n            else {\r\n                _this._engine = sceneOrEngine;\r\n            }\r\n        }\r\n        else {\r\n            _this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n        if (_this._scene) {\r\n            _this.uniqueId = _this._scene.getUniqueId();\r\n            _this._scene.addTexture(_this);\r\n            _this._engine = _this._scene.getEngine();\r\n        }\r\n        _this._uid = null;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\r\n        get: function () {\r\n            return this._hasAlpha;\r\n        },\r\n        /**\r\n         * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n         */\r\n        set: function (value) {\r\n            if (this._hasAlpha === value) {\r\n                return;\r\n            }\r\n            this._hasAlpha = value;\r\n            if (this._scene) {\r\n                this._scene.markAllMaterialsAsDirty(1 | 16);\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\r\n        get: function () {\r\n            return this._coordinatesMode;\r\n        },\r\n        /**\r\n        * How a texture is mapped.\r\n        *\r\n        * | Value | Type                                | Description |\r\n        * | ----- | ----------------------------------- | ----------- |\r\n        * | 0     | EXPLICIT_MODE                       |             |\r\n        * | 1     | SPHERICAL_MODE                      |             |\r\n        * | 2     | PLANAR_MODE                         |             |\r\n        * | 3     | CUBIC_MODE                          |             |\r\n        * | 4     | PROJECTION_MODE                     |             |\r\n        * | 5     | SKYBOX_MODE                         |             |\r\n        * | 6     | INVCUBIC_MODE                       |             |\r\n        * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n        * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n        * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n        */\r\n        set: function (value) {\r\n            if (this._coordinatesMode === value) {\r\n                return;\r\n            }\r\n            this._coordinatesMode = value;\r\n            if (this._scene) {\r\n                this._scene.markAllMaterialsAsDirty(1);\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"wrapU\", {\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        get: function () {\r\n            return this._wrapU;\r\n        },\r\n        set: function (value) {\r\n            this._wrapU = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"wrapV\", {\r\n        /**\r\n         * | Value | Type               | Description |\r\n         * | ----- | ------------------ | ----------- |\r\n         * | 0     | CLAMP_ADDRESSMODE  |             |\r\n         * | 1     | WRAP_ADDRESSMODE   |             |\r\n         * | 2     | MIRROR_ADDRESSMODE |             |\r\n         */\r\n        get: function () {\r\n            return this._wrapV;\r\n        },\r\n        set: function (value) {\r\n            this._wrapV = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isCube\", {\r\n        /**\r\n         * Define if the texture is a cube texture or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._isCube;\r\n            }\r\n            return this._texture.isCube;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                this._isCube = value;\r\n            }\r\n            else {\r\n                this._texture.isCube = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"is3D\", {\r\n        /**\r\n         * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is3D;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is3D = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"is2DArray\", {\r\n        /**\r\n         * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return false;\r\n            }\r\n            return this._texture.is2DArray;\r\n        },\r\n        set: function (value) {\r\n            if (!this._texture) {\r\n                return;\r\n            }\r\n            this._texture.is2DArray = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"gammaSpace\", {\r\n        /**\r\n         * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n         * HDR texture are usually stored in linear space.\r\n         * This only impacts the PBR and Background materials\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._gammaSpace;\r\n            }\r\n            else {\r\n                if (this._texture._gammaSpace === null) {\r\n                    this._texture._gammaSpace = this._gammaSpace;\r\n                }\r\n            }\r\n            return this._texture._gammaSpace;\r\n        },\r\n        set: function (gamma) {\r\n            if (!this._texture) {\r\n                if (this._gammaSpace === gamma) {\r\n                    return;\r\n                }\r\n                this._gammaSpace = gamma;\r\n            }\r\n            else {\r\n                if (this._texture._gammaSpace === gamma) {\r\n                    return;\r\n                }\r\n                this._texture._gammaSpace = gamma;\r\n            }\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isRGBD\", {\r\n        /**\r\n         * Gets or sets whether or not the texture contains RGBD data.\r\n         */\r\n        get: function () {\r\n            return this._texture != null && this._texture._isRGBD;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._isRGBD = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"noMipmap\", {\r\n        /**\r\n         * Are mip maps generated for this texture or not.\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"lodGenerationOffset\", {\r\n        /**\r\n         * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodGenerationOffset;\r\n            }\r\n            return 0.0;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._lodGenerationOffset = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"lodGenerationScale\", {\r\n        /**\r\n         * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodGenerationScale;\r\n            }\r\n            return 0.0;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._lodGenerationScale = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"linearSpecularLOD\", {\r\n        /**\r\n         * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n         * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n         * average roughness values.\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._linearSpecularLOD;\r\n            }\r\n            return false;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._linearSpecularLOD = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"irradianceTexture\", {\r\n        /**\r\n         * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n         * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n         * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n         */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._irradianceTexture;\r\n            }\r\n            return null;\r\n        },\r\n        set: function (value) {\r\n            if (this._texture) {\r\n                this._texture._irradianceTexture = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"uid\", {\r\n        /**\r\n         * Define the unique id of the texture in the scene.\r\n         */\r\n        get: function () {\r\n            if (!this._uid) {\r\n                this._uid = GUID.RandomId();\r\n            }\r\n            return this._uid;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    BaseTexture.prototype.toString = function () {\r\n        return this.name;\r\n    };\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    BaseTexture.prototype.getClassName = function () {\r\n        return \"BaseTexture\";\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\r\n        /**\r\n         * Callback triggered when the texture has been disposed.\r\n         * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n         */\r\n        set: function (callback) {\r\n            if (this._onDisposeObserver) {\r\n                this.onDisposeObservable.remove(this._onDisposeObserver);\r\n            }\r\n            this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\r\n        /**\r\n         * Define if the texture is preventinga material to render or not.\r\n         * If not and the texture is not ready, the engine will use a default black texture instead.\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    BaseTexture.prototype.getScene = function () {\r\n        return this._scene;\r\n    };\r\n    /** @hidden */\r\n    BaseTexture.prototype._getEngine = function () {\r\n        return this._engine;\r\n    };\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    BaseTexture.prototype.checkTransformsAreIdentical = function (texture) {\r\n        return texture !== null;\r\n    };\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for istance.\r\n     * @returns the transformation matrix\r\n     */\r\n    BaseTexture.prototype.getTextureMatrix = function () {\r\n        return Matrix.IdentityReadOnly;\r\n    };\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    BaseTexture.prototype.getReflectionTextureMatrix = function () {\r\n        return Matrix.IdentityReadOnly;\r\n    };\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready or not blocking\r\n     */\r\n    BaseTexture.prototype.isReadyOrNotBlocking = function () {\r\n        return !this.isBlocking || this.isReady();\r\n    };\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    BaseTexture.prototype.scale = function (ratio) {\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\r\n        /**\r\n         * Get if the texture can rescale.\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @hidden */\r\n    BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling, invertY) {\r\n        var engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n        var texturesCache = engine.getLoadedTexturesCache();\r\n        for (var index = 0; index < texturesCache.length; index++) {\r\n            var texturesCacheEntry = texturesCache[index];\r\n            if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                    if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                        texturesCacheEntry.incrementReferences();\r\n                        return texturesCacheEntry;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /** @hidden */\r\n    BaseTexture.prototype._rebuild = function () {\r\n    };\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    BaseTexture.prototype.clone = function () {\r\n        return null;\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"textureType\", {\r\n        /**\r\n         * Get the texture underlying type (INT, FLOAT...)\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return 0;\r\n            }\r\n            return (this._texture.type !== undefined) ? this._texture.type : 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\r\n        /**\r\n         * Get the texture underlying format (RGB, RGBA...)\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return 5;\r\n            }\r\n            return (this._texture.format !== undefined) ? this._texture.format : 5;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    BaseTexture.prototype._markAllSubMeshesAsTexturesDirty = function () {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1);\r\n    };\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @returns The Array buffer containing the pixels data.\r\n     */\r\n    BaseTexture.prototype.readPixels = function (faceIndex, level, buffer) {\r\n        if (faceIndex === void 0) { faceIndex = 0; }\r\n        if (level === void 0) { level = 0; }\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        var engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\r\n            }\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    };\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureHigh;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureMid;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            if (this._texture) {\r\n                return this._texture._lodTextureLow;\r\n            }\r\n            return null;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    BaseTexture.prototype.dispose = function () {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n            // Remove from scene\r\n            this._scene._removePendingData(this);\r\n            var index = this._scene.textures.indexOf(this);\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n        }\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        _super.prototype.dispose.call(this);\r\n    };\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    BaseTexture.prototype.serialize = function () {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    BaseTexture.WhenAllReady = function (textures, callback) {\r\n        var numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n        for (var i = 0; i < textures.length; i++) {\r\n            var texture = textures[i];\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            }\r\n            else {\r\n                var onLoadObservable = texture.onLoadObservable;\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(function () {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    };\r\n    BaseTexture._isScene = function (sceneOrEngine) {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    };\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"uniqueId\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"name\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"metadata\", void 0);\r\n    __decorate([\r\n        serialize(\"hasAlpha\")\r\n    ], BaseTexture.prototype, \"_hasAlpha\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"getAlphaFromRGB\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"level\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"coordinatesIndex\", void 0);\r\n    __decorate([\r\n        serialize(\"coordinatesMode\")\r\n    ], BaseTexture.prototype, \"_coordinatesMode\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapU\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapV\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"wrapR\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"isCube\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"is3D\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"is2DArray\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"gammaSpace\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"invertZ\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodGenerationOffset\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"lodGenerationScale\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"linearSpecularLOD\", null);\r\n    __decorate([\r\n        serializeAsTexture()\r\n    ], BaseTexture.prototype, \"irradianceTexture\", null);\r\n    __decorate([\r\n        serialize()\r\n    ], BaseTexture.prototype, \"isRenderTarget\", void 0);\r\n    return BaseTexture;\r\n}(ThinTexture));\r\nexport { BaseTexture };\r\n//# sourceMappingURL=baseTexture.js.map","/**\r\n * Class used to host copy specific utilities\r\n */\r\nvar CopyTools = /** @class */ (function () {\r\n    function CopyTools() {\r\n    }\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    CopyTools.GenerateBase64StringFromTexture = function (texture, faceIndex, level) {\r\n        if (faceIndex === void 0) { faceIndex = 0; }\r\n        if (level === void 0) { level = 0; }\r\n        var internalTexture = texture.getInternalTexture();\r\n        if (!internalTexture) {\r\n            return null;\r\n        }\r\n        var pixels = texture.readPixels(faceIndex, level);\r\n        if (!pixels) {\r\n            return null;\r\n        }\r\n        var size = texture.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        if (pixels instanceof Float32Array) {\r\n            var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n            var npixels = new Uint8Array(len);\r\n            while (--len >= 0) {\r\n                var val = pixels[len];\r\n                if (val < 0) {\r\n                    val = 0;\r\n                }\r\n                else if (val > 1) {\r\n                    val = 1;\r\n                }\r\n                npixels[len] = val * 255;\r\n            }\r\n            pixels = npixels;\r\n        }\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        var ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            return null;\r\n        }\r\n        var imageData = ctx.createImageData(width, height);\r\n        var castData = imageData.data;\r\n        castData.set(pixels);\r\n        ctx.putImageData(imageData, 0, 0);\r\n        if (internalTexture.invertY) {\r\n            var canvas2 = document.createElement('canvas');\r\n            canvas2.width = width;\r\n            canvas2.height = height;\r\n            var ctx2 = canvas2.getContext('2d');\r\n            if (!ctx2) {\r\n                return null;\r\n            }\r\n            ctx2.translate(0, height);\r\n            ctx2.scale(1, -1);\r\n            ctx2.drawImage(canvas, 0, 0);\r\n            return canvas2.toDataURL('image/png');\r\n        }\r\n        return canvas.toDataURL('image/png');\r\n    };\r\n    return CopyTools;\r\n}());\r\nexport { CopyTools };\r\n//# sourceMappingURL=copyTools.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { _DevTools } from '../../Misc/devTools';\r\nimport { TimingTools } from '../../Misc/timingTools';\r\nimport { InstantiationTools } from '../../Misc/instantiationTools';\r\nimport { Plane } from '../../Maths/math.plane';\r\nimport { StringTools } from '../../Misc/stringTools';\r\nimport { CopyTools } from '../../Misc/copyTools';\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n */\r\nvar Texture = /** @class */ (function (_super) {\r\n    __extends(Texture, _super);\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/babylon101/materials#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmap defines if the texture will require mip maps or not\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     */\r\n    function Texture(url, sceneOrEngine, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions) {\r\n        if (noMipmap === void 0) { noMipmap = false; }\r\n        if (invertY === void 0) { invertY = true; }\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (deleteBuffer === void 0) { deleteBuffer = false; }\r\n        var _this = _super.call(this, sceneOrEngine) || this;\r\n        /**\r\n         * Define the url of the texture.\r\n         */\r\n        _this.url = null;\r\n        /**\r\n         * Define an offset on the texture to offset the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n         */\r\n        _this.uOffset = 0;\r\n        /**\r\n         * Define an offset on the texture to offset the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting\r\n         */\r\n        _this.vOffset = 0;\r\n        /**\r\n         * Define an offset on the texture to scale the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n         */\r\n        _this.uScale = 1.0;\r\n        /**\r\n         * Define an offset on the texture to scale the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials#tiling\r\n         */\r\n        _this.vScale = 1.0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.uAng = 0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.vAng = 0;\r\n        /**\r\n         * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n         * @see https://doc.babylonjs.com/how_to/more_materials\r\n         */\r\n        _this.wAng = 0;\r\n        /**\r\n         * Defines the center of rotation (U)\r\n         */\r\n        _this.uRotationCenter = 0.5;\r\n        /**\r\n         * Defines the center of rotation (V)\r\n         */\r\n        _this.vRotationCenter = 0.5;\r\n        /**\r\n         * Defines the center of rotation (W)\r\n         */\r\n        _this.wRotationCenter = 0.5;\r\n        /**\r\n         * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n         */\r\n        _this.homogeneousRotationInUVTransform = false;\r\n        /**\r\n         * List of inspectable custom properties (used by the Inspector)\r\n         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n         */\r\n        _this.inspectableCustomProperties = null;\r\n        _this._noMipmap = false;\r\n        /** @hidden */\r\n        _this._invertY = false;\r\n        _this._rowGenerationMatrix = null;\r\n        _this._cachedTextureMatrix = null;\r\n        _this._projectionModeMatrix = null;\r\n        _this._t0 = null;\r\n        _this._t1 = null;\r\n        _this._t2 = null;\r\n        _this._cachedUOffset = -1;\r\n        _this._cachedVOffset = -1;\r\n        _this._cachedUScale = 0;\r\n        _this._cachedVScale = 0;\r\n        _this._cachedUAng = -1;\r\n        _this._cachedVAng = -1;\r\n        _this._cachedWAng = -1;\r\n        _this._cachedProjectionMatrixId = -1;\r\n        _this._cachedURotationCenter = -1;\r\n        _this._cachedVRotationCenter = -1;\r\n        _this._cachedWRotationCenter = -1;\r\n        _this._cachedHomogeneousRotationInUVTransform = false;\r\n        _this._cachedCoordinatesMode = -1;\r\n        /** @hidden */\r\n        _this._initialSamplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n        /** @hidden */\r\n        _this._buffer = null;\r\n        _this._deleteBuffer = false;\r\n        _this._format = null;\r\n        _this._delayedOnLoad = null;\r\n        _this._delayedOnError = null;\r\n        /**\r\n         * Observable triggered once the texture has been loaded.\r\n         */\r\n        _this.onLoadObservable = new Observable();\r\n        _this._isBlocking = true;\r\n        _this.name = url || \"\";\r\n        _this.url = url;\r\n        _this._noMipmap = noMipmap;\r\n        _this._invertY = invertY;\r\n        _this._initialSamplingMode = samplingMode;\r\n        _this._buffer = buffer;\r\n        _this._deleteBuffer = deleteBuffer;\r\n        _this._mimeType = mimeType;\r\n        _this._loaderOptions = loaderOptions;\r\n        if (format) {\r\n            _this._format = format;\r\n        }\r\n        var scene = _this.getScene();\r\n        var engine = _this._getEngine();\r\n        if (!engine) {\r\n            return _this;\r\n        }\r\n        engine.onBeforeTextureInitObservable.notifyObservers(_this);\r\n        var load = function () {\r\n            if (_this._texture) {\r\n                if (_this._texture._invertVScale) {\r\n                    _this.vScale *= -1;\r\n                    _this.vOffset += 1;\r\n                }\r\n                // Update texutre to match internal texture's wrapping\r\n                if (_this._texture._cachedWrapU !== null) {\r\n                    _this.wrapU = _this._texture._cachedWrapU;\r\n                    _this._texture._cachedWrapU = null;\r\n                }\r\n                if (_this._texture._cachedWrapV !== null) {\r\n                    _this.wrapV = _this._texture._cachedWrapV;\r\n                    _this._texture._cachedWrapV = null;\r\n                }\r\n                if (_this._texture._cachedWrapR !== null) {\r\n                    _this.wrapR = _this._texture._cachedWrapR;\r\n                    _this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n            if (_this.onLoadObservable.hasObservers()) {\r\n                _this.onLoadObservable.notifyObservers(_this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n            if (!_this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n        if (!_this.url) {\r\n            _this._delayedOnLoad = load;\r\n            _this._delayedOnError = onError;\r\n            return _this;\r\n        }\r\n        _this._texture = _this._getFromCache(_this.url, noMipmap, samplingMode, invertY);\r\n        if (!_this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                _this._texture = engine.createTexture(_this.url, noMipmap, invertY, scene, samplingMode, load, onError, _this._buffer, undefined, _this._format, null, mimeType, loaderOptions);\r\n                if (deleteBuffer) {\r\n                    _this._buffer = null;\r\n                }\r\n            }\r\n            else {\r\n                _this.delayLoadState = 4;\r\n                _this._delayedOnLoad = load;\r\n                _this._delayedOnError = onError;\r\n            }\r\n        }\r\n        else {\r\n            if (_this._texture.isReady) {\r\n                TimingTools.SetImmediate(function () { return load(); });\r\n            }\r\n            else {\r\n                _this._texture.onLoadedObservable.add(load);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Texture.prototype, \"noMipmap\", {\r\n        /**\r\n         * Are mip maps generated for this texture or not.\r\n         */\r\n        get: function () {\r\n            return this._noMipmap;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"mimeType\", {\r\n        /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n        get: function () {\r\n            return this._mimeType;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"isBlocking\", {\r\n        get: function () {\r\n            return this._isBlocking;\r\n        },\r\n        /**\r\n         * Is the texture preventing material to render while loading.\r\n         * If false, a default texture will be used instead of the loading one during the preparation step.\r\n         */\r\n        set: function (value) {\r\n            this._isBlocking = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"samplingMode\", {\r\n        /**\r\n         * Get the current sampling mode associated with the texture.\r\n         */\r\n        get: function () {\r\n            if (!this._texture) {\r\n                return this._initialSamplingMode;\r\n            }\r\n            return this._texture.samplingMode;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Texture.prototype, \"invertY\", {\r\n        /**\r\n         * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n         */\r\n        get: function () {\r\n            return this._invertY;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     */\r\n    Texture.prototype.updateURL = function (url, buffer, onLoad) {\r\n        if (buffer === void 0) { buffer = null; }\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene().markAllMaterialsAsDirty(1);\r\n        }\r\n        if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this.delayLoadState = 4;\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    };\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @hidden\r\n     */\r\n    Texture.prototype.delayLoad = function () {\r\n        if (this.delayLoadState !== 4) {\r\n            return;\r\n        }\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.delayLoadState = 1;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY);\r\n        if (!this._texture) {\r\n            this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions);\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        }\r\n        else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                }\r\n                else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    };\r\n    Texture.prototype._prepareRowForTextureGeneration = function (x, y, z, t) {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    };\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    Texture.prototype.checkTransformsAreIdentical = function (texture) {\r\n        return texture !== null &&\r\n            this.uOffset === texture.uOffset &&\r\n            this.vOffset === texture.vOffset &&\r\n            this.uScale === texture.uScale &&\r\n            this.vScale === texture.vScale &&\r\n            this.uAng === texture.uAng &&\r\n            this.vAng === texture.vAng &&\r\n            this.wAng === texture.wAng;\r\n    };\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    Texture.prototype.getTextureMatrix = function (uBase) {\r\n        var _this = this;\r\n        if (uBase === void 0) { uBase = 1; }\r\n        if (this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        }\r\n        else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);\r\n            this._t1.subtractInPlace(this._t0);\r\n            this._t2.subtractInPlace(this._t0);\r\n            Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0.0, this._t2.x, this._t2.y, this._t2.z, 0.0, this._t0.x, this._t0.y, this._t0.z, 0.0, 0.0, 0.0, 0.0, 1.0, this._cachedTextureMatrix);\r\n        }\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1, function (mat) {\r\n            return mat.hasTexture(_this);\r\n        });\r\n        return this._cachedTextureMatrix;\r\n    };\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    Texture.prototype.getReflectionTextureMatrix = function () {\r\n        var _this = this;\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n        if (this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.coordinatesMode === this._cachedCoordinatesMode) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedTextureMatrix;\r\n                }\r\n            }\r\n            else {\r\n                return this._cachedTextureMatrix;\r\n            }\r\n        }\r\n        if (!this._cachedTextureMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n        }\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedCoordinatesMode = this.coordinatesMode;\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                this._cachedTextureMatrix[0] = this.uScale;\r\n                this._cachedTextureMatrix[5] = this.vScale;\r\n                this._cachedTextureMatrix[12] = this.uOffset;\r\n                this._cachedTextureMatrix[13] = this.vOffset;\r\n                break;\r\n            case Texture.PROJECTION_MODE:\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n                var projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\r\n                break;\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                break;\r\n        }\r\n        scene.markAllMaterialsAsDirty(1, function (mat) {\r\n            return (mat.getActiveTextures().indexOf(_this) !== -1);\r\n        });\r\n        return this._cachedTextureMatrix;\r\n    };\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    Texture.prototype.clone = function () {\r\n        var _this = this;\r\n        return SerializationHelper.Clone(function () {\r\n            return new Texture(_this._texture ? _this._texture.url : null, _this.getScene(), _this._noMipmap, _this._invertY, _this.samplingMode, undefined, undefined, _this._texture ? _this._texture._buffer : undefined);\r\n        }, this);\r\n    };\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    Texture.prototype.serialize = function () {\r\n        var savedName = this.name;\r\n        if (!Texture.SerializeBuffers) {\r\n            if (StringTools.StartsWith(this.name, \"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n        if (StringTools.StartsWith(this.name, \"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n        var serializationObject = _super.prototype.serialize.call(this);\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && this._buffer.substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            }\r\n            else if (this.url && StringTools.StartsWith(this.url, \"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + StringTools.EncodeArrayBufferToBase64(this._buffer);\r\n            }\r\n            else if (Texture.ForceSerializeBuffers) {\r\n                serializationObject.base64String = CopyTools.GenerateBase64StringFromTexture(this);\r\n            }\r\n        }\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        this.name = savedName;\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    Texture.prototype.getClassName = function () {\r\n        return \"Texture\";\r\n    };\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    Texture.prototype.dispose = function () {\r\n        _super.prototype.dispose.call(this);\r\n        this.onLoadObservable.clear();\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    };\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    Texture.Parse = function (parsedTexture, scene, rootUrl) {\r\n        if (parsedTexture.customType) {\r\n            var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            return null;\r\n        }\r\n        var onLoaded = function () {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                var sampling = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    var parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var texture = SerializationHelper.Parse(function () {\r\n            var generateMipMaps = true;\r\n            if (parsedTexture.noMipmap) {\r\n                generateMipMaps = false;\r\n            }\r\n            if (parsedTexture.mirrorPlane) {\r\n                var mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                onLoaded();\r\n                return mirrorTexture;\r\n            }\r\n            else if (parsedTexture.isRenderTarget) {\r\n                var renderTargetTexture = null;\r\n                if (parsedTexture.isCube) {\r\n                    // Search for an existing reflection probe (which contains a cube render target texture)\r\n                    if (scene.reflectionProbes) {\r\n                        for (var index = 0; index < scene.reflectionProbes.length; index++) {\r\n                            var probe = scene.reflectionProbes[index];\r\n                            if (probe.name === parsedTexture.name) {\r\n                                return probe.cubeTexture;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                }\r\n                onLoaded();\r\n                return renderTargetTexture;\r\n            }\r\n            else {\r\n                var texture;\r\n                if (parsedTexture.base64String) {\r\n                    texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, undefined, onLoaded);\r\n                }\r\n                else {\r\n                    var url = void 0;\r\n                    if (parsedTexture.name && parsedTexture.name.indexOf(\"://\") > 0) {\r\n                        url = parsedTexture.name;\r\n                    }\r\n                    else {\r\n                        url = rootUrl + parsedTexture.name;\r\n                    }\r\n                    if (StringTools.StartsWith(parsedTexture.url, \"data:\") || (Texture.UseSerializedUrlIfAny && parsedTexture.url)) {\r\n                        url = parsedTexture.url;\r\n                    }\r\n                    texture = new Texture(url, scene, !generateMipMaps, parsedTexture.invertY, undefined, onLoaded);\r\n                }\r\n                return texture;\r\n            }\r\n        }, parsedTexture, scene);\r\n        return texture;\r\n    };\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    Texture.CreateFromBase64String = function (data, name, scene, noMipmap, invertY, samplingMode, onLoad, onError, format) {\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (format === void 0) { format = 5; }\r\n        return new Texture(\"data:\" + name, scene, noMipmap, invertY, samplingMode, onLoad, onError, data, false, format);\r\n    };\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    Texture.LoadFromDataString = function (name, buffer, scene, deleteBuffer, noMipmap, invertY, samplingMode, onLoad, onError, format) {\r\n        if (deleteBuffer === void 0) { deleteBuffer = false; }\r\n        if (noMipmap === void 0) { noMipmap = false; }\r\n        if (invertY === void 0) { invertY = true; }\r\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\r\n        if (onLoad === void 0) { onLoad = null; }\r\n        if (onError === void 0) { onError = null; }\r\n        if (format === void 0) { format = 5; }\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n        return new Texture(name, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format);\r\n    };\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    Texture.SerializeBuffers = true;\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    Texture.ForceSerializeBuffers = false;\r\n    /** @hidden */\r\n    Texture._CubeTextureParser = function (jsonTexture, scene, rootUrl) {\r\n        throw _DevTools.WarnImport(\"CubeTexture\");\r\n    };\r\n    /** @hidden */\r\n    Texture._CreateMirror = function (name, renderTargetSize, scene, generateMipMaps) {\r\n        throw _DevTools.WarnImport(\"MirrorTexture\");\r\n    };\r\n    /** @hidden */\r\n    Texture._CreateRenderTargetTexture = function (name, renderTargetSize, scene, generateMipMaps) {\r\n        throw _DevTools.WarnImport(\"RenderTargetTexture\");\r\n    };\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    Texture.NEAREST_SAMPLINGMODE = 1;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    Texture.NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    Texture.BILINEAR_SAMPLINGMODE = 2;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    Texture.LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    Texture.TRILINEAR_SAMPLINGMODE = 3;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    Texture.LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    Texture.NEAREST_NEAREST_MIPNEAREST = 4;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    Texture.NEAREST_LINEAR_MIPNEAREST = 5;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    Texture.NEAREST_LINEAR_MIPLINEAR = 6;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    Texture.NEAREST_LINEAR = 7;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    Texture.NEAREST_NEAREST = 1;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    Texture.LINEAR_NEAREST_MIPNEAREST = 9;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    Texture.LINEAR_NEAREST_MIPLINEAR = 10;\r\n    /** mag = linear and min = linear and mip = none */\r\n    Texture.LINEAR_LINEAR = 2;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    Texture.LINEAR_NEAREST = 12;\r\n    /** Explicit coordinates mode */\r\n    Texture.EXPLICIT_MODE = 0;\r\n    /** Spherical coordinates mode */\r\n    Texture.SPHERICAL_MODE = 1;\r\n    /** Planar coordinates mode */\r\n    Texture.PLANAR_MODE = 2;\r\n    /** Cubic coordinates mode */\r\n    Texture.CUBIC_MODE = 3;\r\n    /** Projection coordinates mode */\r\n    Texture.PROJECTION_MODE = 4;\r\n    /** Inverse Cubic coordinates mode */\r\n    Texture.SKYBOX_MODE = 5;\r\n    /** Inverse Cubic coordinates mode */\r\n    Texture.INVCUBIC_MODE = 6;\r\n    /** Equirectangular coordinates mode */\r\n    Texture.EQUIRECTANGULAR_MODE = 7;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    Texture.FIXED_EQUIRECTANGULAR_MODE = 8;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    Texture.CLAMP_ADDRESSMODE = 0;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    Texture.WRAP_ADDRESSMODE = 1;\r\n    /** Texture is repeating and mirrored */\r\n    Texture.MIRROR_ADDRESSMODE = 2;\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    Texture.UseSerializedUrlIfAny = false;\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"url\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uScale\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vScale\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"wAng\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"uRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"vRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"wRotationCenter\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"homogeneousRotationInUVTransform\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], Texture.prototype, \"isBlocking\", null);\r\n    return Texture;\r\n}(BaseTexture));\r\nexport { Texture };\r\n// References the dependencies.\r\n_TypeStore.RegisteredTypes[\"BABYLON.Texture\"] = Texture;\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n//# sourceMappingURL=texture.js.map","import { Engine } from \"../Engines/engine\";\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nvar MaterialFlags = /** @class */ (function () {\r\n    function MaterialFlags() {\r\n    }\r\n    Object.defineProperty(MaterialFlags, \"DiffuseTextureEnabled\", {\r\n        /**\r\n         * Are diffuse textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._DiffuseTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._DiffuseTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._DiffuseTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"DetailTextureEnabled\", {\r\n        /**\r\n         * Are detail textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._DetailTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._DetailTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._DetailTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"AmbientTextureEnabled\", {\r\n        /**\r\n         * Are ambient textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._AmbientTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._AmbientTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._AmbientTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"OpacityTextureEnabled\", {\r\n        /**\r\n         * Are opacity textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._OpacityTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._OpacityTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._OpacityTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ReflectionTextureEnabled\", {\r\n        /**\r\n         * Are reflection textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ReflectionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ReflectionTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ReflectionTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"EmissiveTextureEnabled\", {\r\n        /**\r\n         * Are emissive textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._EmissiveTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._EmissiveTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._EmissiveTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"SpecularTextureEnabled\", {\r\n        /**\r\n         * Are specular textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._SpecularTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._SpecularTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._SpecularTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"BumpTextureEnabled\", {\r\n        /**\r\n         * Are bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._BumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._BumpTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._BumpTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"LightmapTextureEnabled\", {\r\n        /**\r\n         * Are lightmap textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._LightmapTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._LightmapTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._LightmapTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"RefractionTextureEnabled\", {\r\n        /**\r\n         * Are refraction textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._RefractionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._RefractionTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._RefractionTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ColorGradingTextureEnabled\", {\r\n        /**\r\n         * Are color grading textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ColorGradingTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ColorGradingTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ColorGradingTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"FresnelEnabled\", {\r\n        /**\r\n         * Are fresnels enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._FresnelEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._FresnelEnabled === value) {\r\n                return;\r\n            }\r\n            this._FresnelEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(4);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatTextureEnabled\", {\r\n        /**\r\n         * Are clear coat textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatBumpTextureEnabled\", {\r\n        /**\r\n         * Are clear coat bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatBumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatBumpTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatBumpTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ClearCoatTintTextureEnabled\", {\r\n        /**\r\n         * Are clear coat tint textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ClearCoatTintTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ClearCoatTintTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ClearCoatTintTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"SheenTextureEnabled\", {\r\n        /**\r\n         * Are sheen textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._SheenTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._SheenTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._SheenTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"AnisotropicTextureEnabled\", {\r\n        /**\r\n         * Are anisotropic textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._AnisotropicTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._AnisotropicTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._AnisotropicTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaterialFlags, \"ThicknessTextureEnabled\", {\r\n        /**\r\n         * Are thickness textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return this._ThicknessTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            if (this._ThicknessTextureEnabled === value) {\r\n                return;\r\n            }\r\n            this._ThicknessTextureEnabled = value;\r\n            Engine.MarkAllMaterialsAsDirty(1);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    MaterialFlags._DiffuseTextureEnabled = true;\r\n    MaterialFlags._DetailTextureEnabled = true;\r\n    MaterialFlags._AmbientTextureEnabled = true;\r\n    MaterialFlags._OpacityTextureEnabled = true;\r\n    MaterialFlags._ReflectionTextureEnabled = true;\r\n    MaterialFlags._EmissiveTextureEnabled = true;\r\n    MaterialFlags._SpecularTextureEnabled = true;\r\n    MaterialFlags._BumpTextureEnabled = true;\r\n    MaterialFlags._LightmapTextureEnabled = true;\r\n    MaterialFlags._RefractionTextureEnabled = true;\r\n    MaterialFlags._ColorGradingTextureEnabled = true;\r\n    MaterialFlags._FresnelEnabled = true;\r\n    MaterialFlags._ClearCoatTextureEnabled = true;\r\n    MaterialFlags._ClearCoatBumpTextureEnabled = true;\r\n    MaterialFlags._ClearCoatTintTextureEnabled = true;\r\n    MaterialFlags._SheenTextureEnabled = true;\r\n    MaterialFlags._AnisotropicTextureEnabled = true;\r\n    MaterialFlags._ThicknessTextureEnabled = true;\r\n    return MaterialFlags;\r\n}());\r\nexport { MaterialFlags };\r\n//# sourceMappingURL=materialFlags.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultFragmentDeclaration';\r\nvar shader = \"uniform vec4 vDiffuseColor;\\n#ifdef SPECULARTERM\\nuniform vec4 vSpecularColor;\\n#endif\\nuniform vec3 vEmissiveColor;\\nuniform float visibility;\\n\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\n#ifndef REFRACTIONMAP_3D\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nuniform vec4 refractionLeftColor;\\nuniform vec4 refractionRightColor;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nuniform vec4 diffuseLeftColor;\\nuniform vec4 diffuseRightColor;\\n#endif\\n#ifdef OPACITYFRESNEL\\nuniform vec4 opacityParts;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nuniform vec4 emissiveLeftColor;\\nuniform vec4 emissiveRightColor;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifndef REFLECTIONMAP_SKYBOX\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize;\\n#endif\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 reflectionLeftColor;\\nuniform vec4 reflectionRightColor;\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultUboDeclaration';\r\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nvec4 diffuseLeftColor;\\nvec4 diffuseRightColor;\\nvec4 opacityParts;\\nvec4 reflectionLeftColor;\\nvec4 reflectionRightColor;\\nvec4 refractionLeftColor;\\nvec4 refractionRightColor;\\nvec4 emissiveLeftColor;\\nvec4 emissiveRightColor;\\nvec2 vDiffuseInfos;\\nvec2 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vReflectionInfos;\\nvec3 vReflectionPosition;\\nvec3 vReflectionSize;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec2 vSpecularInfos;\\nvec3 vBumpInfos;\\nmat4 diffuseMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 reflectionMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 specularMatrix;\\nmat4 bumpMatrix;\\nvec2 vTangentSpaceParams;\\nfloat pointSize;\\nmat4 refractionMatrix;\\nvec4 vRefractionInfos;\\nvec4 vSpecularColor;\\nvec3 vEmissiveColor;\\nfloat visibility;\\nvec4 vDiffuseColor;\\nvec4 vDetailInfos;\\nmat4 detailMatrix;\\n};\\nuniform Scene {\\nmat4 viewProjection;\\n#ifdef MULTIVIEW\\nmat4 viewProjectionR;\\n#endif\\nmat4 view;\\n};\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultUboDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultUboDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassDeclaration';\r\nvar shader = \"#ifdef PREPASS\\n#extension GL_EXT_draw_buffers : require\\n#ifdef WEBGL2\\nlayout(location=0) out highp vec4 glFragData[{X}];\\nhighp vec4 gl_FragColor;\\n#endif\\n#ifdef PREPASS_DEPTHNORMAL\\nvarying highp vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvarying highp vec4 vCurrentPosition;\\nvarying highp vec4 vPreviousPosition;\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'helperFunctions';\r\nvar shader = \"const float PI=3.1415926535897932384626433832795;\\nconst float HALF_MIN=5.96046448e-08;\\nconst float LinearEncodePowerApprox=2.2;\\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\\nconst float Epsilon=0.0000001;\\n#define saturate(x) clamp(x,0.0,1.0)\\n#define absEps(x) abs(x)+Epsilon\\n#define maxEps(x) max(x,Epsilon)\\n#define saturateEps(x) clamp(x,Epsilon,1.0)\\nmat3 transposeMat3(mat3 inMatrix) {\\nvec3 i0=inMatrix[0];\\nvec3 i1=inMatrix[1];\\nvec3 i2=inMatrix[2];\\nmat3 outMatrix=mat3(\\nvec3(i0.x,i1.x,i2.x),\\nvec3(i0.y,i1.y,i2.y),\\nvec3(i0.z,i1.z,i2.z)\\n);\\nreturn outMatrix;\\n}\\n\\nmat3 inverseMat3(mat3 inMatrix) {\\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\\nfloat b01=a22*a11-a12*a21;\\nfloat b11=-a22*a10+a12*a20;\\nfloat b21=a21*a10-a11*a20;\\nfloat det=a00*b01+a01*b11+a02*b21;\\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\\n}\\nfloat toLinearSpace(float color)\\n{\\nreturn pow(color,LinearEncodePowerApprox);\\n}\\nvec3 toLinearSpace(vec3 color)\\n{\\nreturn pow(color,vec3(LinearEncodePowerApprox));\\n}\\nvec4 toLinearSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\\n}\\nvec3 toGammaSpace(vec3 color)\\n{\\nreturn pow(color,vec3(GammaEncodePowerApprox));\\n}\\nvec4 toGammaSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\\n}\\nfloat toGammaSpace(float color)\\n{\\nreturn pow(color,GammaEncodePowerApprox);\\n}\\nfloat square(float value)\\n{\\nreturn value*value;\\n}\\nfloat pow5(float value) {\\nfloat sq=value*value;\\nreturn sq*sq*value;\\n}\\nfloat getLuminance(vec3 color)\\n{\\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\\n}\\n\\nfloat getRand(vec2 seed) {\\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\\n}\\nfloat dither(vec2 seed,float varianceAmount) {\\nfloat rand=getRand(seed);\\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\\nreturn dither;\\n}\\n\\nconst float rgbdMaxRange=255.0;\\nvec4 toRGBD(vec3 color) {\\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\\nfloat D=max(rgbdMaxRange/maxRGB,1.);\\nD=clamp(floor(D)/255.0,0.,1.);\\n\\nvec3 rgb=color.rgb*D;\\n\\nrgb=toGammaSpace(rgb);\\nreturn vec4(rgb,D);\\n}\\nvec3 fromRGBD(vec4 rgbd) {\\n\\nrgbd.rgb=toLinearSpace(rgbd.rgb);\\n\\nreturn rgbd.rgb/rgbd.a;\\n}\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var helperFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=helperFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightFragmentDeclaration';\r\nvar shader = \"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec4 vLightSpecular{X};\\n#else\\nvec4 vLightSpecular{X}=vec4(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec4 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\nuniform vec4 vLightFalloff{X};\\n#elif defined(POINTLIGHT{X})\\nuniform vec4 vLightFalloff{X};\\n#elif defined(HEMILIGHT{X})\\nuniform vec3 vLightGround{X};\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=lightFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightUboDeclaration';\r\nvar shader = \"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec4 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\nvec4 vLightFalloff;\\n#elif defined(POINTLIGHT{X})\\nvec4 vLightFalloff;\\n#elif defined(HEMILIGHT{X})\\nvec3 vLightGround;\\n#endif\\nvec4 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightUboDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=lightUboDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightsFragmentFunctions';\r\nvar shader = \"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef NDOTL\\nfloat ndl;\\n#endif\\n};\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 lightVectorW;\\nfloat attenuation=1.0;\\nif (lightData.w == 0.)\\n{\\nvec3 direction=lightData.xyz-vPositionW;\\nattenuation=max(0.,1.0-length(direction)/range);\\nlightVectorW=normalize(direction);\\n}\\nelse\\n{\\nlightVectorW=normalize(-lightData.xyz);\\n}\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 direction=lightData.xyz-vPositionW;\\nvec3 lightVectorW=normalize(direction);\\nfloat attenuation=max(0.,1.0-length(direction)/range);\\n\\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\\nif (cosAngle>=lightDirection.w)\\n{\\ncosAngle=max(0.,pow(cosAngle,lightData.w));\\nattenuation*=cosAngle;\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nresult.diffuse=vec3(0.);\\n#ifdef SPECULARTERM\\nresult.specular=vec3(0.);\\n#endif\\n#ifdef NDOTL\\nresult.ndl=0.;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\\nlightingInfo result;\\n\\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor;\\n#endif\\nreturn result;\\n}\\n#define inline\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn textureColor;\\n}\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightsFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=lightsFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'shadowsFragmentFunctions';\r\nvar shader = \"#ifdef SHADOWS\\n#ifndef SHADOWFLOAT\\n\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\\n{\\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\\nreturn mix(value,1.0,mask);\\n}\\n#define inline\\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nreturn depth>shadow ? darkness : 1.0;\\n}\\n#define inline\\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\nfloat visibility=1.;\\nvec3 poissonDisk[4];\\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\\n#else\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\n#define inline\\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn esm;\\n}\\n#define inline\\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn esm;\\n}\\n#ifdef WEBGL2\\n#define inline\\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\\n#else\\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n#endif\\n#define inline\\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadow=texture2D(shadowSampler,uv).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n}\\n#define inline\\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\nfloat visibility=1.;\\nvec2 poissonDisk[4];\\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\\npoissonDisk[3]=vec2(0.34495938,0.29387760);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\\n#else\\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\n#endif\\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#ifdef WEBGL2\\n#define GREATEST_LESS_THAN_ONE 0.99999994\\n\\n#define inline\\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat shadow=texture(shadowSampler,uvDepthLayer);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\n\\n\\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n#define inline\\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat shadow=texture2D(shadowSampler,uvDepth);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\n\\n\\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\\nuv+=0.5;\\nvec2 st=fract(uv);\\nvec2 base_uv=floor(uv)-0.5;\\nbase_uv*=shadowMapSizeAndInverse.y;\\n\\n\\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\nconst vec3 PoissonSamplers32[64]=vec3[64](\\nvec3(0.06407013,0.05409927,0.),\\nvec3(0.7366577,0.5789394,0.),\\nvec3(-0.6270542,-0.5320278,0.),\\nvec3(-0.4096107,0.8411095,0.),\\nvec3(0.6849564,-0.4990818,0.),\\nvec3(-0.874181,-0.04579735,0.),\\nvec3(0.9989998,0.0009880066,0.),\\nvec3(-0.004920578,-0.9151649,0.),\\nvec3(0.1805763,0.9747483,0.),\\nvec3(-0.2138451,0.2635818,0.),\\nvec3(0.109845,0.3884785,0.),\\nvec3(0.06876755,-0.3581074,0.),\\nvec3(0.374073,-0.7661266,0.),\\nvec3(0.3079132,-0.1216763,0.),\\nvec3(-0.3794335,-0.8271583,0.),\\nvec3(-0.203878,-0.07715034,0.),\\nvec3(0.5912697,0.1469799,0.),\\nvec3(-0.88069,0.3031784,0.),\\nvec3(0.5040108,0.8283722,0.),\\nvec3(-0.5844124,0.5494877,0.),\\nvec3(0.6017799,-0.1726654,0.),\\nvec3(-0.5554981,0.1559997,0.),\\nvec3(-0.3016369,-0.3900928,0.),\\nvec3(-0.5550632,-0.1723762,0.),\\nvec3(0.925029,0.2995041,0.),\\nvec3(-0.2473137,0.5538505,0.),\\nvec3(0.9183037,-0.2862392,0.),\\nvec3(0.2469421,0.6718712,0.),\\nvec3(0.3916397,-0.4328209,0.),\\nvec3(-0.03576927,-0.6220032,0.),\\nvec3(-0.04661255,0.7995201,0.),\\nvec3(0.4402924,0.3640312,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.)\\n);\\nconst vec3 PoissonSamplers64[64]=vec3[64](\\nvec3(-0.613392,0.617481,0.),\\nvec3(0.170019,-0.040254,0.),\\nvec3(-0.299417,0.791925,0.),\\nvec3(0.645680,0.493210,0.),\\nvec3(-0.651784,0.717887,0.),\\nvec3(0.421003,0.027070,0.),\\nvec3(-0.817194,-0.271096,0.),\\nvec3(-0.705374,-0.668203,0.),\\nvec3(0.977050,-0.108615,0.),\\nvec3(0.063326,0.142369,0.),\\nvec3(0.203528,0.214331,0.),\\nvec3(-0.667531,0.326090,0.),\\nvec3(-0.098422,-0.295755,0.),\\nvec3(-0.885922,0.215369,0.),\\nvec3(0.566637,0.605213,0.),\\nvec3(0.039766,-0.396100,0.),\\nvec3(0.751946,0.453352,0.),\\nvec3(0.078707,-0.715323,0.),\\nvec3(-0.075838,-0.529344,0.),\\nvec3(0.724479,-0.580798,0.),\\nvec3(0.222999,-0.215125,0.),\\nvec3(-0.467574,-0.405438,0.),\\nvec3(-0.248268,-0.814753,0.),\\nvec3(0.354411,-0.887570,0.),\\nvec3(0.175817,0.382366,0.),\\nvec3(0.487472,-0.063082,0.),\\nvec3(-0.084078,0.898312,0.),\\nvec3(0.488876,-0.783441,0.),\\nvec3(0.470016,0.217933,0.),\\nvec3(-0.696890,-0.549791,0.),\\nvec3(-0.149693,0.605762,0.),\\nvec3(0.034211,0.979980,0.),\\nvec3(0.503098,-0.308878,0.),\\nvec3(-0.016205,-0.872921,0.),\\nvec3(0.385784,-0.393902,0.),\\nvec3(-0.146886,-0.859249,0.),\\nvec3(0.643361,0.164098,0.),\\nvec3(0.634388,-0.049471,0.),\\nvec3(-0.688894,0.007843,0.),\\nvec3(0.464034,-0.188818,0.),\\nvec3(-0.440840,0.137486,0.),\\nvec3(0.364483,0.511704,0.),\\nvec3(0.034028,0.325968,0.),\\nvec3(0.099094,-0.308023,0.),\\nvec3(0.693960,-0.366253,0.),\\nvec3(0.678884,-0.204688,0.),\\nvec3(0.001801,0.780328,0.),\\nvec3(0.145177,-0.898984,0.),\\nvec3(0.062655,-0.611866,0.),\\nvec3(0.315226,-0.604297,0.),\\nvec3(-0.780145,0.486251,0.),\\nvec3(-0.371868,0.882138,0.),\\nvec3(0.200476,0.494430,0.),\\nvec3(-0.494552,-0.711051,0.),\\nvec3(0.612476,0.705252,0.),\\nvec3(-0.578845,-0.768792,0.),\\nvec3(-0.772454,-0.090976,0.),\\nvec3(0.504440,0.372295,0.),\\nvec3(0.155736,0.065157,0.),\\nvec3(0.391522,0.849605,0.),\\nvec3(-0.620106,-0.328104,0.),\\nvec3(0.789239,-0.419965,0.),\\nvec3(-0.545396,0.538133,0.),\\nvec3(-0.178564,-0.596057,0.)\\n);\\n\\n\\n\\n\\n\\n#define inline\\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(uvDepth.z,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\n\\nfloat AAOffset=shadowMapSizeInverse*10.;\\n\\n\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec4 offset=vec4(poissonSamplers[i],0.);\\n\\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\n\\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\\n\\nshadow=mix(darkness,1.,shadow);\\n\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n\\n\\n\\n\\n\\n#define inline\\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\n\\nfloat AAOffset=shadowMapSizeInverse*10.;\\n\\n\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec3 offset=poissonSamplers[i];\\n\\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\n\\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\\n\\nshadow=mix(darkness,1.,shadow);\\n\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var shadowsFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=shadowsFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fresnelFunction';\r\nvar shader = \"#ifdef FRESNEL\\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\\n{\\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\\nreturn clamp(fresnelTerm,0.,1.);\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fresnelFunction = { name: name, shader: shader };\r\n//# sourceMappingURL=fresnelFunction.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'reflectionFunction';\r\nvar shader = \"vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\\n\\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\\nvec3 halfSize=cubeSize*0.5;\\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\\n\\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\\n\\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\\n\\nvec3 intersectPositionWS=vertexPos+origVec*distance;\\n\\nreturn intersectPositionWS-cubePos;\\n}\\nvec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0);\\n}\\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(1.0-s,t,0);\\n}\\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\\nr=vec3(reflectionMatrix*vec4(r,0));\\nfloat lon=atan(r.z,r.x);\\nfloat lat=acos(r.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0);\\n}\\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(vec3(view*worldPos));\\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\\nvec3 r=reflect(viewDir,viewNormal);\\nr=vec3(reflectionMatrix*vec4(r,0));\\nr.z=r.z-1.0;\\nfloat m=2.0*length(r);\\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\\n}\\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=worldPos.xyz-eyePosition;\\nvec3 coords=normalize(reflect(viewDir,worldNormal));\\nreturn vec3(reflectionMatrix*vec4(coords,1));\\n}\\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\n\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\n\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*(view*worldPos));\\n}\\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\\n}\\n#ifdef REFLECTION\\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\\n{\\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SPHERICAL\\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_PLANAR\\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_CUBIC\\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\\n#else\\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_PROJECTION\\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_EXPLICIT\\nreturn vec3(0,0,0);\\n#endif\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var reflectionFunction = { name: name, shader: shader };\r\n//# sourceMappingURL=reflectionFunction.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'imageProcessingDeclaration';\r\nvar shader = \"#ifdef EXPOSURE\\nuniform float exposureLinear;\\n#endif\\n#ifdef CONTRAST\\nuniform float contrast;\\n#endif\\n#ifdef VIGNETTE\\nuniform vec2 vInverseScreenSize;\\nuniform vec4 vignetteSettings1;\\nuniform vec4 vignetteSettings2;\\n#endif\\n#ifdef COLORCURVES\\nuniform vec4 vCameraColorCurveNegative;\\nuniform vec4 vCameraColorCurveNeutral;\\nuniform vec4 vCameraColorCurvePositive;\\n#endif\\n#ifdef COLORGRADING\\n#ifdef COLORGRADING3D\\nuniform highp sampler3D txColorTransform;\\n#else\\nuniform sampler2D txColorTransform;\\n#endif\\nuniform vec4 colorTransformSettings;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var imageProcessingDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=imageProcessingDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'imageProcessingFunctions';\r\nvar shader = \"#if defined(COLORGRADING) && !defined(COLORGRADING3D)\\n\\n#define inline\\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\\n{\\nfloat sliceSize=2.0*sampler3dSetting.x;\\n#ifdef SAMPLER3DGREENDEPTH\\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\\n#else\\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\\n#endif\\nfloat sliceInteger=floor(sliceContinuous);\\n\\n\\nfloat sliceFraction=sliceContinuous-sliceInteger;\\n#ifdef SAMPLER3DGREENDEPTH\\nvec2 sliceUV=color.rb;\\n#else\\nvec2 sliceUV=color.rg;\\n#endif\\nsliceUV.x*=sliceSize;\\nsliceUV.x+=sliceInteger*sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\\nsliceUV.x+=sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\\n#ifdef SAMPLER3DBGRMAP\\ncolor.rgb=result.rgb;\\n#else\\ncolor.rgb=result.bgr;\\n#endif\\nreturn color;\\n}\\n#endif\\n#ifdef TONEMAPPING_ACES\\n\\n\\n\\n\\n\\nconst mat3 ACESInputMat=mat3(\\nvec3(0.59719,0.07600,0.02840),\\nvec3(0.35458,0.90834,0.13383),\\nvec3(0.04823,0.01566,0.83777)\\n);\\n\\nconst mat3 ACESOutputMat=mat3(\\nvec3( 1.60475,-0.10208,-0.00327),\\nvec3(-0.53108,1.10813,-0.07276),\\nvec3(-0.07367,-0.00605,1.07602)\\n);\\nvec3 RRTAndODTFit(vec3 v)\\n{\\nvec3 a=v*(v+0.0245786)-0.000090537;\\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\\nreturn a/b;\\n}\\nvec3 ACESFitted(vec3 color)\\n{\\ncolor=ACESInputMat*color;\\n\\ncolor=RRTAndODTFit(color);\\ncolor=ACESOutputMat*color;\\n\\ncolor=saturate(color);\\nreturn color;\\n}\\n#endif\\nvec4 applyImageProcessing(vec4 result) {\\n#ifdef EXPOSURE\\nresult.rgb*=exposureLinear;\\n#endif\\n#ifdef VIGNETTE\\n\\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\\nviewportXY=viewportXY*2.0-1.0;\\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\\n\\nvec3 vignetteColor=vignetteSettings2.rgb;\\n#ifdef VIGNETTEBLENDMODEMULTIPLY\\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\\nresult.rgb*=vignetteColorMultiplier;\\n#endif\\n#ifdef VIGNETTEBLENDMODEOPAQUE\\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\\n#endif\\n#endif\\n#ifdef TONEMAPPING\\n#ifdef TONEMAPPING_ACES\\nresult.rgb=ACESFitted(result.rgb);\\n#else\\nconst float tonemappingCalibration=1.590579;\\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\\n#endif\\n#endif\\n\\nresult.rgb=toGammaSpace(result.rgb);\\nresult.rgb=saturate(result.rgb);\\n#ifdef CONTRAST\\n\\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\\nif (contrast<1.0) {\\n\\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\\n} else {\\n\\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\\n}\\n#endif\\n\\n#ifdef COLORGRADING\\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\\n#ifdef COLORGRADING3D\\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\\n#else\\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\\n#endif\\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\\n#endif\\n#ifdef COLORCURVES\\n\\nfloat luma=getLuminance(result.rgb);\\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\\nresult.rgb*=colorCurve.rgb;\\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\\n#endif\\nreturn result;\\n}\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var imageProcessingFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=imageProcessingFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragmentMainFunctions';\r\nvar shader = \"#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\\n#if defined(TANGENT) && defined(NORMAL)\\nvarying mat3 vTBN;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nuniform mat4 normalMatrix;\\n#endif\\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\\n{\\n#ifdef NORMALXYSCALE\\nnormal=normalize(normal*vec3(scale,scale,1.0));\\n#endif\\nreturn normalize(cotangentFrame*normal);\\n}\\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\\n{\\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\\n}\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\\n{\\n\\nuv=gl_FrontFacing ? uv : -uv;\\n\\nvec3 dp1=dFdx(p);\\nvec3 dp2=dFdy(p);\\nvec2 duv1=dFdx(uv);\\nvec2 duv2=dFdy(uv);\\n\\nvec3 dp2perp=cross(dp2,normal);\\nvec3 dp1perp=cross(normal,dp1);\\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\\n\\ntangent*=tangentSpaceParams.x;\\nbitangent*=tangentSpaceParams.y;\\n\\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\\n}\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragmentMainFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragmentMainFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragmentFunctions';\r\nvar shader = \"#if defined(BUMP)\\n#if BUMPDIRECTUV == 1\\n#define vBumpUV vMainUV1\\n#elif BUMPDIRECTUV == 2\\n#define vBumpUV vMainUV2\\n#else\\nvarying vec2 vBumpUV;\\n#endif\\nuniform sampler2D bumpSampler;\\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\\n{\\nreturn perturbNormal(cotangentFrame,texture2D(bumpSampler,uv).xyz,vBumpInfos.y);\\n}\\n#endif\\n#if defined(DETAIL)\\n#if DETAILDIRECTUV == 1\\n#define vDetailUV vMainUV1\\n#elif DETAILDIRECTUV == 2\\n#define vDetailUV vMainUV2\\n#else\\nvarying vec2 vDetailUV;\\n#endif\\nuniform sampler2D detailSampler;\\n#endif\\n#if defined(BUMP)\\nvec3 perturbNormal(mat3 cotangentFrame,vec3 color)\\n{\\nreturn perturbNormal(cotangentFrame,color,vBumpInfos.y);\\n}\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\\n{\\nreturn cotangent_frame(normal,p,uv,vTangentSpaceParams);\\n}\\n#endif\\n#if defined(BUMP) && defined(PARALLAX)\\nconst float minSamples=4.;\\nconst float maxSamples=15.;\\nconst int iMaxSamples=15;\\n\\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\\nparallaxLimit*=parallaxScale;\\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\\nfloat stepSize=1.0/numSamples;\\n\\nfloat currRayHeight=1.0;\\nvec2 vCurrOffset=vec2(0,0);\\nvec2 vLastOffset=vec2(0,0);\\nfloat lastSampledHeight=1.0;\\nfloat currSampledHeight=1.0;\\nfor (int i=0; i<iMaxSamples; i++)\\n{\\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\\n\\nif (currSampledHeight>currRayHeight)\\n{\\nfloat delta1=currSampledHeight-currRayHeight;\\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\\nfloat ratio=delta1/(delta1+delta2);\\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\\n\\nbreak;\\n}\\nelse\\n{\\ncurrRayHeight-=stepSize;\\nvLastOffset=vCurrOffset;\\nvCurrOffset+=stepSize*vMaxOffset;\\nlastSampledHeight=currSampledHeight;\\n}\\n}\\nreturn vCurrOffset;\\n}\\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\\n{\\n\\nfloat height=texture2D(bumpSampler,vBumpUV).w;\\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\\nreturn -texCoordOffset;\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragmentFunctions = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragmentFunctions.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneFragmentDeclaration';\r\nvar shader = \"#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nvarying float fClipDistance6;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthDeclaration';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nuniform float logarithmicDepthConstant;\\nvarying float vFragmentDepth;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogFragmentDeclaration';\r\nvar shader = \"#ifdef FOG\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying vec3 vFogDistance;\\nfloat CalcFogFactor()\\n{\\nfloat fogCoeff=1.0;\\nfloat fogStart=vFogInfos.y;\\nfloat fogEnd=vFogInfos.z;\\nfloat fogDensity=vFogInfos.w;\\nfloat fogDistance=length(vFogDistance);\\nif (FOGMODE_LINEAR == vFogInfos.x)\\n{\\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\\n}\\nelse if (FOGMODE_EXP == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\\n}\\nelse if (FOGMODE_EXP2 == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\\n}\\nreturn clamp(fogCoeff,0.0,1.0);\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogFragmentDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=fogFragmentDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneFragment';\r\nvar shader = \"#ifdef CLIPPLANE\\nif (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE2\\nif (fClipDistance2>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE3\\nif (fClipDistance3>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE4\\nif (fClipDistance4>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE5\\nif (fClipDistance5>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE6\\nif (fClipDistance6>0.0)\\n{\\ndiscard;\\n}\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpFragment';\r\nvar shader = \"vec2 uvOffset=vec2(0.0,0.0);\\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\\n#ifdef NORMALXYSCALE\\nfloat normalScale=1.0;\\n#elif defined(BUMP)\\nfloat normalScale=vBumpInfos.y;\\n#else\\nfloat normalScale=1.0;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#elif defined(BUMP)\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\\n#else\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vDetailUV,vec2(1.,1.));\\n#endif\\n#elif defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#else\\nmat3 TBN=cotangent_frame(normalW,vPositionW,vMainUV1,vec2(1.,1.));\\n#endif\\n#endif\\n#ifdef PARALLAX\\nmat3 invTBN=transposeMat3(TBN);\\n#ifdef PARALLAXOCCLUSION\\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\\n#else\\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\\n#endif\\n#endif\\n#ifdef DETAIL\\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\\n#endif\\n#ifdef BUMP\\n#ifdef OBJECTSPACE_NORMALMAP\\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\\nnormalW=normalize(mat3(normalMatrix)*normalW);\\n#elif !defined(DETAIL)\\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\\n#else\\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\\n\\n#if DETAIL_NORMALBLENDMETHOD == 0\\ndetailNormal.xy*=vDetailInfos.z;\\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\\n#elif DETAIL_NORMALBLENDMETHOD == 1\\ndetailNormal.xy*=vDetailInfos.z;\\nbumpNormal+=vec3(0.0,0.0,1.0);\\ndetailNormal*=vec3(-1.0,-1.0,1.0);\\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\\n#endif\\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\\n#endif\\n#elif defined(DETAIL)\\ndetailNormal.xy*=vDetailInfos.z;\\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'depthPrePass';\r\nvar shader = \"#ifdef DEPTHPREPASS\\ngl_FragColor=vec4(0.,0.,0.,1.0);\\nreturn;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var depthPrePass = { name: name, shader: shader };\r\n//# sourceMappingURL=depthPrePass.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'lightFragment';\r\nvar shader = \"#ifdef LIGHT{X}\\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\\n\\n#else\\n#ifdef PBR\\n\\n#ifdef SPOTLIGHT{X}\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(POINTLIGHT{X})\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(HEMILIGHT{X})\\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(DIRLIGHT{X})\\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#endif\\npreInfo.NdotV=NdotV;\\n\\n#ifdef SPOTLIGHT{X}\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#endif\\n#elif defined(POINTLIGHT{X})\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\n#endif\\n#else\\npreInfo.attenuation=1.0;\\n#endif\\n\\n\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=roughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n\\n#ifdef HEMILIGHT{X}\\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\\n#elif defined(SS_TRANSLUCENCY)\\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\\n#else\\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\\n#endif\\n\\n#ifdef SPECULARTERM\\n#ifdef ANISOTROPIC\\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#else\\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n#endif\\n\\n#ifdef SHEEN\\n#ifdef SHEEN_LINKWITHALBEDO\\n\\npreInfo.roughness=sheenOut.sheenIntensity;\\n#else\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=sheenOut.sheenRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n#endif\\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n\\n#ifdef CLEARCOAT\\n\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\\n#ifdef CLEARCOAT_TINT\\n\\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\\ninfo.diffuse*=absorption;\\n#ifdef SPECULARTERM\\ninfo.specular*=absorption;\\n#endif\\n#endif\\n\\ninfo.diffuse*=info.clearCoat.w;\\n#ifdef SPECULARTERM\\ninfo.specular*=info.clearCoat.w;\\n#endif\\n#ifdef SHEEN\\ninfo.sheen*=info.clearCoat.w;\\n#endif\\n#endif\\n#else\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#elif defined(HEMILIGHT{X})\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\\n#endif\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\\n{\\n#ifdef SHADOWCSM_RIGHTHANDED{X}\\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\\n#else\\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\\n#endif\\nif (diff{X}>=0.) {\\nindex{X}=i;\\nbreak;\\n}\\n}\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nif (index{X}>=0)\\n#endif\\n{\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\\n#endif\\n#ifndef SHADOWCSMNOBLEND{X}\\nfloat frustumLength=frustumLengths{X}[index{X}];\\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\\n{\\nindex{X}+=1;\\nfloat nextShadow=0.;\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\nshadow=mix(nextShadow,shadow,diffRatio);\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\\n#endif\\n}\\n#endif\\n}\\n#elif defined(SHADOWCLOSEESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPOISSON{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#else\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#endif\\n#ifdef SHADOWONLY\\n#ifndef SHADOWINUSE\\n#define SHADOWINUSE\\n#endif\\nglobalShadow+=shadow;\\nshadowLightCount+=1.0;\\n#endif\\n#else\\nshadow=1.;\\n#endif\\n#ifndef SHADOWONLY\\n#ifdef CUSTOMUSERLIGHTING\\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\\n#ifdef SPECULARTERM\\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\\n#endif\\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\\ndiffuseBase+=lightmapColor.rgb*shadow;\\n#ifdef SPECULARTERM\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef CLEARCOAT\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef SHEEN\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#else\\n#ifdef SHADOWCSMDEBUG{X}\\ndiffuseBase+=info.diffuse*shadowDebug{X};\\n#else\\ndiffuseBase+=info.diffuse*shadow;\\n#endif\\n#ifdef SPECULARTERM\\nspecularBase+=info.specular*shadow;\\n#endif\\n#ifdef CLEARCOAT\\nclearCoatBase+=info.clearCoat.rgb*shadow;\\n#endif\\n#ifdef SHEEN\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var lightFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=lightFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthFragment';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthFragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogFragment';\r\nvar shader = \"#ifdef FOG\\nfloat fog=CalcFogFactor();\\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogFragment = { name: name, shader: shader };\r\n//# sourceMappingURL=fogFragment.js.map","import { Effect } from \"../Materials/effect\";\r\nimport \"./ShadersInclude/defaultFragmentDeclaration\";\r\nimport \"./ShadersInclude/defaultUboDeclaration\";\r\nimport \"./ShadersInclude/prePassDeclaration\";\r\nimport \"./ShadersInclude/helperFunctions\";\r\nimport \"./ShadersInclude/lightFragmentDeclaration\";\r\nimport \"./ShadersInclude/lightUboDeclaration\";\r\nimport \"./ShadersInclude/lightsFragmentFunctions\";\r\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\r\nimport \"./ShadersInclude/fresnelFunction\";\r\nimport \"./ShadersInclude/reflectionFunction\";\r\nimport \"./ShadersInclude/imageProcessingDeclaration\";\r\nimport \"./ShadersInclude/imageProcessingFunctions\";\r\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\r\nimport \"./ShadersInclude/bumpFragmentFunctions\";\r\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\r\nimport \"./ShadersInclude/logDepthDeclaration\";\r\nimport \"./ShadersInclude/fogFragmentDeclaration\";\r\nimport \"./ShadersInclude/clipPlaneFragment\";\r\nimport \"./ShadersInclude/bumpFragment\";\r\nimport \"./ShadersInclude/depthPrePass\";\r\nimport \"./ShadersInclude/lightFragment\";\r\nimport \"./ShadersInclude/logDepthFragment\";\r\nimport \"./ShadersInclude/fogFragment\";\r\nvar name = 'defaultPixelShader';\r\nvar shader = \"#include<__decl__defaultFragment>\\n#if defined(BUMP) || !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\\n#define CUSTOM_FRAGMENT_BEGIN\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n\\n#define RECIPROCAL_PI2 0.15915494\\nuniform vec3 vEyePosition;\\nuniform vec3 vAmbientColor;\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n\\n#include<helperFunctions>\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV == 1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV == 2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY\\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\nuniform samplerCube refractionCubeSampler;\\n#else\\nuniform sampler2D refraction2DSampler;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\n#if SPECULARDIRECTUV == 1\\n#define vSpecularUV vMainUV1\\n#elif SPECULARDIRECTUV == 2\\n#define vSpecularUV vMainUV2\\n#else\\nvarying vec2 vSpecularUV;\\n#endif\\nuniform sampler2D specularSampler;\\n#endif\\n#ifdef ALPHATEST\\nuniform float alphaCutOff;\\n#endif\\n\\n#include<fresnelFunction>\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\nuniform samplerCube reflectionCubeSampler;\\n#else\\nuniform sampler2D reflection2DSampler;\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<imageProcessingFunctions>\\n#include<bumpFragmentMainFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n\\nvec4 baseColor=vec4(1.,1.,1.,1.);\\nvec3 diffuseColor=vDiffuseColor.rgb;\\n\\nfloat alpha=vDiffuseColor.a;\\n\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\\n#endif\\n#include<bumpFragment>\\n#ifdef TWOSIDEDLIGHTING\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n#ifdef DIFFUSE\\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\\nif (baseColor.a<alphaCutOff)\\ndiscard;\\n#endif\\n#ifdef ALPHAFROMDIFFUSE\\nalpha*=baseColor.a;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\\nbaseColor.rgb*=vDiffuseInfos.y;\\n#endif\\n#include<depthPrePass>\\n#ifdef VERTEXCOLOR\\nbaseColor.rgb*=vColor.rgb;\\n#endif\\n#ifdef DETAIL\\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\\n\\nvec3 baseAmbientColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\\n\\n#ifdef SPECULARTERM\\nfloat glossiness=vSpecularColor.a;\\nvec3 specularColor=vSpecularColor.rgb;\\n#ifdef SPECULAR\\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\\nspecularColor=specularMapColor.rgb;\\n#ifdef GLOSSINESS\\nglossiness=glossiness*specularMapColor.a;\\n#endif\\n#endif\\n#else\\nfloat glossiness=0.;\\n#endif\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\nlightingInfo info;\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\nfloat shadow=1.;\\n#ifdef LIGHTMAP\\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\\n#ifdef RGBDLIGHTMAP\\nlightmapColor.rgb=fromRGBD(lightmapColor);\\n#endif\\nlightmapColor.rgb*=vLightmapInfos.y;\\n#endif\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\nvec4 refractionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFRACTION\\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nif (dot(refractionVector,viewDirectionW)<1.0) {\\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\\n}\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\\n#endif\\n#ifdef RGBDREFRACTION\\nrefractionColor.rgb=fromRGBD(refractionColor);\\n#endif\\n#ifdef IS_REFRACTION_LINEAR\\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\\n#endif\\nrefractionColor.rgb*=vRefractionInfos.x;\\n#endif\\n\\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFLECTION\\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_3D\\n#ifdef ROUGHNESS\\nfloat bias=vReflectionInfos.y;\\n#ifdef SPECULARTERM\\n#ifdef SPECULAR\\n#ifdef GLOSSINESS\\nbias*=(1.0-specularMapColor.a);\\n#endif\\n#endif\\n#endif\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\\n#else\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\\n#endif\\n#else\\nvec2 coords=vReflectionUVW.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\ncoords/=vReflectionUVW.z;\\n#endif\\ncoords.y=1.0-coords.y;\\nreflectionColor=texture2D(reflection2DSampler,coords);\\n#endif\\n#ifdef RGBDREFLECTION\\nreflectionColor.rgb=fromRGBD(reflectionColor);\\n#endif\\n#ifdef IS_REFLECTION_LINEAR\\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\\n#endif\\nreflectionColor.rgb*=vReflectionInfos.x;\\n#ifdef REFLECTIONFRESNEL\\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\\n#ifdef REFLECTIONFRESNELFROMSPECULAR\\n#ifdef SPECULARTERM\\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#endif\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\\n#else\\nalpha*=opacityMap.a*vOpacityInfos.y;\\n#endif\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\\nif (alpha<alphaCutOff)\\ndiscard;\\n#endif\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n\\nvec3 emissiveColor=vEmissiveColor;\\n#ifdef EMISSIVE\\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\\n#endif\\n\\n#ifdef DIFFUSEFRESNEL\\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase*specularColor;\\n#ifdef SPECULAROVERALPHA\\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#else\\nvec3 finalSpecular=vec3(0.0);\\n#endif\\n#ifdef REFLECTIONOVERALPHA\\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\\n#else\\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\\n#endif\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\ncolor.rgb*=lightmapColor.rgb;\\n#else\\ncolor.rgb+=lightmapColor.rgb;\\n#endif\\n#endif\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FOG\\ncolor.rgb=max(color.rgb,0.);\\n#include<logDepthFragment>\\n#include<fogFragment>\\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ncolor.rgb=toLinearSpace(color.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ncolor.rgb=toLinearSpace(color.rgb);\\ncolor=applyImageProcessing(color);\\n#endif\\n#endif\\ncolor.a*=visibility;\\n#ifdef PREMULTIPLYALPHA\\n\\ncolor.rgb*=color.a;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\\n#ifdef PREPASS\\ngl_FragData[0]=color;\\n#ifdef PREPASS_POSITION\\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,1.0);\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\\nvec2 velocity=abs(a-b);\\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\\n#endif\\n#ifdef PREPASS_IRRADIANCE\\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#ifdef PREPASS_DEPTHNORMAL\\ngl_FragData[PREPASS_DEPTHNORMAL_INDEX]=vec4(vViewPos.z,(view*vec4(normalW,0.0)).rgb);\\n#endif\\n#ifdef PREPASS_ALBEDO\\ngl_FragData[PREPASS_ALBEDO_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#ifdef PREPASS_REFLECTIVITY\\n#if defined(SPECULAR)\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=specularMapColor;\\n#else\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0);\\n#endif\\n#endif\\n#endif\\n#if !defined(PREPASS) || defined(WEBGL2)\\ngl_FragColor=color;\\n#endif\\n}\\n\";\r\nEffect.ShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultPixelShader = { name: name, shader: shader };\r\n//# sourceMappingURL=default.fragment.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'defaultVertexDeclaration';\r\nvar shader = \"\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\nuniform mat4 specularMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef REFLECTION\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=defaultVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bonesDeclaration';\r\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\n#ifdef BONETEXTURE\\nuniform sampler2D boneSampler;\\nuniform float boneTextureWidth;\\n#else\\nuniform mat4 mBones[BonesPerMesh];\\n#ifdef BONES_VELOCITY_ENABLED\\nuniform mat4 mPreviousBones[BonesPerMesh];\\n#endif\\n#endif\\nattribute vec4 matricesIndices;\\nattribute vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute vec4 matricesIndicesExtra;\\nattribute vec4 matricesWeightsExtra;\\n#endif\\n#ifdef BONETEXTURE\\n#define inline\\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\\n{\\nfloat offset=index*4.0;\\nfloat dx=1.0/boneTextureWidth;\\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\\nreturn mat4(m0,m1,m2,m3);\\n}\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bonesDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=bonesDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'instancesDeclaration';\r\nvar shader = \"#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#ifdef THIN_INSTANCES\\nuniform mat4 world;\\n#endif\\n#else\\nuniform mat4 world;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var instancesDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=instancesDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassVertexDeclaration';\r\nvar shader = \"#ifdef PREPASS\\n#ifdef PREPASS_DEPTHNORMAL\\nvarying vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nuniform mat4 previousWorld;\\nuniform mat4 previousViewProjection;\\nvarying vec4 vCurrentPosition;\\nvarying vec4 vPreviousPosition;\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpVertexDeclaration';\r\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nvarying mat3 vTBN;\\n#endif\\n#endif\\n\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneVertexDeclaration';\r\nvar shader = \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nuniform vec4 vClipPlane5;\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nuniform vec4 vClipPlane6;\\nvarying float fClipDistance6;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogVertexDeclaration';\r\nvar shader = \"#ifdef FOG\\nvarying vec3 vFogDistance;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=fogVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertexGlobalDeclaration';\r\nvar shader = \"#ifdef MORPHTARGETS\\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertexGlobalDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertexDeclaration';\r\nvar shader = \"#ifdef MORPHTARGETS\\nattribute vec3 position{X};\\n#ifdef MORPHTARGETS_NORMAL\\nattribute vec3 normal{X};\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute vec3 tangent{X};\\n#endif\\n#ifdef MORPHTARGETS_UV\\nattribute vec2 uv_{X};\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertexDeclaration = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'morphTargetsVertex';\r\nvar shader = \"#ifdef MORPHTARGETS\\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var morphTargetsVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=morphTargetsVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'instancesVertex';\r\nvar shader = \"#ifdef INSTANCES\\nmat4 finalWorld=mat4(world0,world1,world2,world3);\\n#ifdef THIN_INSTANCES\\nfinalWorld=world*finalWorld;\\n#endif\\n#else\\nmat4 finalWorld=world;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var instancesVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=instancesVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bonesVertex';\r\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\nmat4 influence;\\n#ifdef BONETEXTURE\\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\\n#endif\\n#else\\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\n#endif\\nfinalWorld=finalWorld*influence;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bonesVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=bonesVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'prePassVertex';\r\nvar shader = \"#ifdef PREPASS_DEPTHNORMAL\\nvViewPos=(view*worldPos).rgb;\\n#endif\\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*worldPos;\\n#if NUM_BONE_INFLUENCERS>0\\nmat4 previousInfluence;\\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\nvPreviousPosition=previousViewProjection*previousWorld*previousInfluence*vec4(positionUpdated,1.0);\\n#else\\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var prePassVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=prePassVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'bumpVertex';\r\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nvec3 tbnNormal=normalize(normalUpdated);\\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var bumpVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=bumpVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'clipPlaneVertex';\r\nvar shader = \"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\\n#ifdef CLIPPLANE2\\nfClipDistance2=dot(worldPos,vClipPlane2);\\n#endif\\n#ifdef CLIPPLANE3\\nfClipDistance3=dot(worldPos,vClipPlane3);\\n#endif\\n#ifdef CLIPPLANE4\\nfClipDistance4=dot(worldPos,vClipPlane4);\\n#endif\\n#ifdef CLIPPLANE5\\nfClipDistance5=dot(worldPos,vClipPlane5);\\n#endif\\n#ifdef CLIPPLANE6\\nfClipDistance6=dot(worldPos,vClipPlane6);\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var clipPlaneVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=clipPlaneVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'fogVertex';\r\nvar shader = \"#ifdef FOG\\nvFogDistance=(view*worldPos).xyz;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var fogVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=fogVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'shadowsVertex';\r\nvar shader = \"#ifdef SHADOWS\\n#if defined(SHADOWCSM{X})\\nvPositionFromCamera{X}=view*worldPos;\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\\nvDepthMetric{X}[i]=((vPositionFromLight{X}[i].z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n}\\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n#endif\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var shadowsVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=shadowsVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'pointCloudVertex';\r\nvar shader = \"#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var pointCloudVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=pointCloudVertex.js.map","import { Effect } from \"../../Materials/effect\";\r\nvar name = 'logDepthVertex';\r\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nvFragmentDepth=1.0+gl_Position.w;\\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\\n#endif\";\r\nEffect.IncludesShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var logDepthVertex = { name: name, shader: shader };\r\n//# sourceMappingURL=logDepthVertex.js.map","import { Effect } from \"../Materials/effect\";\r\nimport \"./ShadersInclude/defaultVertexDeclaration\";\r\nimport \"./ShadersInclude/defaultUboDeclaration\";\r\nimport \"./ShadersInclude/helperFunctions\";\r\nimport \"./ShadersInclude/bonesDeclaration\";\r\nimport \"./ShadersInclude/instancesDeclaration\";\r\nimport \"./ShadersInclude/prePassVertexDeclaration\";\r\nimport \"./ShadersInclude/bumpVertexDeclaration\";\r\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\r\nimport \"./ShadersInclude/fogVertexDeclaration\";\r\nimport \"./ShadersInclude/lightFragmentDeclaration\";\r\nimport \"./ShadersInclude/lightUboDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"./ShadersInclude/logDepthDeclaration\";\r\nimport \"./ShadersInclude/morphTargetsVertex\";\r\nimport \"./ShadersInclude/instancesVertex\";\r\nimport \"./ShadersInclude/bonesVertex\";\r\nimport \"./ShadersInclude/prePassVertex\";\r\nimport \"./ShadersInclude/bumpVertex\";\r\nimport \"./ShadersInclude/clipPlaneVertex\";\r\nimport \"./ShadersInclude/fogVertex\";\r\nimport \"./ShadersInclude/shadowsVertex\";\r\nimport \"./ShadersInclude/pointCloudVertex\";\r\nimport \"./ShadersInclude/logDepthVertex\";\r\nvar name = 'defaultVertexShader';\r\nvar shader = \"#include<__decl__defaultVertex>\\n\\n#define CUSTOM_VERTEX_BEGIN\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#include<prePassVertexDeclaration>\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#if defined(DETAIL) && DETAILDIRECTUV == 0\\nvarying vec2 vDetailUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nvarying vec2 vSpecularUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_POSITION\\n#define CUSTOM_VERTEX_UPDATE_NORMAL\\n#include<instancesVertex>\\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\\n\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvPreviousPosition=previousViewProjection*previousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#include<bonesVertex>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\\nvNormalW=normalize(normalWorld*vNormalW);\\n#else\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#endif\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR == 0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\nvPositionW=vec3(worldPos);\\n#include<prePassVertex>\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uvUpdated=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uvUpdated;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nif (vDiffuseInfos.x == 0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(DETAIL) && DETAILDIRECTUV == 0\\nif (vDetailInfos.x == 0.)\\n{\\nvDetailUV=vec2(detailMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvDetailUV=vec2(detailMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nif (vSpecularInfos.x == 0.)\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n#include<pointCloudVertex>\\n#include<logDepthVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\r\nEffect.ShadersStore[name] = shader;\r\n/** @hidden */\r\nexport var defaultVertexShader = { name: name, shader: shader };\r\n//# sourceMappingURL=default.vertex.js.map","/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nvar EffectFallbacks = /** @class */ (function () {\r\n    function EffectFallbacks() {\r\n        this._defines = {};\r\n        this._currentRank = 32;\r\n        this._maxRank = -1;\r\n        this._mesh = null;\r\n    }\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    EffectFallbacks.prototype.unBindMesh = function () {\r\n        this._mesh = null;\r\n    };\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    EffectFallbacks.prototype.addFallback = function (rank, define) {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n            this._defines[rank] = new Array();\r\n        }\r\n        this._defines[rank].push(define);\r\n    };\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    EffectFallbacks.prototype.addCPUSkinningFallback = function (rank, mesh) {\r\n        this._mesh = mesh;\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    };\r\n    Object.defineProperty(EffectFallbacks.prototype, \"hasMoreFallbacks\", {\r\n        /**\r\n         * Checks to see if more fallbacks are still availible.\r\n         */\r\n        get: function () {\r\n            return this._currentRank <= this._maxRank;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    EffectFallbacks.prototype.reduce = function (currentDefines, effect) {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n            var scene = this._mesh.getScene();\r\n            for (var index = 0; index < scene.meshes.length; index++) {\r\n                var otherMesh = scene.meshes[index];\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                }\r\n                else if (otherMesh.subMeshes) {\r\n                    for (var _i = 0, _a = otherMesh.subMeshes; _i < _a.length; _i++) {\r\n                        var subMesh = _a[_i];\r\n                        var subMeshEffect = subMesh.effect;\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (var index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n            this._currentRank++;\r\n        }\r\n        return currentDefines;\r\n    };\r\n    return EffectFallbacks;\r\n}());\r\nexport { EffectFallbacks };\r\n//# sourceMappingURL=effectFallbacks.js.map","import { __decorate } from \"tslib\";\r\nimport { Material } from \"./material\";\r\nimport { serialize, expandToProperty, serializeAsTexture, SerializationHelper } from '../Misc/decorators';\r\nimport { MaterialFlags } from './materialFlags';\r\nimport { MaterialHelper } from './materialHelper';\r\n/**\r\n * Define the code related to the detail map parameters of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nvar DetailMapConfiguration = /** @class */ (function () {\r\n    /**\r\n     * Instantiate a new detail map\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    function DetailMapConfiguration(markAllSubMeshesAsTexturesDirty) {\r\n        this._texture = null;\r\n        /**\r\n         * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n         * Bigger values mean stronger blending\r\n         */\r\n        this.diffuseBlendLevel = 1;\r\n        /**\r\n         * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n         * Bigger values mean stronger blending. Only used with PBR materials\r\n         */\r\n        this.roughnessBlendLevel = 1;\r\n        /**\r\n         * Defines how strong the bump effect from the detail map is\r\n         * Bigger values mean stronger effect\r\n         */\r\n        this.bumpLevel = 1;\r\n        this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n        this._isEnabled = false;\r\n        /**\r\n         * Enable or disable the detail map on this material\r\n         */\r\n        this.isEnabled = false;\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n    /** @hidden */\r\n    DetailMapConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    };\r\n    /**\r\n     * Gets whether the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    DetailMapConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\r\n        var engine = scene.getEngine();\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Update the defines for detail map usage\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    DetailMapConfiguration.prototype.prepareDefines = function (defines, scene) {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n            var engine = scene.getEngine();\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                }\r\n                else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.DETAIL = false;\r\n        }\r\n    };\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     */\r\n    DetailMapConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen) {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    DetailMapConfiguration.prototype.hasTexture = function (texture) {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    DetailMapConfiguration.prototype.getActiveTextures = function (activeTextures) {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    DetailMapConfiguration.prototype.getAnimatables = function (animatables) {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    };\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    DetailMapConfiguration.prototype.dispose = function (forceDisposeTextures) {\r\n        var _a;\r\n        if (forceDisposeTextures) {\r\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        }\r\n    };\r\n    /**\r\n    * Get the current class name useful for serialization or dynamic coding.\r\n    * @returns \"DetailMap\"\r\n    */\r\n    DetailMapConfiguration.prototype.getClassName = function () {\r\n        return \"DetailMap\";\r\n    };\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    DetailMapConfiguration.AddUniforms = function (uniforms) {\r\n        uniforms.push(\"vDetailInfos\");\r\n    };\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    DetailMapConfiguration.AddSamplers = function (samplers) {\r\n        samplers.push(\"detailSampler\");\r\n    };\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    DetailMapConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\r\n        uniformBuffer.addUniform(\"vDetailInfos\", 4);\r\n        uniformBuffer.addUniform(\"detailMatrix\", 16);\r\n    };\r\n    /**\r\n     * Makes a duplicate of the current instance into another one.\r\n     * @param detailMap define the instance where to copy the info\r\n     */\r\n    DetailMapConfiguration.prototype.copyTo = function (detailMap) {\r\n        SerializationHelper.Clone(function () { return detailMap; }, this);\r\n    };\r\n    /**\r\n     * Serializes this detail map instance\r\n     * @returns - An object with the serialized instance.\r\n     */\r\n    DetailMapConfiguration.prototype.serialize = function () {\r\n        return SerializationHelper.Serialize(this);\r\n    };\r\n    /**\r\n     * Parses a detail map setting from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    DetailMapConfiguration.prototype.parse = function (source, scene, rootUrl) {\r\n        var _this = this;\r\n        SerializationHelper.Parse(function () { return _this; }, source, scene, rootUrl);\r\n    };\r\n    __decorate([\r\n        serializeAsTexture(\"detailTexture\"),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"texture\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"diffuseBlendLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"roughnessBlendLevel\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], DetailMapConfiguration.prototype, \"bumpLevel\", void 0);\r\n    __decorate([\r\n        serialize(),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"normalBlendMethod\", void 0);\r\n    __decorate([\r\n        serialize(),\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], DetailMapConfiguration.prototype, \"isEnabled\", void 0);\r\n    return DetailMapConfiguration;\r\n}());\r\nexport { DetailMapConfiguration };\r\n//# sourceMappingURL=material.detailMapConfiguration.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport \"../Shaders/default.fragment\";\r\nimport \"../Shaders/default.vertex\";\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { DetailMapConfiguration } from './material.detailMapConfiguration';\r\nvar onCreatedEffectParameters = { effect: null, subMesh: null };\r\n/** @hidden */\r\nvar StandardMaterialDefines = /** @class */ (function (_super) {\r\n    __extends(StandardMaterialDefines, _super);\r\n    function StandardMaterialDefines() {\r\n        var _this = _super.call(this) || this;\r\n        _this.MAINUV1 = false;\r\n        _this.MAINUV2 = false;\r\n        _this.DIFFUSE = false;\r\n        _this.DIFFUSEDIRECTUV = 0;\r\n        _this.DETAIL = false;\r\n        _this.DETAILDIRECTUV = 0;\r\n        _this.DETAIL_NORMALBLENDMETHOD = 0;\r\n        _this.AMBIENT = false;\r\n        _this.AMBIENTDIRECTUV = 0;\r\n        _this.OPACITY = false;\r\n        _this.OPACITYDIRECTUV = 0;\r\n        _this.OPACITYRGB = false;\r\n        _this.REFLECTION = false;\r\n        _this.EMISSIVE = false;\r\n        _this.EMISSIVEDIRECTUV = 0;\r\n        _this.SPECULAR = false;\r\n        _this.SPECULARDIRECTUV = 0;\r\n        _this.BUMP = false;\r\n        _this.BUMPDIRECTUV = 0;\r\n        _this.PARALLAX = false;\r\n        _this.PARALLAXOCCLUSION = false;\r\n        _this.SPECULAROVERALPHA = false;\r\n        _this.CLIPPLANE = false;\r\n        _this.CLIPPLANE2 = false;\r\n        _this.CLIPPLANE3 = false;\r\n        _this.CLIPPLANE4 = false;\r\n        _this.CLIPPLANE5 = false;\r\n        _this.CLIPPLANE6 = false;\r\n        _this.ALPHATEST = false;\r\n        _this.DEPTHPREPASS = false;\r\n        _this.ALPHAFROMDIFFUSE = false;\r\n        _this.POINTSIZE = false;\r\n        _this.FOG = false;\r\n        _this.SPECULARTERM = false;\r\n        _this.DIFFUSEFRESNEL = false;\r\n        _this.OPACITYFRESNEL = false;\r\n        _this.REFLECTIONFRESNEL = false;\r\n        _this.REFRACTIONFRESNEL = false;\r\n        _this.EMISSIVEFRESNEL = false;\r\n        _this.FRESNEL = false;\r\n        _this.NORMAL = false;\r\n        _this.UV1 = false;\r\n        _this.UV2 = false;\r\n        _this.VERTEXCOLOR = false;\r\n        _this.VERTEXALPHA = false;\r\n        _this.NUM_BONE_INFLUENCERS = 0;\r\n        _this.BonesPerMesh = 0;\r\n        _this.BONETEXTURE = false;\r\n        _this.BONES_VELOCITY_ENABLED = false;\r\n        _this.INSTANCES = false;\r\n        _this.THIN_INSTANCES = false;\r\n        _this.GLOSSINESS = false;\r\n        _this.ROUGHNESS = false;\r\n        _this.EMISSIVEASILLUMINATION = false;\r\n        _this.LINKEMISSIVEWITHDIFFUSE = false;\r\n        _this.REFLECTIONFRESNELFROMSPECULAR = false;\r\n        _this.LIGHTMAP = false;\r\n        _this.LIGHTMAPDIRECTUV = 0;\r\n        _this.OBJECTSPACE_NORMALMAP = false;\r\n        _this.USELIGHTMAPASSHADOWMAP = false;\r\n        _this.REFLECTIONMAP_3D = false;\r\n        _this.REFLECTIONMAP_SPHERICAL = false;\r\n        _this.REFLECTIONMAP_PLANAR = false;\r\n        _this.REFLECTIONMAP_CUBIC = false;\r\n        _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n        _this.REFLECTIONMAP_PROJECTION = false;\r\n        _this.REFLECTIONMAP_SKYBOX = false;\r\n        _this.REFLECTIONMAP_EXPLICIT = false;\r\n        _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n        _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n        _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n        _this.INVERTCUBICMAP = false;\r\n        _this.LOGARITHMICDEPTH = false;\r\n        _this.REFRACTION = false;\r\n        _this.REFRACTIONMAP_3D = false;\r\n        _this.REFLECTIONOVERALPHA = false;\r\n        _this.TWOSIDEDLIGHTING = false;\r\n        _this.SHADOWFLOAT = false;\r\n        _this.MORPHTARGETS = false;\r\n        _this.MORPHTARGETS_NORMAL = false;\r\n        _this.MORPHTARGETS_TANGENT = false;\r\n        _this.MORPHTARGETS_UV = false;\r\n        _this.NUM_MORPH_INFLUENCERS = 0;\r\n        _this.NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\r\n        _this.PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\r\n        _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\r\n        _this.ALPHABLEND = true;\r\n        _this.PREPASS = false;\r\n        _this.PREPASS_IRRADIANCE = false;\r\n        _this.PREPASS_IRRADIANCE_INDEX = -1;\r\n        _this.PREPASS_ALBEDO = false;\r\n        _this.PREPASS_ALBEDO_INDEX = -1;\r\n        _this.PREPASS_DEPTHNORMAL = false;\r\n        _this.PREPASS_DEPTHNORMAL_INDEX = -1;\r\n        _this.PREPASS_POSITION = false;\r\n        _this.PREPASS_POSITION_INDEX = -1;\r\n        _this.PREPASS_VELOCITY = false;\r\n        _this.PREPASS_VELOCITY_INDEX = -1;\r\n        _this.PREPASS_REFLECTIVITY = false;\r\n        _this.PREPASS_REFLECTIVITY_INDEX = -1;\r\n        _this.SCENE_MRT_COUNT = 0;\r\n        _this.RGBDLIGHTMAP = false;\r\n        _this.RGBDREFLECTION = false;\r\n        _this.RGBDREFRACTION = false;\r\n        _this.IMAGEPROCESSING = false;\r\n        _this.VIGNETTE = false;\r\n        _this.VIGNETTEBLENDMODEMULTIPLY = false;\r\n        _this.VIGNETTEBLENDMODEOPAQUE = false;\r\n        _this.TONEMAPPING = false;\r\n        _this.TONEMAPPING_ACES = false;\r\n        _this.CONTRAST = false;\r\n        _this.COLORCURVES = false;\r\n        _this.COLORGRADING = false;\r\n        _this.COLORGRADING3D = false;\r\n        _this.SAMPLER3DGREENDEPTH = false;\r\n        _this.SAMPLER3DBGRMAP = false;\r\n        _this.IMAGEPROCESSINGPOSTPROCESS = false;\r\n        _this.MULTIVIEW = false;\r\n        /**\r\n         * If the reflection texture on this material is in linear color space\r\n         * @hidden\r\n         */\r\n        _this.IS_REFLECTION_LINEAR = false;\r\n        /**\r\n         * If the refraction texture on this material is in linear color space\r\n         * @hidden\r\n         */\r\n        _this.IS_REFRACTION_LINEAR = false;\r\n        _this.EXPOSURE = false;\r\n        _this.rebuild();\r\n        return _this;\r\n    }\r\n    StandardMaterialDefines.prototype.setReflectionMode = function (modeToEnable) {\r\n        var modes = [\r\n            \"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\",\r\n            \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\",\r\n            \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\r\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"\r\n        ];\r\n        for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {\r\n            var mode = modes_1[_i];\r\n            this[mode] = (mode === modeToEnable);\r\n        }\r\n    };\r\n    return StandardMaterialDefines;\r\n}(MaterialDefines));\r\nexport { StandardMaterialDefines };\r\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/babylon101/materials\r\n */\r\nvar StandardMaterial = /** @class */ (function (_super) {\r\n    __extends(StandardMaterial, _super);\r\n    /**\r\n     * Instantiates a new standard material.\r\n     * This is the default material used in Babylon. It is the best trade off between quality\r\n     * and performances.\r\n     * @see https://doc.babylonjs.com/babylon101/materials\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    function StandardMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        _this._diffuseTexture = null;\r\n        _this._ambientTexture = null;\r\n        _this._opacityTexture = null;\r\n        _this._reflectionTexture = null;\r\n        _this._emissiveTexture = null;\r\n        _this._specularTexture = null;\r\n        _this._bumpTexture = null;\r\n        _this._lightmapTexture = null;\r\n        _this._refractionTexture = null;\r\n        /**\r\n         * The color of the material lit by the environmental background lighting.\r\n         * @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example\r\n         */\r\n        _this.ambientColor = new Color3(0, 0, 0);\r\n        /**\r\n         * The basic color of the material as viewed under a light.\r\n         */\r\n        _this.diffuseColor = new Color3(1, 1, 1);\r\n        /**\r\n         * Define how the color and intensity of the highlight given by the light in the material.\r\n         */\r\n        _this.specularColor = new Color3(1, 1, 1);\r\n        /**\r\n         * Define the color of the material as if self lit.\r\n         * This will be mixed in the final result even in the absence of light.\r\n         */\r\n        _this.emissiveColor = new Color3(0, 0, 0);\r\n        /**\r\n         * Defines how sharp are the highlights in the material.\r\n         * The bigger the value the sharper giving a more glossy feeling to the result.\r\n         * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n         */\r\n        _this.specularPower = 64;\r\n        _this._useAlphaFromDiffuseTexture = false;\r\n        _this._useEmissiveAsIllumination = false;\r\n        _this._linkEmissiveWithDiffuse = false;\r\n        _this._useSpecularOverAlpha = false;\r\n        _this._useReflectionOverAlpha = false;\r\n        _this._disableLighting = false;\r\n        _this._useObjectSpaceNormalMap = false;\r\n        _this._useParallax = false;\r\n        _this._useParallaxOcclusion = false;\r\n        /**\r\n         * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n         */\r\n        _this.parallaxScaleBias = 0.05;\r\n        _this._roughness = 0;\r\n        /**\r\n         * In case of refraction, define the value of the index of refraction.\r\n         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n         */\r\n        _this.indexOfRefraction = 0.98;\r\n        /**\r\n         * Invert the refraction texture alongside the y axis.\r\n         * It can be useful with procedural textures or probe for instance.\r\n         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n         */\r\n        _this.invertRefractionY = true;\r\n        /**\r\n         * Defines the alpha limits in alpha test mode.\r\n         */\r\n        _this.alphaCutOff = 0.4;\r\n        _this._useLightmapAsShadowmap = false;\r\n        _this._useReflectionFresnelFromSpecular = false;\r\n        _this._useGlossinessFromSpecularMapAlpha = false;\r\n        _this._maxSimultaneousLights = 4;\r\n        _this._invertNormalMapX = false;\r\n        _this._invertNormalMapY = false;\r\n        _this._twoSidedLighting = false;\r\n        /**\r\n         * Defines the detail map parameters for the material.\r\n         */\r\n        _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\r\n        _this._renderTargets = new SmartArray(16);\r\n        _this._worldViewProjectionMatrix = Matrix.Zero();\r\n        _this._globalAmbientColor = new Color3(0, 0, 0);\r\n        _this._rebuildInParallel = false;\r\n        // Setup the default processing configuration to the scene.\r\n        _this._attachImageProcessingConfiguration(null);\r\n        _this.prePassConfiguration = new PrePassConfiguration();\r\n        _this.getRenderTargetTextures = function () {\r\n            _this._renderTargets.reset();\r\n            if (StandardMaterial.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\r\n                _this._renderTargets.push(_this._reflectionTexture);\r\n            }\r\n            if (StandardMaterial.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {\r\n                _this._renderTargets.push(_this._refractionTexture);\r\n            }\r\n            return _this._renderTargets;\r\n        };\r\n        return _this;\r\n    }\r\n    Object.defineProperty(StandardMaterial.prototype, \"imageProcessingConfiguration\", {\r\n        /**\r\n         * Gets the image processing configuration used either in this material.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration;\r\n        },\r\n        /**\r\n         * Sets the Default image processing configuration used either in the this material.\r\n         *\r\n         * If sets to null, the scene one is in use.\r\n         */\r\n        set: function (value) {\r\n            this._attachImageProcessingConfiguration(value);\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    StandardMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\r\n        var _this = this;\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n        // Detaches observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n        // Pick the scene configuration if needed\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        }\r\n        else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n        // Attaches observer\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\r\n                _this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    };\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurvesEnabled\", {\r\n        /**\r\n         * Gets wether the color curves effect is enabled.\r\n         */\r\n        get: function () {\r\n            return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n        },\r\n        /**\r\n         * Sets wether the color curves effect is enabled.\r\n         */\r\n        set: function (value) {\r\n            this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingEnabled\", {\r\n        /**\r\n         * Gets wether the color grading effect is enabled.\r\n         */\r\n        get: function () {\r\n            return this.imageProcessingConfiguration.colorGradingEnabled;\r\n        },\r\n        /**\r\n         * Gets wether the color grading effect is enabled.\r\n         */\r\n        set: function (value) {\r\n            this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraToneMappingEnabled\", {\r\n        /**\r\n         * Gets wether tonemapping is enabled or not.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.toneMappingEnabled;\r\n        },\r\n        /**\r\n         * Sets wether tonemapping is enabled or not\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraExposure\", {\r\n        /**\r\n         * The camera exposure used on this material.\r\n         * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n         * This corresponds to a photographic exposure.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.exposure;\r\n        },\r\n        /**\r\n         * The camera exposure used on this material.\r\n         * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n         * This corresponds to a photographic exposure.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.exposure = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraContrast\", {\r\n        /**\r\n         * Gets The camera contrast used on this material.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.contrast;\r\n        },\r\n        /**\r\n         * Sets The camera contrast used on this material.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.contrast = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingTexture\", {\r\n        /**\r\n         * Gets the Color Grading 2D Lookup Texture.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.colorGradingTexture;\r\n        },\r\n        /**\r\n         * Sets the Color Grading 2D Lookup Texture.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.colorGradingTexture = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurves\", {\r\n        /**\r\n         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n         * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n         */\r\n        get: function () {\r\n            return this._imageProcessingConfiguration.colorCurves;\r\n        },\r\n        /**\r\n         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n         * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n         */\r\n        set: function (value) {\r\n            this._imageProcessingConfiguration.colorCurves = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"canRenderToMRT\", {\r\n        /**\r\n         * Can this material render to several textures at once\r\n         */\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial.prototype, \"hasRenderTargetTextures\", {\r\n        /**\r\n         * Gets a boolean indicating that current material needs to register RTT\r\n         */\r\n        get: function () {\r\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                return true;\r\n            }\r\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    StandardMaterial.prototype.getClassName = function () {\r\n        return \"StandardMaterial\";\r\n    };\r\n    Object.defineProperty(StandardMaterial.prototype, \"useLogarithmicDepth\", {\r\n        /**\r\n         * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n         * You can try switching to logarithmic depth.\r\n         * @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer\r\n         */\r\n        get: function () {\r\n            return this._useLogarithmicDepth;\r\n        },\r\n        set: function (value) {\r\n            this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n            this._markAllSubMeshesAsMiscDirty();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    StandardMaterial.prototype.needAlphaBlending = function () {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n        return (this.alpha < 1.0) || (this._opacityTexture != null) || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\r\n    };\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    StandardMaterial.prototype.needAlphaTesting = function () {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    };\r\n    /**\r\n     * Specifies whether or not the alpha value of the diffuse texture should be used for alpha blending.\r\n     */\r\n    StandardMaterial.prototype._shouldUseAlphaFromDiffuseTexture = function () {\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\r\n    };\r\n    /**\r\n     * Specifies whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    StandardMaterial.prototype._hasAlphaChannel = function () {\r\n        return (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._opacityTexture != null;\r\n    };\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns the diffuse texture in case of the standard material.\r\n     */\r\n    StandardMaterial.prototype.getAlphaTestTexture = function () {\r\n        return this._diffuseTexture;\r\n    };\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    StandardMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\r\n        if (useInstances === void 0) { useInstances = false; }\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new StandardMaterialDefines();\r\n        }\r\n        var scene = this.getScene();\r\n        var defines = subMesh._materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n        var engine = scene.getEngine();\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n        // PrePass\r\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT);\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            defines.MAINUV1 = false;\r\n            defines.MAINUV2 = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.DIFFUSE = false;\r\n                }\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.OPACITY = false;\r\n                }\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        defines._needNormals = true;\r\n                        defines.REFLECTION = true;\r\n                        defines.ROUGHNESS = (this._roughness > 0);\r\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\r\n                        defines.INVERTCUBICMAP = (this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE);\r\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\r\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\r\n                        switch (this._reflectionTexture.coordinatesMode) {\r\n                            case Texture.EXPLICIT_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\r\n                                break;\r\n                            case Texture.PLANAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\r\n                                break;\r\n                            case Texture.PROJECTION_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\r\n                                break;\r\n                            case Texture.SKYBOX_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\r\n                                break;\r\n                            case Texture.SPHERICAL_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\r\n                                break;\r\n                            case Texture.EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.CUBIC_MODE:\r\n                            case Texture.INVCUBIC_MODE:\r\n                            default:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\r\n                                break;\r\n                        }\r\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.REFLECTION = false;\r\n                }\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    }\r\n                }\r\n                else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\r\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.SPECULAR = false;\r\n                }\r\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                    // Bump texure can not be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n                        defines.PARALLAX = this._useParallax;\r\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\r\n                    }\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                }\r\n                else {\r\n                    defines.BUMP = false;\r\n                }\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        defines._needUVs = true;\r\n                        defines.REFRACTION = true;\r\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\r\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\r\n                    }\r\n                }\r\n                else {\r\n                    defines.REFRACTION = false;\r\n                }\r\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\r\n            }\r\n            else {\r\n                defines.DIFFUSE = false;\r\n                defines.AMBIENT = false;\r\n                defines.OPACITY = false;\r\n                defines.REFLECTION = false;\r\n                defines.EMISSIVE = false;\r\n                defines.LIGHTMAP = false;\r\n                defines.BUMP = false;\r\n                defines.REFRACTION = false;\r\n            }\r\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\r\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\r\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n            defines.PREMULTIPLYALPHA = (this.alphaMode === 7 || this.alphaMode === 8);\r\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\r\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\r\n        }\r\n        if (!this.detailMap.isReadyForSubMesh(defines, scene)) {\r\n            return false;\r\n        }\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n            defines.IS_REFLECTION_LINEAR = (this.reflectionTexture != null && !this.reflectionTexture.gammaSpace);\r\n            defines.IS_REFRACTION_LINEAR = (this.refractionTexture != null && !this.refractionTexture.gammaSpace);\r\n        }\r\n        if (defines._areFresnelDirty) {\r\n            if (StandardMaterial.FresnelEnabled) {\r\n                // Fresnel\r\n                if (this._diffuseFresnelParameters || this._opacityFresnelParameters ||\r\n                    this._emissiveFresnelParameters || this._refractionFresnelParameters ||\r\n                    this._reflectionFresnelParameters) {\r\n                    defines.DIFFUSEFRESNEL = (this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled);\r\n                    defines.OPACITYFRESNEL = (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled);\r\n                    defines.REFLECTIONFRESNEL = (this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled);\r\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\r\n                    defines.REFRACTIONFRESNEL = (this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled);\r\n                    defines.EMISSIVEFRESNEL = (this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled);\r\n                    defines._needNormals = true;\r\n                    defines.FRESNEL = true;\r\n                }\r\n            }\r\n            else {\r\n                defines.FRESNEL = false;\r\n            }\r\n        }\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n        // External config\r\n        this.detailMap.prepareDefines(defines, scene);\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            var lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.REFLECTION) {\r\n                fallbacks.addFallback(0, \"REFLECTION\");\r\n            }\r\n            if (defines.SPECULAR) {\r\n                fallbacks.addFallback(0, \"SPECULAR\");\r\n            }\r\n            if (defines.BUMP) {\r\n                fallbacks.addFallback(0, \"BUMP\");\r\n            }\r\n            if (defines.PARALLAX) {\r\n                fallbacks.addFallback(1, \"PARALLAX\");\r\n            }\r\n            if (defines.PARALLAXOCCLUSION) {\r\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\r\n            }\r\n            if (defines.SPECULAROVERALPHA) {\r\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\r\n            }\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(0, \"POINTSIZE\");\r\n            }\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n            if (defines.SPECULARTERM) {\r\n                fallbacks.addFallback(0, \"SPECULARTERM\");\r\n            }\r\n            if (defines.DIFFUSEFRESNEL) {\r\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\r\n            }\r\n            if (defines.OPACITYFRESNEL) {\r\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\r\n            }\r\n            if (defines.REFLECTIONFRESNEL) {\r\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\r\n            }\r\n            if (defines.EMISSIVEFRESNEL) {\r\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\r\n            }\r\n            if (defines.FRESNEL) {\r\n                fallbacks.addFallback(4, \"FRESNEL\");\r\n            }\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n            MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n            var shaderName = \"default\";\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\", \"visibility\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"normalMatrix\", \"lightmapMatrix\", \"refractionMatrix\",\r\n                \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\",\r\n                \"vReflectionPosition\", \"vReflectionSize\",\r\n                \"logarithmicDepthConstant\", \"vTangentSpaceParams\", \"alphaCutOff\", \"boneTextureWidth\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\",\r\n                \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\",\r\n                \"refractionCubeSampler\", \"refraction2DSampler\", \"boneSampler\"];\r\n            var uniformBuffers = [\"Material\", \"Scene\"];\r\n            DetailMapConfiguration.AddUniforms(uniforms);\r\n            DetailMapConfiguration.AddSamplers(samplers);\r\n            PrePassConfiguration.AddUniforms(uniforms);\r\n            PrePassConfiguration.AddSamplers(uniforms);\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n            MaterialHelper.PrepareUniformsAndSamplersList({\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights\r\n            });\r\n            var csnrOptions = {};\r\n            if (this.customShaderNameResolve) {\r\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n            }\r\n            var join = defines.toString();\r\n            var previousEffect = subMesh.effect;\r\n            var effect = scene.getEngine().createEffect(shaderName, {\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                multiTarget: defines.PREPASS\r\n            }, engine);\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    this._rebuildInParallel = true;\r\n                    defines.markAsUnprocessed();\r\n                    if (lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    this._rebuildInParallel = false;\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines);\r\n                    this.buildUniformLayout();\r\n                }\r\n            }\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        return true;\r\n    };\r\n    /**\r\n     * Builds the material UBO layouts.\r\n     * Used internally during the effect preparation.\r\n     */\r\n    StandardMaterial.prototype.buildUniformLayout = function () {\r\n        // Order is important !\r\n        var ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"diffuseLeftColor\", 4);\r\n        ubo.addUniform(\"diffuseRightColor\", 4);\r\n        ubo.addUniform(\"opacityParts\", 4);\r\n        ubo.addUniform(\"reflectionLeftColor\", 4);\r\n        ubo.addUniform(\"reflectionRightColor\", 4);\r\n        ubo.addUniform(\"refractionLeftColor\", 4);\r\n        ubo.addUniform(\"refractionRightColor\", 4);\r\n        ubo.addUniform(\"emissiveLeftColor\", 4);\r\n        ubo.addUniform(\"emissiveRightColor\", 4);\r\n        ubo.addUniform(\"vDiffuseInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 2);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vSpecularInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n        ubo.addUniform(\"diffuseMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"specularMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"refractionMatrix\", 16);\r\n        ubo.addUniform(\"vRefractionInfos\", 4);\r\n        ubo.addUniform(\"vSpecularColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"visibility\", 1);\r\n        ubo.addUniform(\"vDiffuseColor\", 4);\r\n        DetailMapConfiguration.PrepareUniformBuffer(ubo);\r\n        ubo.create();\r\n    };\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    StandardMaterial.prototype.unbind = function () {\r\n        if (this._activeEffect) {\r\n            var needFlag = false;\r\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"reflection2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n            if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._activeEffect.setTexture(\"refraction2DSampler\", null);\r\n                needFlag = true;\r\n            }\r\n            if (needFlag) {\r\n                this._markAllSubMeshesAsTexturesDirty();\r\n            }\r\n        }\r\n        _super.prototype.unbind.call(this);\r\n    };\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    StandardMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\r\n        var scene = this.getScene();\r\n        var defines = subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCES) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        // PrePass\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n        var mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, effect);\r\n        var ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            ubo.bindToEffect(effect, \"Material\");\r\n            this.bindViewProjection(effect);\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {\r\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\r\n                    // Fresnel\r\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\r\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\r\n                    }\r\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"opacityParts\", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\r\n                    }\r\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\r\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\r\n                    }\r\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\r\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\r\n                    }\r\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\r\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\r\n                    }\r\n                }\r\n                // Textures\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\r\n                    }\r\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n                    if (this._hasAlphaChannel()) {\r\n                        effect.setFloat(\"alphaCutOff\", this.alphaCutOff);\r\n                    }\r\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\r\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\r\n                        if (this._reflectionTexture.boundingBoxSize) {\r\n                            var cubeTexture = this._reflectionTexture;\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, \"specular\");\r\n                    }\r\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\r\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        }\r\n                        else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                        var depth = 1.0;\r\n                        if (!this._refractionTexture.isCube) {\r\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\r\n                            if (this._refractionTexture.depth) {\r\n                                depth = this._refractionTexture.depth;\r\n                            }\r\n                        }\r\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n                    }\r\n                }\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n                if (defines.SPECULARTERM) {\r\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n                }\r\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\r\n                // Diffuse\r\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\r\n            }\r\n            // Visibility\r\n            ubo.updateFloat(\"visibility\", mesh.visibility);\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (this._reflectionTexture.isCube) {\r\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\r\n                    }\r\n                    else {\r\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\r\n                    }\r\n                }\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\r\n                }\r\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    var depth = 1.0;\r\n                    if (this._refractionTexture.isCube) {\r\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\r\n                    }\r\n                    else {\r\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\r\n                    }\r\n                }\r\n            }\r\n            this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(effect, scene);\r\n            // Colors\r\n            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n            effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n        }\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights, this._rebuildInParallel);\r\n            }\r\n            // View\r\n            if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {\r\n                this.bindView(effect);\r\n            }\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, effect);\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n            }\r\n            // Log. depth\r\n            if (this.useLogarithmicDepth) {\r\n                MaterialHelper.BindLogDepth(defines, effect, scene);\r\n            }\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n        ubo.update();\r\n        this._afterBind(mesh, this._activeEffect);\r\n    };\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    StandardMaterial.prototype.getAnimatables = function () {\r\n        var results = [];\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\r\n            results.push(this._specularTexture);\r\n        }\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            results.push(this._refractionTexture);\r\n        }\r\n        this.detailMap.getAnimatables(results);\r\n        return results;\r\n    };\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    StandardMaterial.prototype.getActiveTextures = function () {\r\n        var activeTextures = _super.prototype.getActiveTextures.call(this);\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n        if (this._specularTexture) {\r\n            activeTextures.push(this._specularTexture);\r\n        }\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n        this.detailMap.getActiveTextures(activeTextures);\r\n        return activeTextures;\r\n    };\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    StandardMaterial.prototype.hasTexture = function (texture) {\r\n        if (_super.prototype.hasTexture.call(this, texture)) {\r\n            return true;\r\n        }\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._specularTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n        return this.detailMap.hasTexture(texture);\r\n    };\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     */\r\n    StandardMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        if (forceDisposeTextures) {\r\n            (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();\r\n            (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\r\n            (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\r\n            (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\r\n            (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\r\n            (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();\r\n            (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();\r\n            (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();\r\n            (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();\r\n        }\r\n        this.detailMap.dispose(forceDisposeTextures);\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\r\n    };\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    StandardMaterial.prototype.clone = function (name) {\r\n        var _this = this;\r\n        var result = SerializationHelper.Clone(function () { return new StandardMaterial(name, _this.getScene()); }, this);\r\n        result.name = name;\r\n        result.id = name;\r\n        return result;\r\n    };\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    StandardMaterial.prototype.serialize = function () {\r\n        return SerializationHelper.Serialize(this);\r\n    };\r\n    /**\r\n     * Creates a standard material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new standard material\r\n     */\r\n    StandardMaterial.Parse = function (source, scene, rootUrl) {\r\n        return SerializationHelper.Parse(function () { return new StandardMaterial(source.name, scene); }, source, scene, rootUrl);\r\n    };\r\n    Object.defineProperty(StandardMaterial, \"DiffuseTextureEnabled\", {\r\n        // Flags used to enable or disable a type of texture for all Standard Materials\r\n        /**\r\n         * Are diffuse textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.DiffuseTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.DiffuseTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"DetailTextureEnabled\", {\r\n        /**\r\n         * Are detail textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.DetailTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.DetailTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"AmbientTextureEnabled\", {\r\n        /**\r\n         * Are ambient textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.AmbientTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.AmbientTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"OpacityTextureEnabled\", {\r\n        /**\r\n         * Are opacity textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.OpacityTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.OpacityTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"ReflectionTextureEnabled\", {\r\n        /**\r\n         * Are reflection textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.ReflectionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.ReflectionTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"EmissiveTextureEnabled\", {\r\n        /**\r\n         * Are emissive textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.EmissiveTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.EmissiveTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"SpecularTextureEnabled\", {\r\n        /**\r\n         * Are specular textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.SpecularTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.SpecularTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"BumpTextureEnabled\", {\r\n        /**\r\n         * Are bump textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.BumpTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.BumpTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"LightmapTextureEnabled\", {\r\n        /**\r\n         * Are lightmap textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.LightmapTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.LightmapTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"RefractionTextureEnabled\", {\r\n        /**\r\n         * Are refraction textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.RefractionTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.RefractionTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"ColorGradingTextureEnabled\", {\r\n        /**\r\n         * Are color grading textures enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.ColorGradingTextureEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.ColorGradingTextureEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(StandardMaterial, \"FresnelEnabled\", {\r\n        /**\r\n         * Are fresnels enabled in the application.\r\n         */\r\n        get: function () {\r\n            return MaterialFlags.FresnelEnabled;\r\n        },\r\n        set: function (value) {\r\n            MaterialFlags.FresnelEnabled = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    __decorate([\r\n        serializeAsTexture(\"diffuseTexture\")\r\n    ], StandardMaterial.prototype, \"_diffuseTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"diffuseTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"ambientTexture\")\r\n    ], StandardMaterial.prototype, \"_ambientTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"ambientTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"opacityTexture\")\r\n    ], StandardMaterial.prototype, \"_opacityTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"opacityTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"reflectionTexture\")\r\n    ], StandardMaterial.prototype, \"_reflectionTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"reflectionTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"emissiveTexture\")\r\n    ], StandardMaterial.prototype, \"_emissiveTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"emissiveTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"specularTexture\")\r\n    ], StandardMaterial.prototype, \"_specularTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"specularTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"bumpTexture\")\r\n    ], StandardMaterial.prototype, \"_bumpTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"bumpTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"lightmapTexture\")\r\n    ], StandardMaterial.prototype, \"_lightmapTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"lightmapTexture\", void 0);\r\n    __decorate([\r\n        serializeAsTexture(\"refractionTexture\")\r\n    ], StandardMaterial.prototype, \"_refractionTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"refractionTexture\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"ambient\")\r\n    ], StandardMaterial.prototype, \"ambientColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"diffuse\")\r\n    ], StandardMaterial.prototype, \"diffuseColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"specular\")\r\n    ], StandardMaterial.prototype, \"specularColor\", void 0);\r\n    __decorate([\r\n        serializeAsColor3(\"emissive\")\r\n    ], StandardMaterial.prototype, \"emissiveColor\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"specularPower\", void 0);\r\n    __decorate([\r\n        serialize(\"useAlphaFromDiffuseTexture\")\r\n    ], StandardMaterial.prototype, \"_useAlphaFromDiffuseTexture\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"useAlphaFromDiffuseTexture\", void 0);\r\n    __decorate([\r\n        serialize(\"useEmissiveAsIllumination\")\r\n    ], StandardMaterial.prototype, \"_useEmissiveAsIllumination\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useEmissiveAsIllumination\", void 0);\r\n    __decorate([\r\n        serialize(\"linkEmissiveWithDiffuse\")\r\n    ], StandardMaterial.prototype, \"_linkEmissiveWithDiffuse\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"linkEmissiveWithDiffuse\", void 0);\r\n    __decorate([\r\n        serialize(\"useSpecularOverAlpha\")\r\n    ], StandardMaterial.prototype, \"_useSpecularOverAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useSpecularOverAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"useReflectionOverAlpha\")\r\n    ], StandardMaterial.prototype, \"_useReflectionOverAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useReflectionOverAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"disableLighting\")\r\n    ], StandardMaterial.prototype, \"_disableLighting\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    ], StandardMaterial.prototype, \"disableLighting\", void 0);\r\n    __decorate([\r\n        serialize(\"useObjectSpaceNormalMap\")\r\n    ], StandardMaterial.prototype, \"_useObjectSpaceNormalMap\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useObjectSpaceNormalMap\", void 0);\r\n    __decorate([\r\n        serialize(\"useParallax\")\r\n    ], StandardMaterial.prototype, \"_useParallax\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useParallax\", void 0);\r\n    __decorate([\r\n        serialize(\"useParallaxOcclusion\")\r\n    ], StandardMaterial.prototype, \"_useParallaxOcclusion\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useParallaxOcclusion\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"parallaxScaleBias\", void 0);\r\n    __decorate([\r\n        serialize(\"roughness\")\r\n    ], StandardMaterial.prototype, \"_roughness\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"roughness\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"indexOfRefraction\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"invertRefractionY\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"alphaCutOff\", void 0);\r\n    __decorate([\r\n        serialize(\"useLightmapAsShadowmap\")\r\n    ], StandardMaterial.prototype, \"_useLightmapAsShadowmap\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"diffuseFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_diffuseFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"diffuseFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"opacityFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_opacityFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\r\n    ], StandardMaterial.prototype, \"opacityFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"reflectionFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_reflectionFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"reflectionFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"refractionFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_refractionFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"refractionFresnelParameters\", void 0);\r\n    __decorate([\r\n        serializeAsFresnelParameters(\"emissiveFresnelParameters\")\r\n    ], StandardMaterial.prototype, \"_emissiveFresnelParameters\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"emissiveFresnelParameters\", void 0);\r\n    __decorate([\r\n        serialize(\"useReflectionFresnelFromSpecular\")\r\n    ], StandardMaterial.prototype, \"_useReflectionFresnelFromSpecular\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    ], StandardMaterial.prototype, \"useReflectionFresnelFromSpecular\", void 0);\r\n    __decorate([\r\n        serialize(\"useGlossinessFromSpecularMapAlpha\")\r\n    ], StandardMaterial.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0);\r\n    __decorate([\r\n        serialize(\"maxSimultaneousLights\")\r\n    ], StandardMaterial.prototype, \"_maxSimultaneousLights\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    ], StandardMaterial.prototype, \"maxSimultaneousLights\", void 0);\r\n    __decorate([\r\n        serialize(\"invertNormalMapX\")\r\n    ], StandardMaterial.prototype, \"_invertNormalMapX\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"invertNormalMapX\", void 0);\r\n    __decorate([\r\n        serialize(\"invertNormalMapY\")\r\n    ], StandardMaterial.prototype, \"_invertNormalMapY\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"invertNormalMapY\", void 0);\r\n    __decorate([\r\n        serialize(\"twoSidedLighting\")\r\n    ], StandardMaterial.prototype, \"_twoSidedLighting\", void 0);\r\n    __decorate([\r\n        expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], StandardMaterial.prototype, \"twoSidedLighting\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], StandardMaterial.prototype, \"useLogarithmicDepth\", null);\r\n    return StandardMaterial;\r\n}(PushMaterial));\r\nexport { StandardMaterial };\r\n_TypeStore.RegisteredTypes[\"BABYLON.StandardMaterial\"] = StandardMaterial;\r\nScene.DefaultMaterialFactory = function (scene) {\r\n    return new StandardMaterial(\"default material\", scene);\r\n};\r\n//# sourceMappingURL=standardMaterial.js.map","/**\r\n * Enum for the animation key frame interpolation type\r\n */\r\nexport var AnimationKeyInterpolation;\r\n(function (AnimationKeyInterpolation) {\r\n    /**\r\n     * Do not interpolate between keys and use the start key value only. Tangents are ignored\r\n     */\r\n    AnimationKeyInterpolation[AnimationKeyInterpolation[\"STEP\"] = 1] = \"STEP\";\r\n})(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));\r\n//# sourceMappingURL=animationKey.js.map","/**\r\n * Represents the range of an animation\r\n */\r\nvar AnimationRange = /** @class */ (function () {\r\n    /**\r\n     * Initializes the range of an animation\r\n     * @param name The name of the animation range\r\n     * @param from The starting frame of the animation\r\n     * @param to The ending frame of the animation\r\n     */\r\n    function AnimationRange(\r\n    /**The name of the animation range**/\r\n    name, \r\n    /**The starting frame of the animation */\r\n    from, \r\n    /**The ending frame of the animation*/\r\n    to) {\r\n        this.name = name;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n    /**\r\n     * Makes a copy of the animation range\r\n     * @returns A copy of the animation range\r\n     */\r\n    AnimationRange.prototype.clone = function () {\r\n        return new AnimationRange(this.name, this.from, this.to);\r\n    };\r\n    return AnimationRange;\r\n}());\r\nexport { AnimationRange };\r\n//# sourceMappingURL=animationRange.js.map","import { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { AnimationKeyInterpolation } from './animationKey';\r\nimport { AnimationRange } from './animationRange';\r\nimport { Node } from \"../node\";\r\nimport { Size } from '../Maths/math.size';\r\nimport { WebRequest } from '../Misc/webRequest';\r\n/**\r\n * @hidden\r\n */\r\nvar _IAnimationState = /** @class */ (function () {\r\n    function _IAnimationState() {\r\n    }\r\n    return _IAnimationState;\r\n}());\r\nexport { _IAnimationState };\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nvar Animation = /** @class */ (function () {\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    function Animation(\r\n    /**Name of the animation */\r\n    name, \r\n    /**Property to animate */\r\n    targetProperty, \r\n    /**The frames per second of the animation */\r\n    framePerSecond, \r\n    /**The data type of the animation */\r\n    dataType, \r\n    /**The loop mode of the animation */\r\n    loopMode, \r\n    /**Specifies if blending should be enabled */\r\n    enableBlending) {\r\n        this.name = name;\r\n        this.targetProperty = targetProperty;\r\n        this.framePerSecond = framePerSecond;\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode;\r\n        this.enableBlending = enableBlending;\r\n        /**\r\n         * @hidden Internal use only\r\n         */\r\n        this._runtimeAnimations = new Array();\r\n        /**\r\n         * The set of event that will be linked to this animation\r\n         */\r\n        this._events = new Array();\r\n        /**\r\n         * Stores the blending speed of the animation\r\n         */\r\n        this.blendingSpeed = 0.01;\r\n        /**\r\n         * Stores the animation ranges for the animation\r\n         */\r\n        this._ranges = {};\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n    }\r\n    /**\r\n     * @hidden Internal use\r\n     */\r\n    Animation._PrepareAnimation = function (name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\r\n        var dataType = undefined;\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        }\r\n        else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        }\r\n        else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        }\r\n        else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        }\r\n        else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        }\r\n        else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        }\r\n        else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n        var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n        var keys = [{ frame: 0, value: from }, { frame: totalFrame, value: to }];\r\n        animation.setKeys(keys);\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n        return animation;\r\n    };\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    Animation.CreateAnimation = function (property, animationType, framePerSecond, easingFunction) {\r\n        var animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        animation.setEasingFunction(easingFunction);\r\n        return animation;\r\n    };\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @returns the animatable created for this animation\r\n     */\r\n    Animation.CreateAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n        return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    Animation.CreateAndStartHierarchyAnimation = function (name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n        var scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    Animation.CreateMergeAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n        node.animations.push(animation);\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    Animation.MakeAnimationAdditive = function (sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {\r\n        if (referenceFrame === void 0) { referenceFrame = 0; }\r\n        if (cloneOriginal === void 0) { cloneOriginal = false; }\r\n        var animation = sourceAnimation;\r\n        if (cloneOriginal) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = clonedName || animation.name;\r\n        }\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\r\n        var startIndex = 0;\r\n        var firstKey = animation._keys[0];\r\n        var endIndex = animation._keys.length - 1;\r\n        var lastKey = animation._keys[endIndex];\r\n        var valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3]\r\n        };\r\n        var referenceFound = false;\r\n        var from = firstKey.frame;\r\n        var to = lastKey.frame;\r\n        if (range) {\r\n            var rangeValue = animation.getRange(range);\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        }\r\n        var fromKeyFound = firstKey.frame === from;\r\n        var toKeyFound = lastKey.frame === to;\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            var value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            var value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            var value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n        // Find key bookends, create them if they don't exist\r\n        var index = 0;\r\n        while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\r\n            var currentKey = animation._keys[index];\r\n            var nextKey = animation._keys[index + 1];\r\n            // If reference frame wasn't found yet, check if we can interpolate to it\r\n            if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\r\n                var value = void 0;\r\n                if (referenceFrame === currentKey.frame) {\r\n                    value = animation._getKeyValue(currentKey.value);\r\n                }\r\n                else if (referenceFrame === nextKey.frame) {\r\n                    value = animation._getKeyValue(nextKey.value);\r\n                }\r\n                else {\r\n                    var animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    value = animation._interpolate(referenceFrame, animationState);\r\n                }\r\n                valueStore.referenceValue = value.clone ? value.clone() : value;\r\n                referenceFound = true;\r\n            }\r\n            // If from key wasn't found yet, check if we can interpolate to it\r\n            if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\r\n                if (from === currentKey.frame) {\r\n                    startIndex = index;\r\n                }\r\n                else if (from === nextKey.frame) {\r\n                    startIndex = index + 1;\r\n                }\r\n                else {\r\n                    var animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    var value = animation._interpolate(from, animationState);\r\n                    var key = {\r\n                        frame: from,\r\n                        value: value.clone ? value.clone() : value\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    startIndex = index + 1;\r\n                }\r\n                fromKeyFound = true;\r\n            }\r\n            // If to key wasn't found yet, check if we can interpolate to it\r\n            if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\r\n                if (to === currentKey.frame) {\r\n                    endIndex = index;\r\n                }\r\n                else if (to === nextKey.frame) {\r\n                    endIndex = index + 1;\r\n                }\r\n                else {\r\n                    var animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    var value = animation._interpolate(to, animationState);\r\n                    var key = {\r\n                        frame: to,\r\n                        value: value.clone ? value.clone() : value\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    endIndex = index + 1;\r\n                }\r\n                toKeyFound = true;\r\n            }\r\n            index++;\r\n        }\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n        // Subtract the reference value from all of the key values\r\n        for (var index = startIndex; index <= endIndex; index++) {\r\n            var key = animation._keys[index];\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n        return animation;\r\n    };\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    Animation.TransitionTo = function (property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {\r\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n        var endFrame = frameRate * (duration / 1000);\r\n        transition.setKeys([{\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property]\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue\r\n            }]);\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n        host.animations.push(transition);\r\n        var animation = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    };\r\n    Object.defineProperty(Animation.prototype, \"runtimeAnimations\", {\r\n        /**\r\n         * Return the array of runtime animations currently using this animation\r\n         */\r\n        get: function () {\r\n            return this._runtimeAnimations;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animation.prototype, \"hasRunningRuntimeAnimations\", {\r\n        /**\r\n         * Specifies if any of the runtime animations are currently running\r\n         */\r\n        get: function () {\r\n            for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {\r\n                var runtimeAnimation = _a[_i];\r\n                if (!runtimeAnimation.isStopped) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    Animation.prototype.toString = function (fullDetails) {\r\n        var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + ([\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"])[this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            var first = true;\r\n            for (var name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    Animation.prototype.addEvent = function (event) {\r\n        this._events.push(event);\r\n        this._events.sort(function (a, b) { return a.frame - b.frame; });\r\n    };\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    Animation.prototype.removeEvents = function (frame) {\r\n        for (var index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    Animation.prototype.getEvents = function () {\r\n        return this._events;\r\n    };\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    Animation.prototype.createRange = function (name, from, to) {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    };\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    Animation.prototype.deleteRange = function (name, deleteFrames) {\r\n        if (deleteFrames === void 0) { deleteFrames = true; }\r\n        var range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            var from = range.from;\r\n            var to = range.to;\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (var key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    };\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    Animation.prototype.getRange = function (name) {\r\n        return this._ranges[name];\r\n    };\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    Animation.prototype.getKeys = function () {\r\n        return this._keys;\r\n    };\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    Animation.prototype.getHighestFrame = function () {\r\n        var ret = 0;\r\n        for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    Animation.prototype.getEasingFunction = function () {\r\n        return this._easingFunction;\r\n    };\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    Animation.prototype.setEasingFunction = function (easingFunction) {\r\n        this._easingFunction = easingFunction;\r\n    };\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    Animation.prototype.floatInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    Animation.prototype.quaternionInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    };\r\n    /**\r\n     * Interpolates a Vector3 linearl\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    Animation.prototype.vector3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    Animation.prototype.vector2InterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    Animation.prototype.vector2InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    Animation.prototype.sizeInterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    Animation.prototype.color3InterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    Animation.prototype.color4InterpolateFunction = function (startValue, endValue, gradient) {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    Animation.prototype._getKeyValue = function (value) {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    Animation.prototype._interpolate = function (currentFrame, state) {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n        var keys = this._keys;\r\n        if (keys.length === 1) {\r\n            return this._getKeyValue(keys[0].value);\r\n        }\r\n        var startKeyIndex = state.key;\r\n        if (keys[startKeyIndex].frame >= currentFrame) {\r\n            while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\r\n                startKeyIndex--;\r\n            }\r\n        }\r\n        for (var key = startKeyIndex; key < keys.length; key++) {\r\n            var endKey = keys[key + 1];\r\n            if (endKey.frame >= currentFrame) {\r\n                state.key = key;\r\n                var startKey = keys[key];\r\n                var startValue = this._getKeyValue(startKey.value);\r\n                if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n                    return startValue;\r\n                }\r\n                var endValue = this._getKeyValue(endKey.value);\r\n                var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n                var frameDelta = endKey.frame - startKey.frame;\r\n                // gradient : percent of currentFrame between the frame inf and the frame sup\r\n                var gradient = (currentFrame - startKey.frame) / frameDelta;\r\n                // check for easingFunction and correction of gradient\r\n                var easingFunction = this.getEasingFunction();\r\n                if (easingFunction != null) {\r\n                    gradient = easingFunction.ease(gradient);\r\n                }\r\n                switch (this.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return floatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return state.offsetValue * state.repeatCount + floatValue;\r\n                        }\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return quatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                        return quatValue;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec3Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec2Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.color3InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Color4\r\n                    case Animation.ANIMATIONTYPE_COLOR4:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.color4InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Matrix\r\n                    case Animation.ANIMATIONTYPE_MATRIX:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                if (Animation.AllowMatricesInterpolation) {\r\n                                    return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                                }\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return startValue;\r\n                        }\r\n                    default:\r\n                        break;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return this._getKeyValue(keys[keys.length - 1].value);\r\n    };\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    Animation.prototype.matrixInterpolateFunction = function (startValue, endValue, gradient, result) {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    };\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    Animation.prototype.clone = function () {\r\n        var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (var name in this._ranges) {\r\n                var range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n        return clone;\r\n    };\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     */\r\n    Animation.prototype.setKeys = function (values) {\r\n        this._keys = values.slice(0);\r\n    };\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    Animation.prototype.serialize = function () {\r\n        var serializationObject = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n        var dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        var keys = this.getKeys();\r\n        for (var index = 0; index < keys.length; index++) {\r\n            var animationKey = keys[index];\r\n            var key = {};\r\n            key.frame = animationKey.frame;\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    break;\r\n            }\r\n            serializationObject.keys.push(key);\r\n        }\r\n        serializationObject.ranges = [];\r\n        for (var name in this._ranges) {\r\n            var source = this._ranges[name];\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            var range = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n        return serializationObject;\r\n    };\r\n    /** @hidden */\r\n    Animation._UniversalLerp = function (left, right, amount) {\r\n        var constructor = left.constructor;\r\n        if (constructor.Lerp) { // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        }\r\n        else if (constructor.Slerp) { // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        }\r\n        else if (left.toFixed) { // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        }\r\n        else { // Blending not supported\r\n            return right;\r\n        }\r\n    };\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    Animation.Parse = function (parsedAnimation) {\r\n        var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n        var dataType = parsedAnimation.dataType;\r\n        var keys = [];\r\n        var data;\r\n        var index;\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            var key = parsedAnimation.keys[index];\r\n            var inTangent;\r\n            var outTangent;\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 1) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 2) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    break;\r\n            }\r\n            var keyData = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n        animation.setKeys(keys);\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return animation;\r\n    };\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    Animation.AppendSerializedAnimations = function (source, destination) {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    };\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    Animation.ParseFromFileAsync = function (name, url) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", function () {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.length) {\r\n                            var output = new Array();\r\n                            for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {\r\n                                var serializedAnimation = serializationObject_1[_i];\r\n                                output.push(_this.Parse(serializedAnimation));\r\n                            }\r\n                            resolve(output);\r\n                        }\r\n                        else {\r\n                            var output = _this.Parse(serializationObject);\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n                            resolve(output);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    };\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    Animation.CreateFromSnippetAsync = function (snippetId) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", function () {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        if (snippet.animations) {\r\n                            var serializationObject = JSON.parse(snippet.animations);\r\n                            var output = new Array();\r\n                            for (var _i = 0, serializationObject_2 = serializationObject; _i < serializationObject_2.length; _i++) {\r\n                                var serializedAnimation = serializationObject_2[_i];\r\n                                output.push(_this.Parse(serializedAnimation));\r\n                            }\r\n                            resolve(output);\r\n                        }\r\n                        else {\r\n                            var serializationObject = JSON.parse(snippet.animation);\r\n                            var output = _this.Parse(serializationObject);\r\n                            output.snippetId = snippetId;\r\n                            resolve(output);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    };\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    Animation.AllowMatricesInterpolation = false;\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    Animation.AllowMatrixDecomposeForInterpolation = true;\r\n    /** Define the Url to load snippets */\r\n    Animation.SnippetUrl = \"https://snippet.babylonjs.com\";\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    Animation.ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    Animation.ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    Animation.ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    Animation.ANIMATIONLOOPMODE_CONSTANT = 2;\r\n    return Animation;\r\n}());\r\nexport { Animation };\r\n_TypeStore.RegisteredTypes[\"BABYLON.Animation\"] = Animation;\r\nNode._AnimationRangeFactory = function (name, from, to) { return new AnimationRange(name, from, to); };\r\n//# sourceMappingURL=animation.js.map","import { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n */\r\nvar AutoRotationBehavior = /** @class */ (function () {\r\n    function AutoRotationBehavior() {\r\n        this._zoomStopsAnimation = false;\r\n        this._idleRotationSpeed = 0.05;\r\n        this._idleRotationWaitTime = 2000;\r\n        this._idleRotationSpinupTime = 2000;\r\n        this._isPointerDown = false;\r\n        this._lastFrameTime = null;\r\n        this._lastInteractionTime = -Infinity;\r\n        this._cameraRotationSpeed = 0;\r\n        this._lastFrameRadius = 0;\r\n    }\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"name\", {\r\n        /**\r\n         * Gets the name of the behavior.\r\n         */\r\n        get: function () {\r\n            return \"AutoRotation\";\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"zoomStopsAnimation\", {\r\n        /**\r\n        * Gets the flag that indicates if user zooming should stop animation.\r\n        */\r\n        get: function () {\r\n            return this._zoomStopsAnimation;\r\n        },\r\n        /**\r\n        * Sets the flag that indicates if user zooming should stop animation.\r\n        */\r\n        set: function (flag) {\r\n            this._zoomStopsAnimation = flag;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpeed\", {\r\n        /**\r\n        * Gets the default speed at which the camera rotates around the model.\r\n        */\r\n        get: function () {\r\n            return this._idleRotationSpeed;\r\n        },\r\n        /**\r\n        * Sets the default speed at which the camera rotates around the model.\r\n        */\r\n        set: function (speed) {\r\n            this._idleRotationSpeed = speed;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationWaitTime\", {\r\n        /**\r\n        * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n        */\r\n        get: function () {\r\n            return this._idleRotationWaitTime;\r\n        },\r\n        /**\r\n        * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n        */\r\n        set: function (time) {\r\n            this._idleRotationWaitTime = time;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpinupTime\", {\r\n        /**\r\n        * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n        */\r\n        get: function () {\r\n            return this._idleRotationSpinupTime;\r\n        },\r\n        /**\r\n        * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n        */\r\n        set: function (time) {\r\n            this._idleRotationSpinupTime = time;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoRotationBehavior.prototype, \"rotationInProgress\", {\r\n        /**\r\n         * Gets a value indicating if the camera is currently rotating because of this behavior\r\n         */\r\n        get: function () {\r\n            return Math.abs(this._cameraRotationSpeed) > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    AutoRotationBehavior.prototype.init = function () {\r\n        // Do notihng\r\n    };\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    AutoRotationBehavior.prototype.attach = function (camera) {\r\n        var _this = this;\r\n        this._attachedCamera = camera;\r\n        var scene = this._attachedCamera.getScene();\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                _this._isPointerDown = true;\r\n                return;\r\n            }\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                _this._isPointerDown = false;\r\n            }\r\n        });\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\r\n            var now = PrecisionDate.Now;\r\n            var dt = 0;\r\n            if (_this._lastFrameTime != null) {\r\n                dt = now - _this._lastFrameTime;\r\n            }\r\n            _this._lastFrameTime = now;\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            _this._applyUserInteraction();\r\n            var timeToRotation = now - _this._lastInteractionTime - _this._idleRotationWaitTime;\r\n            var scale = Math.max(Math.min(timeToRotation / (_this._idleRotationSpinupTime), 1), 0);\r\n            _this._cameraRotationSpeed = _this._idleRotationSpeed * scale;\r\n            // Step camera rotation by rotation speed\r\n            if (_this._attachedCamera) {\r\n                _this._attachedCamera.alpha -= _this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    AutoRotationBehavior.prototype.detach = function () {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        var scene = this._attachedCamera.getScene();\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    };\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @return true if user is scrolling.\r\n     */\r\n    AutoRotationBehavior.prototype._userIsZooming = function () {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    };\r\n    AutoRotationBehavior.prototype._shouldAnimationStopForInteraction = function () {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        var zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    };\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    AutoRotationBehavior.prototype._applyUserInteraction = function () {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    };\r\n    // Tools\r\n    AutoRotationBehavior.prototype._userIsMoving = function () {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown;\r\n    };\r\n    return AutoRotationBehavior;\r\n}());\r\nexport { AutoRotationBehavior };\r\n//# sourceMappingURL=autoRotationBehavior.js.map","import { __extends } from \"tslib\";\r\nimport { BezierCurve } from \"../Maths/math.path\";\r\n/**\r\n * Base class used for every default easing function.\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar EasingFunction = /** @class */ (function () {\r\n    function EasingFunction() {\r\n        this._easingMode = EasingFunction.EASINGMODE_EASEIN;\r\n    }\r\n    /**\r\n     * Sets the easing mode of the current function.\r\n     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)\r\n     */\r\n    EasingFunction.prototype.setEasingMode = function (easingMode) {\r\n        var n = Math.min(Math.max(easingMode, 0), 2);\r\n        this._easingMode = n;\r\n    };\r\n    /**\r\n     * Gets the current easing mode.\r\n     * @returns the easing mode\r\n     */\r\n    EasingFunction.prototype.getEasingMode = function () {\r\n        return this._easingMode;\r\n    };\r\n    /**\r\n     * @hidden\r\n     */\r\n    EasingFunction.prototype.easeInCore = function (gradient) {\r\n        throw new Error('You must implement this method');\r\n    };\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    EasingFunction.prototype.ease = function (gradient) {\r\n        switch (this._easingMode) {\r\n            case EasingFunction.EASINGMODE_EASEIN:\r\n                return this.easeInCore(gradient);\r\n            case EasingFunction.EASINGMODE_EASEOUT:\r\n                return (1 - this.easeInCore(1 - gradient));\r\n        }\r\n        if (gradient >= 0.5) {\r\n            return (((1 - this.easeInCore((1 - gradient) * 2)) * 0.5) + 0.5);\r\n        }\r\n        return (this.easeInCore(gradient * 2) * 0.5);\r\n    };\r\n    /**\r\n     * Interpolation follows the mathematical formula associated with the easing function.\r\n     */\r\n    EasingFunction.EASINGMODE_EASEIN = 0;\r\n    /**\r\n     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.\r\n     */\r\n    EasingFunction.EASINGMODE_EASEOUT = 1;\r\n    /**\r\n     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.\r\n     */\r\n    EasingFunction.EASINGMODE_EASEINOUT = 2;\r\n    return EasingFunction;\r\n}());\r\nexport { EasingFunction };\r\n/**\r\n * Easing function with a circle shape (see link below).\r\n * @see https://easings.net/#easeInCirc\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar CircleEase = /** @class */ (function (_super) {\r\n    __extends(CircleEase, _super);\r\n    function CircleEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    CircleEase.prototype.easeInCore = function (gradient) {\r\n        gradient = Math.max(0, Math.min(1, gradient));\r\n        return (1.0 - Math.sqrt(1.0 - (gradient * gradient)));\r\n    };\r\n    return CircleEase;\r\n}(EasingFunction));\r\nexport { CircleEase };\r\n/**\r\n * Easing function with a ease back shape (see link below).\r\n * @see https://easings.net/#easeInBack\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar BackEase = /** @class */ (function (_super) {\r\n    __extends(BackEase, _super);\r\n    /**\r\n     * Instantiates a back ease easing\r\n     * @see https://easings.net/#easeInBack\r\n     * @param amplitude Defines the amplitude of the function\r\n     */\r\n    function BackEase(\r\n    /** Defines the amplitude of the function */\r\n    amplitude) {\r\n        if (amplitude === void 0) { amplitude = 1; }\r\n        var _this = _super.call(this) || this;\r\n        _this.amplitude = amplitude;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    BackEase.prototype.easeInCore = function (gradient) {\r\n        var num = Math.max(0, this.amplitude);\r\n        return (Math.pow(gradient, 3.0) - ((gradient * num) * Math.sin(3.1415926535897931 * gradient)));\r\n    };\r\n    return BackEase;\r\n}(EasingFunction));\r\nexport { BackEase };\r\n/**\r\n * Easing function with a bouncing shape (see link below).\r\n * @see https://easings.net/#easeInBounce\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar BounceEase = /** @class */ (function (_super) {\r\n    __extends(BounceEase, _super);\r\n    /**\r\n     * Instantiates a bounce easing\r\n     * @see https://easings.net/#easeInBounce\r\n     * @param bounces Defines the number of bounces\r\n     * @param bounciness Defines the amplitude of the bounce\r\n     */\r\n    function BounceEase(\r\n    /** Defines the number of bounces */\r\n    bounces, \r\n    /** Defines the amplitude of the bounce */\r\n    bounciness) {\r\n        if (bounces === void 0) { bounces = 3; }\r\n        if (bounciness === void 0) { bounciness = 2; }\r\n        var _this = _super.call(this) || this;\r\n        _this.bounces = bounces;\r\n        _this.bounciness = bounciness;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    BounceEase.prototype.easeInCore = function (gradient) {\r\n        var y = Math.max(0.0, this.bounces);\r\n        var bounciness = this.bounciness;\r\n        if (bounciness <= 1.0) {\r\n            bounciness = 1.001;\r\n        }\r\n        var num9 = Math.pow(bounciness, y);\r\n        var num5 = 1.0 - bounciness;\r\n        var num4 = ((1.0 - num9) / num5) + (num9 * 0.5);\r\n        var num15 = gradient * num4;\r\n        var num65 = Math.log((-num15 * (1.0 - bounciness)) + 1.0) / Math.log(bounciness);\r\n        var num3 = Math.floor(num65);\r\n        var num13 = num3 + 1.0;\r\n        var num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\r\n        var num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\r\n        var num7 = (num8 + num12) * 0.5;\r\n        var num6 = gradient - num7;\r\n        var num2 = num7 - num8;\r\n        return (((-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2)) * (num6 + num2));\r\n    };\r\n    return BounceEase;\r\n}(EasingFunction));\r\nexport { BounceEase };\r\n/**\r\n * Easing function with a power of 3 shape (see link below).\r\n * @see https://easings.net/#easeInCubic\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar CubicEase = /** @class */ (function (_super) {\r\n    __extends(CubicEase, _super);\r\n    function CubicEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    CubicEase.prototype.easeInCore = function (gradient) {\r\n        return (gradient * gradient * gradient);\r\n    };\r\n    return CubicEase;\r\n}(EasingFunction));\r\nexport { CubicEase };\r\n/**\r\n * Easing function with an elastic shape (see link below).\r\n * @see https://easings.net/#easeInElastic\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar ElasticEase = /** @class */ (function (_super) {\r\n    __extends(ElasticEase, _super);\r\n    /**\r\n     * Instantiates an elastic easing function\r\n     * @see https://easings.net/#easeInElastic\r\n     * @param oscillations Defines the number of oscillations\r\n     * @param springiness Defines the amplitude of the oscillations\r\n     */\r\n    function ElasticEase(\r\n    /** Defines the number of oscillations*/\r\n    oscillations, \r\n    /** Defines the amplitude of the oscillations*/\r\n    springiness) {\r\n        if (oscillations === void 0) { oscillations = 3; }\r\n        if (springiness === void 0) { springiness = 3; }\r\n        var _this = _super.call(this) || this;\r\n        _this.oscillations = oscillations;\r\n        _this.springiness = springiness;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    ElasticEase.prototype.easeInCore = function (gradient) {\r\n        var num2;\r\n        var num3 = Math.max(0.0, this.oscillations);\r\n        var num = Math.max(0.0, this.springiness);\r\n        if (num == 0) {\r\n            num2 = gradient;\r\n        }\r\n        else {\r\n            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\r\n        }\r\n        return (num2 * Math.sin(((6.2831853071795862 * num3) + 1.5707963267948966) * gradient));\r\n    };\r\n    return ElasticEase;\r\n}(EasingFunction));\r\nexport { ElasticEase };\r\n/**\r\n * Easing function with an exponential shape (see link below).\r\n * @see https://easings.net/#easeInExpo\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar ExponentialEase = /** @class */ (function (_super) {\r\n    __extends(ExponentialEase, _super);\r\n    /**\r\n     * Instantiates an exponential easing function\r\n     * @see https://easings.net/#easeInExpo\r\n     * @param exponent Defines the exponent of the function\r\n     */\r\n    function ExponentialEase(\r\n    /** Defines the exponent of the function */\r\n    exponent) {\r\n        if (exponent === void 0) { exponent = 2; }\r\n        var _this = _super.call(this) || this;\r\n        _this.exponent = exponent;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    ExponentialEase.prototype.easeInCore = function (gradient) {\r\n        if (this.exponent <= 0) {\r\n            return gradient;\r\n        }\r\n        return ((Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0));\r\n    };\r\n    return ExponentialEase;\r\n}(EasingFunction));\r\nexport { ExponentialEase };\r\n/**\r\n * Easing function with a power shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar PowerEase = /** @class */ (function (_super) {\r\n    __extends(PowerEase, _super);\r\n    /**\r\n     * Instantiates an power base easing function\r\n     * @see https://easings.net/#easeInQuad\r\n     * @param power Defines the power of the function\r\n     */\r\n    function PowerEase(\r\n    /** Defines the power of the function */\r\n    power) {\r\n        if (power === void 0) { power = 2; }\r\n        var _this = _super.call(this) || this;\r\n        _this.power = power;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    PowerEase.prototype.easeInCore = function (gradient) {\r\n        var y = Math.max(0.0, this.power);\r\n        return Math.pow(gradient, y);\r\n    };\r\n    return PowerEase;\r\n}(EasingFunction));\r\nexport { PowerEase };\r\n/**\r\n * Easing function with a power of 2 shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar QuadraticEase = /** @class */ (function (_super) {\r\n    __extends(QuadraticEase, _super);\r\n    function QuadraticEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    QuadraticEase.prototype.easeInCore = function (gradient) {\r\n        return (gradient * gradient);\r\n    };\r\n    return QuadraticEase;\r\n}(EasingFunction));\r\nexport { QuadraticEase };\r\n/**\r\n * Easing function with a power of 4 shape (see link below).\r\n * @see https://easings.net/#easeInQuart\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar QuarticEase = /** @class */ (function (_super) {\r\n    __extends(QuarticEase, _super);\r\n    function QuarticEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    QuarticEase.prototype.easeInCore = function (gradient) {\r\n        return (gradient * gradient * gradient * gradient);\r\n    };\r\n    return QuarticEase;\r\n}(EasingFunction));\r\nexport { QuarticEase };\r\n/**\r\n * Easing function with a power of 5 shape (see link below).\r\n * @see https://easings.net/#easeInQuint\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar QuinticEase = /** @class */ (function (_super) {\r\n    __extends(QuinticEase, _super);\r\n    function QuinticEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    QuinticEase.prototype.easeInCore = function (gradient) {\r\n        return (gradient * gradient * gradient * gradient * gradient);\r\n    };\r\n    return QuinticEase;\r\n}(EasingFunction));\r\nexport { QuinticEase };\r\n/**\r\n * Easing function with a sin shape (see link below).\r\n * @see https://easings.net/#easeInSine\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar SineEase = /** @class */ (function (_super) {\r\n    __extends(SineEase, _super);\r\n    function SineEase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /** @hidden */\r\n    SineEase.prototype.easeInCore = function (gradient) {\r\n        return (1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient)));\r\n    };\r\n    return SineEase;\r\n}(EasingFunction));\r\nexport { SineEase };\r\n/**\r\n * Easing function with a bezier shape (see link below).\r\n * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n * @see https://doc.babylonjs.com/babylon101/animations#easing-functions\r\n */\r\nvar BezierCurveEase = /** @class */ (function (_super) {\r\n    __extends(BezierCurveEase, _super);\r\n    /**\r\n     * Instantiates a bezier function\r\n     * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n     * @param x1 Defines the x component of the start tangent in the bezier curve\r\n     * @param y1 Defines the y component of the start tangent in the bezier curve\r\n     * @param x2 Defines the x component of the end tangent in the bezier curve\r\n     * @param y2 Defines the y component of the end tangent in the bezier curve\r\n     */\r\n    function BezierCurveEase(\r\n    /** Defines the x component of the start tangent in the bezier curve */\r\n    x1, \r\n    /** Defines the y component of the start tangent in the bezier curve */\r\n    y1, \r\n    /** Defines the x component of the end tangent in the bezier curve */\r\n    x2, \r\n    /** Defines the y component of the end tangent in the bezier curve */\r\n    y2) {\r\n        if (x1 === void 0) { x1 = 0; }\r\n        if (y1 === void 0) { y1 = 0; }\r\n        if (x2 === void 0) { x2 = 1; }\r\n        if (y2 === void 0) { y2 = 1; }\r\n        var _this = _super.call(this) || this;\r\n        _this.x1 = x1;\r\n        _this.y1 = y1;\r\n        _this.x2 = x2;\r\n        _this.y2 = y2;\r\n        return _this;\r\n    }\r\n    /** @hidden */\r\n    BezierCurveEase.prototype.easeInCore = function (gradient) {\r\n        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\r\n    };\r\n    return BezierCurveEase;\r\n}(EasingFunction));\r\nexport { BezierCurveEase };\r\n//# sourceMappingURL=easing.js.map","import { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\r\nvar BouncingBehavior = /** @class */ (function () {\r\n    function BouncingBehavior() {\r\n        /**\r\n         * The duration of the animation, in milliseconds\r\n         */\r\n        this.transitionDuration = 450;\r\n        /**\r\n         * Length of the distance animated by the transition when lower radius is reached\r\n         */\r\n        this.lowerRadiusTransitionRange = 2;\r\n        /**\r\n         * Length of the distance animated by the transition when upper radius is reached\r\n         */\r\n        this.upperRadiusTransitionRange = -2;\r\n        this._autoTransitionRange = false;\r\n        // Animations\r\n        this._radiusIsAnimating = false;\r\n        this._radiusBounceTransition = null;\r\n        this._animatables = new Array();\r\n    }\r\n    Object.defineProperty(BouncingBehavior.prototype, \"name\", {\r\n        /**\r\n         * Gets the name of the behavior.\r\n         */\r\n        get: function () {\r\n            return \"Bouncing\";\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BouncingBehavior.prototype, \"autoTransitionRange\", {\r\n        /**\r\n         * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n         */\r\n        get: function () {\r\n            return this._autoTransitionRange;\r\n        },\r\n        /**\r\n         * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n         * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n         */\r\n        set: function (value) {\r\n            var _this = this;\r\n            if (this._autoTransitionRange === value) {\r\n                return;\r\n            }\r\n            this._autoTransitionRange = value;\r\n            var camera = this._attachedCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            if (value) {\r\n                this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\r\n                    if (!mesh) {\r\n                        return;\r\n                    }\r\n                    mesh.computeWorldMatrix(true);\r\n                    var diagonal = mesh.getBoundingInfo().diagonalLength;\r\n                    _this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                    _this.upperRadiusTransitionRange = diagonal * 0.05;\r\n                });\r\n            }\r\n            else if (this._onMeshTargetChangedObserver) {\r\n                camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    BouncingBehavior.prototype.init = function () {\r\n        // Do notihng\r\n    };\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    BouncingBehavior.prototype.attach = function (camera) {\r\n        var _this = this;\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\r\n            if (!_this._attachedCamera) {\r\n                return;\r\n            }\r\n            // Add the bounce animation to the lower radius limit\r\n            if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {\r\n                _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);\r\n            }\r\n            // Add the bounce animation to the upper radius limit\r\n            if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {\r\n                _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    BouncingBehavior.prototype.detach = function () {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    };\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @return Bool to indicate if at limit.\r\n     */\r\n    BouncingBehavior.prototype._isRadiusAtLimit = function (radiusLimit) {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    BouncingBehavior.prototype._applyBoundRadiusAnimation = function (radiusDelta) {\r\n        var _this = this;\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        var animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () { return _this._clearAnimationLocks(); });\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    };\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    BouncingBehavior.prototype._clearAnimationLocks = function () {\r\n        this._radiusIsAnimating = false;\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    };\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    BouncingBehavior.prototype.stopAllAnimations = function () {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    };\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    BouncingBehavior.EasingFunction = new BackEase(0.3);\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n    return BouncingBehavior;\r\n}());\r\nexport { BouncingBehavior };\r\n//# sourceMappingURL=bouncingBehavior.js.map","import { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\r\nvar FramingBehavior = /** @class */ (function () {\r\n    function FramingBehavior() {\r\n        this._mode = FramingBehavior.FitFrustumSidesMode;\r\n        this._radiusScale = 1.0;\r\n        this._positionScale = 0.5;\r\n        this._defaultElevation = 0.3;\r\n        this._elevationReturnTime = 1500;\r\n        this._elevationReturnWaitTime = 1000;\r\n        this._zoomStopsAnimation = false;\r\n        this._framingTime = 1500;\r\n        /**\r\n         * Define if the behavior should automatically change the configured\r\n         * camera limits and sensibilities.\r\n         */\r\n        this.autoCorrectCameraLimitsAndSensibility = true;\r\n        this._isPointerDown = false;\r\n        this._lastInteractionTime = -Infinity;\r\n        // Framing control\r\n        this._animatables = new Array();\r\n        this._betaIsAnimating = false;\r\n    }\r\n    Object.defineProperty(FramingBehavior.prototype, \"name\", {\r\n        /**\r\n         * Gets the name of the behavior.\r\n         */\r\n        get: function () {\r\n            return \"Framing\";\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"mode\", {\r\n        /**\r\n         * Gets current mode used by the behavior.\r\n         */\r\n        get: function () {\r\n            return this._mode;\r\n        },\r\n        /**\r\n         * Sets the current mode used by the behavior\r\n         */\r\n        set: function (mode) {\r\n            this._mode = mode;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"radiusScale\", {\r\n        /**\r\n         * Gets the scale applied to the radius\r\n         */\r\n        get: function () {\r\n            return this._radiusScale;\r\n        },\r\n        /**\r\n         * Sets the scale applied to the radius (1 by default)\r\n         */\r\n        set: function (radius) {\r\n            this._radiusScale = radius;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"positionScale\", {\r\n        /**\r\n         * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n         */\r\n        get: function () {\r\n            return this._positionScale;\r\n        },\r\n        /**\r\n         * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n         */\r\n        set: function (scale) {\r\n            this._positionScale = scale;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"defaultElevation\", {\r\n        /**\r\n        * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n        * behaviour is triggered, in radians.\r\n        */\r\n        get: function () {\r\n            return this._defaultElevation;\r\n        },\r\n        /**\r\n        * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n        * behaviour is triggered, in radians.\r\n        */\r\n        set: function (elevation) {\r\n            this._defaultElevation = elevation;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"elevationReturnTime\", {\r\n        /**\r\n         * Gets the time (in milliseconds) taken to return to the default beta position.\r\n         * Negative value indicates camera should not return to default.\r\n         */\r\n        get: function () {\r\n            return this._elevationReturnTime;\r\n        },\r\n        /**\r\n         * Sets the time (in milliseconds) taken to return to the default beta position.\r\n         * Negative value indicates camera should not return to default.\r\n         */\r\n        set: function (speed) {\r\n            this._elevationReturnTime = speed;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"elevationReturnWaitTime\", {\r\n        /**\r\n         * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n         */\r\n        get: function () {\r\n            return this._elevationReturnWaitTime;\r\n        },\r\n        /**\r\n         * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n         */\r\n        set: function (time) {\r\n            this._elevationReturnWaitTime = time;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"zoomStopsAnimation\", {\r\n        /**\r\n        * Gets the flag that indicates if user zooming should stop animation.\r\n        */\r\n        get: function () {\r\n            return this._zoomStopsAnimation;\r\n        },\r\n        /**\r\n        * Sets the flag that indicates if user zooming should stop animation.\r\n        */\r\n        set: function (flag) {\r\n            this._zoomStopsAnimation = flag;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FramingBehavior.prototype, \"framingTime\", {\r\n        /**\r\n         * Gets the transition time when framing the mesh, in milliseconds\r\n        */\r\n        get: function () {\r\n            return this._framingTime;\r\n        },\r\n        /**\r\n         * Sets the transition time when framing the mesh, in milliseconds\r\n        */\r\n        set: function (time) {\r\n            this._framingTime = time;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    FramingBehavior.prototype.init = function () {\r\n        // Do notihng\r\n    };\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    FramingBehavior.prototype.attach = function (camera) {\r\n        var _this = this;\r\n        this._attachedCamera = camera;\r\n        var scene = this._attachedCamera.getScene();\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                _this._isPointerDown = true;\r\n                return;\r\n            }\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                _this._isPointerDown = false;\r\n            }\r\n        });\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\r\n            if (mesh) {\r\n                _this.zoomOnMesh(mesh);\r\n            }\r\n        });\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            _this._applyUserInteraction();\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            _this._maintainCameraAboveGround();\r\n        });\r\n    };\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    FramingBehavior.prototype.detach = function () {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        var scene = this._attachedCamera.getScene();\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    };\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    FramingBehavior.prototype.zoomOnMesh = function (mesh, focusOnOriginXZ, onAnimationEnd) {\r\n        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }\r\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\r\n        mesh.computeWorldMatrix(true);\r\n        var boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    FramingBehavior.prototype.zoomOnMeshHierarchy = function (mesh, focusOnOriginXZ, onAnimationEnd) {\r\n        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }\r\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\r\n        mesh.computeWorldMatrix(true);\r\n        var boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    FramingBehavior.prototype.zoomOnMeshesHierarchy = function (meshes, focusOnOriginXZ, onAnimationEnd) {\r\n        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }\r\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\r\n        var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n        for (var i = 0; i < meshes.length; i++) {\r\n            var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    };\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    FramingBehavior.prototype.zoomOnBoundingInfo = function (minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {\r\n        var _this = this;\r\n        if (focusOnOriginXZ === void 0) { focusOnOriginXZ = false; }\r\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\r\n        var zoomTarget;\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        var bottom = minimumWorld.y;\r\n        var top = maximumWorld.y;\r\n        var zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        }\r\n        else {\r\n            var centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n        this._betaIsAnimating = true;\r\n        var animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        var radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        }\r\n        else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            var extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {\r\n            _this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {\r\n                _this._attachedCamera.storeState();\r\n            }\r\n        });\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    };\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary\r\n     *\t\t\t  frustum width.\r\n     * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    FramingBehavior.prototype._calculateLowerRadiusFromModelBoundingSphere = function (minimumWorld, maximumWorld) {\r\n        var size = maximumWorld.subtract(minimumWorld);\r\n        var boxVectorGlobalDiagonal = size.length();\r\n        var frustumSlope = this._getFrustumSlope();\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n        // Horizon distance\r\n        var radius = radiusWithoutFraming * this._radiusScale;\r\n        var distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\r\n        var distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\r\n        var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n        var camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n        return distance;\r\n    };\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    FramingBehavior.prototype._maintainCameraAboveGround = function () {\r\n        var _this = this;\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n        var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        var defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        var limitBeta = Math.PI * 0.5;\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n            var animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {\r\n                _this._clearAnimationLocks();\r\n                _this.stopAllAnimations();\r\n            });\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns the frustum slope based on the canvas ratio and camera FOV\r\n     * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n     */\r\n    FramingBehavior.prototype._getFrustumSlope = function () {\r\n        // Calculate the viewport ratio\r\n        // Aspect Ratio is Height/Width.\r\n        var camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return Vector2.Zero();\r\n        }\r\n        var engine = camera.getScene().getEngine();\r\n        var aspectRatio = engine.getAspectRatio(camera);\r\n        // Camera FOV is the vertical field of view (top-bottom) in radians.\r\n        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\r\n        var frustumSlopeY = Math.tan(camera.fov / 2);\r\n        // Slope of the frustum left/right planes in view space, relative to the forward vector.\r\n        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\r\n        // along the forward vector.\r\n        var frustumSlopeX = frustumSlopeY * aspectRatio;\r\n        return new Vector2(frustumSlopeX, frustumSlopeY);\r\n    };\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    FramingBehavior.prototype._clearAnimationLocks = function () {\r\n        this._betaIsAnimating = false;\r\n    };\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    FramingBehavior.prototype._applyUserInteraction = function () {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    };\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    FramingBehavior.prototype.stopAllAnimations = function () {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    };\r\n    Object.defineProperty(FramingBehavior.prototype, \"isUserIsMoving\", {\r\n        /**\r\n         * Gets a value indicating if the user is moving the camera\r\n         */\r\n        get: function () {\r\n            if (!this._attachedCamera) {\r\n                return false;\r\n            }\r\n            return this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n                this._attachedCamera.inertialBetaOffset !== 0 ||\r\n                this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n                this._attachedCamera.inertialPanningX !== 0 ||\r\n                this._attachedCamera.inertialPanningY !== 0 ||\r\n                this._isPointerDown;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    FramingBehavior.EasingFunction = new ExponentialEase();\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n    // Statics\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    FramingBehavior.IgnoreBoundsSizeMode = 0;\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    FramingBehavior.FitFrustumSidesMode = 1;\r\n    return FramingBehavior;\r\n}());\r\nexport { FramingBehavior };\r\n//# sourceMappingURL=framingBehavior.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Camera } from \"./camera\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from '../Maths/math.constants';\r\nimport { Axis } from '../Maths/math.axis';\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nvar TargetCamera = /** @class */ (function (_super) {\r\n    __extends(TargetCamera, _super);\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    function TargetCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\r\n        if (setActiveOnSceneIfNoneActive === void 0) { setActiveOnSceneIfNoneActive = true; }\r\n        var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\r\n        _this._tmpUpVector = Vector3.Zero();\r\n        _this._tmpTargetVector = Vector3.Zero();\r\n        /**\r\n         * Define the current direction the camera is moving to\r\n         */\r\n        _this.cameraDirection = new Vector3(0, 0, 0);\r\n        /**\r\n         * Define the current rotation the camera is rotating to\r\n         */\r\n        _this.cameraRotation = new Vector2(0, 0);\r\n        /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n        _this.ignoreParentScaling = false;\r\n        /**\r\n         * When set, the up vector of the camera will be updated by the rotation of the camera\r\n         */\r\n        _this.updateUpVectorFromRotation = false;\r\n        _this._tmpQuaternion = new Quaternion();\r\n        /**\r\n         * Define the current rotation of the camera\r\n         */\r\n        _this.rotation = new Vector3(0, 0, 0);\r\n        /**\r\n         * Define the current speed of the camera\r\n         */\r\n        _this.speed = 2.0;\r\n        /**\r\n         * Add constraint to the camera to prevent it to move freely in all directions and\r\n         * around all axis.\r\n         */\r\n        _this.noRotationConstraint = false;\r\n        /**\r\n         * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n         * panning\r\n         */\r\n        _this.invertRotation = false;\r\n        /**\r\n         * Speed multiplier for inverse camera panning\r\n         */\r\n        _this.inverseRotationSpeed = 0.2;\r\n        /**\r\n         * Define the current target of the camera as an object or a position.\r\n         */\r\n        _this.lockedTarget = null;\r\n        /** @hidden */\r\n        _this._currentTarget = Vector3.Zero();\r\n        /** @hidden */\r\n        _this._initialFocalDistance = 1;\r\n        /** @hidden */\r\n        _this._viewMatrix = Matrix.Zero();\r\n        /** @hidden */\r\n        _this._camMatrix = Matrix.Zero();\r\n        /** @hidden */\r\n        _this._cameraTransformMatrix = Matrix.Zero();\r\n        /** @hidden */\r\n        _this._cameraRotationMatrix = Matrix.Zero();\r\n        /** @hidden */\r\n        _this._referencePoint = new Vector3(0, 0, 1);\r\n        /** @hidden */\r\n        _this._transformedReferencePoint = Vector3.Zero();\r\n        _this._defaultUp = Vector3.Up();\r\n        _this._cachedRotationZ = 0;\r\n        _this._cachedQuaternionRotationZ = 0;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    TargetCamera.prototype.getFrontPosition = function (distance) {\r\n        this.getWorldMatrix();\r\n        var direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._getLockedTargetPosition = function () {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    };\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    TargetCamera.prototype.storeState = function () {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        return _super.prototype.storeState.call(this);\r\n    };\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @hidden\r\n     */\r\n    TargetCamera.prototype._restoreStateValues = function () {\r\n        if (!_super.prototype._restoreStateValues.call(this)) {\r\n            return false;\r\n        }\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n        return true;\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._initCache = function () {\r\n        _super.prototype._initCache.call(this);\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._updateCache = function (ignoreParentClass) {\r\n        if (!ignoreParentClass) {\r\n            _super.prototype._updateCache.call(this);\r\n        }\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        }\r\n        else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            }\r\n            else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    };\r\n    // Synchronized\r\n    /** @hidden */\r\n    TargetCamera.prototype._isSynchronizedViewMatrix = function () {\r\n        if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\r\n            return false;\r\n        }\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)\r\n            && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\r\n    };\r\n    // Methods\r\n    /** @hidden */\r\n    TargetCamera.prototype._computeLocalCameraSpeed = function () {\r\n        var engine = this.getEngine();\r\n        return this.speed * Math.sqrt((engine.getDeltaTime() / (engine.getFps() * 100.0)));\r\n    };\r\n    // Target\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     */\r\n    TargetCamera.prototype.setTarget = function (target) {\r\n        this.upVector.normalize();\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n        var vDir = target.subtract(this.position);\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);\r\n        }\r\n        else {\r\n            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);\r\n        }\r\n        this.rotation.z = 0;\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    };\r\n    Object.defineProperty(TargetCamera.prototype, \"target\", {\r\n        /**\r\n         * Defines the target point of the camera.\r\n         * The camera looks towards it form the radius distance.\r\n         */\r\n        get: function () {\r\n            return this.getTarget();\r\n        },\r\n        set: function (value) {\r\n            this.setTarget(value);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    TargetCamera.prototype.getTarget = function () {\r\n        return this._currentTarget;\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._decideIfNeedsToMove = function () {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._updatePosition = function () {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._checkInputs = function () {\r\n        var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        var needToMove = this._decideIfNeedsToMove();\r\n        var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                var limit = 1.570796;\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                var len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n        _super.prototype._checkInputs.call(this);\r\n    };\r\n    TargetCamera.prototype._updateCameraRotationMatrix = function () {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        }\r\n        else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    };\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    TargetCamera.prototype._rotateUpVectorWithCameraRotationMatrix = function () {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    TargetCamera.prototype._getViewMatrix = function () {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition());\r\n        }\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        }\r\n        else if (this._cachedRotationZ != this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            }\r\n            else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    };\r\n    TargetCamera.prototype._computeViewMatrix = function (position, target, up) {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                var parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            }\r\n            else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n        else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n        if (this.parent) {\r\n            var parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        }\r\n        else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    };\r\n    /**\r\n     * @hidden\r\n     */\r\n    TargetCamera.prototype.createRigCamera = function (name, cameraIndex) {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * @hidden\r\n     */\r\n    TargetCamera.prototype._updateRigCameras = function () {\r\n        var camLeft = this._rigCameras[0];\r\n        var camRight = this._rigCameras[1];\r\n        this.computeWorldMatrix();\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                var leftSign = (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? 1 : -1;\r\n                var rightSign = (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                }\r\n                else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n                break;\r\n        }\r\n        _super.prototype._updateRigCameras.call(this);\r\n    };\r\n    TargetCamera.prototype._getRigCamPositionAndTarget = function (halfSpace, rigCamera) {\r\n        var target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        var newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    };\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    TargetCamera.prototype.getClassName = function () {\r\n        return \"TargetCamera\";\r\n    };\r\n    TargetCamera._RigCamTransformMatrix = new Matrix();\r\n    TargetCamera._TargetTransformMatrix = new Matrix();\r\n    TargetCamera._TargetFocalPoint = new Vector3();\r\n    __decorate([\r\n        serializeAsVector3()\r\n    ], TargetCamera.prototype, \"rotation\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], TargetCamera.prototype, \"speed\", void 0);\r\n    __decorate([\r\n        serializeAsMeshReference(\"lockedTargetId\")\r\n    ], TargetCamera.prototype, \"lockedTarget\", void 0);\r\n    return TargetCamera;\r\n}(Camera));\r\nexport { TargetCamera };\r\n//# sourceMappingURL=targetCamera.js.map","import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\nexport var CameraInputTypes = {};\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nvar CameraInputsManager = /** @class */ (function () {\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager blongs to\r\n     */\r\n    function CameraInputsManager(camera) {\r\n        /**\r\n         * Defines the dom element the camera is collecting inputs from.\r\n         * This is null if the controls have not been attached.\r\n         */\r\n        this.attachedToElement = false;\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = function () { };\r\n    }\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param input camera input method\r\n     */\r\n    CameraInputsManager.prototype.add = function (input) {\r\n        var type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n        this.attached[type] = input;\r\n        input.camera = this.camera;\r\n        //for checkInputs, we are dynamically creating a function\r\n        //the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n        if (this.attachedToElement) {\r\n            input.attachControl();\r\n        }\r\n    };\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    CameraInputsManager.prototype.remove = function (inputToRemove) {\r\n        for (var cam in this.attached) {\r\n            var input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    CameraInputsManager.prototype.removeByType = function (inputType) {\r\n        for (var cam in this.attached) {\r\n            var input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    };\r\n    CameraInputsManager.prototype._addCheckInputs = function (fn) {\r\n        var current = this.checkInputs;\r\n        return function () {\r\n            current();\r\n            fn();\r\n        };\r\n    };\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    CameraInputsManager.prototype.attachInput = function (input) {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    };\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param element Defines the dom element to collect the events from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    CameraInputsManager.prototype.attachElement = function (noPreventDefault) {\r\n        if (noPreventDefault === void 0) { noPreventDefault = false; }\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n        for (var cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    };\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param element Defines the dom element to collect the events from\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    CameraInputsManager.prototype.detachElement = function (disconnect) {\r\n        if (disconnect === void 0) { disconnect = false; }\r\n        for (var cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    };\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    CameraInputsManager.prototype.rebuildInputCheck = function () {\r\n        this.checkInputs = function () { };\r\n        for (var cam in this.attached) {\r\n            var input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    CameraInputsManager.prototype.clear = function () {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = function () { };\r\n    };\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    CameraInputsManager.prototype.serialize = function (serializedCamera) {\r\n        var inputs = {};\r\n        for (var cam in this.attached) {\r\n            var input = this.attached[cam];\r\n            var res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n        serializedCamera.inputsmgr = inputs;\r\n    };\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    CameraInputsManager.prototype.parse = function (parsedCamera) {\r\n        var parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n            for (var n in parsedInputs) {\r\n                var construct = CameraInputTypes[n];\r\n                if (construct) {\r\n                    var parsedinput = parsedInputs[n];\r\n                    var input = SerializationHelper.Parse(function () {\r\n                        return new construct();\r\n                    }, parsedinput, null);\r\n                    this.add(input);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (var n in this.attached) {\r\n                var construct = CameraInputTypes[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    var input = SerializationHelper.Parse(function () {\r\n                        return new construct();\r\n                    }, parsedCamera, null);\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return CameraInputsManager;\r\n}());\r\nexport { CameraInputsManager };\r\n//# sourceMappingURL=cameraInputsManager.js.map","import { __decorate } from \"tslib\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nvar BaseCameraPointersInput = /** @class */ (function () {\r\n    function BaseCameraPointersInput() {\r\n        /**\r\n         * Defines the buttons associated with the input to handle camera move.\r\n         */\r\n        this.buttons = [0, 1, 2];\r\n    }\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param element Defines the element the controls should be listened from\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    BaseCameraPointersInput.prototype.attachControl = function (noPreventDefault) {\r\n        var _this = this;\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        var engine = this.camera.getEngine();\r\n        var element = engine.getInputElement();\r\n        var previousPinchSquaredDistance = 0;\r\n        var previousMultiTouchPanPosition = null;\r\n        this.pointA = null;\r\n        this.pointB = null;\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._pointerInput = function (p, s) {\r\n            var evt = p.event;\r\n            var isTouch = evt.pointerType === \"touch\";\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n            if (p.type !== PointerEventTypes.POINTERMOVE &&\r\n                _this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n            var srcElement = (evt.srcElement || evt.target);\r\n            _this._altKey = evt.altKey;\r\n            _this._ctrlKey = evt.ctrlKey;\r\n            _this._metaKey = evt.metaKey;\r\n            _this._shiftKey = evt.shiftKey;\r\n            _this._buttonsPressed = evt.buttons;\r\n            if (engine.isPointerLock) {\r\n                var offsetX = evt.movementX ||\r\n                    evt.mozMovementX ||\r\n                    evt.webkitMovementX ||\r\n                    evt.msMovementX ||\r\n                    0;\r\n                var offsetY = evt.movementY ||\r\n                    evt.mozMovementY ||\r\n                    evt.webkitMovementY ||\r\n                    evt.msMovementY ||\r\n                    0;\r\n                _this.onTouch(null, offsetX, offsetY);\r\n                _this.pointA = null;\r\n                _this.pointB = null;\r\n            }\r\n            else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\r\n                try {\r\n                    srcElement.setPointerCapture(evt.pointerId);\r\n                }\r\n                catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n                if (_this.pointA === null) {\r\n                    _this.pointA = { x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType };\r\n                }\r\n                else if (_this.pointB === null) {\r\n                    _this.pointB = { x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType };\r\n                }\r\n                _this.onButtonDown(evt);\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            }\r\n            else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                _this.onDoubleTap(evt.pointerType);\r\n            }\r\n            else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\r\n                try {\r\n                    srcElement.releasePointerCapture(evt.pointerId);\r\n                }\r\n                catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n                if (!isTouch) {\r\n                    _this.pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    _this.pointA = _this.pointB = null;\r\n                }\r\n                else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (_this.pointB && _this.pointA && _this.pointA.pointerId == evt.pointerId) {\r\n                        _this.pointA = _this.pointB;\r\n                        _this.pointB = null;\r\n                    }\r\n                    else if (_this.pointA && _this.pointB &&\r\n                        _this.pointB.pointerId == evt.pointerId) {\r\n                        _this.pointB = null;\r\n                    }\r\n                    else {\r\n                        _this.pointA = _this.pointB = null;\r\n                    }\r\n                }\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, 0, // pinchSquaredDistance\r\n                    previousMultiTouchPanPosition, null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n                _this.onButtonUp(evt);\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            }\r\n            else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n                // One button down\r\n                if (_this.pointA && _this.pointB === null) {\r\n                    var offsetX = evt.clientX - _this.pointA.x;\r\n                    var offsetY = evt.clientY - _this.pointA.y;\r\n                    _this.onTouch(_this.pointA, offsetX, offsetY);\r\n                    _this.pointA.x = evt.clientX;\r\n                    _this.pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (_this.pointA && _this.pointB) {\r\n                    var ed = (_this.pointA.pointerId === evt.pointerId) ?\r\n                        _this.pointA : _this.pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    var distX = _this.pointA.x - _this.pointB.x;\r\n                    var distY = _this.pointA.y - _this.pointB.y;\r\n                    var pinchSquaredDistance = (distX * distX) + (distY * distY);\r\n                    var multiTouchPanPosition = { x: (_this.pointA.x + _this.pointB.x) / 2,\r\n                        y: (_this.pointA.y + _this.pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type };\r\n                    _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP |\r\n            PointerEventTypes.POINTERMOVE);\r\n        this._onLostFocus = function () {\r\n            _this.pointA = _this.pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            _this.onLostFocus();\r\n        };\r\n        element && element.addEventListener(\"contextmenu\", this.onContextMenu.bind(this), false);\r\n        var hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [\r\n                { name: \"blur\", handler: this._onLostFocus }\r\n            ]);\r\n        }\r\n    };\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    BaseCameraPointersInput.prototype.detachControl = function (ignored) {\r\n        if (this._onLostFocus) {\r\n            var hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [\r\n                    { name: \"blur\", handler: this._onLostFocus }\r\n                ]);\r\n            }\r\n        }\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            if (this.onContextMenu) {\r\n                var inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this.onContextMenu);\r\n            }\r\n            this._onLostFocus = null;\r\n        }\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n    };\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    BaseCameraPointersInput.prototype.getClassName = function () {\r\n        return \"BaseCameraPointersInput\";\r\n    };\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    BaseCameraPointersInput.prototype.getSimpleName = function () {\r\n        return \"pointers\";\r\n    };\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     */\r\n    BaseCameraPointersInput.prototype.onDoubleTap = function (type) {\r\n    };\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {\r\n    };\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\r\n    };\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onContextMenu = function (evt) {\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onButtonDown = function (evt) {\r\n    };\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onButtonUp = function (evt) {\r\n    };\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    BaseCameraPointersInput.prototype.onLostFocus = function () {\r\n    };\r\n    __decorate([\r\n        serialize()\r\n    ], BaseCameraPointersInput.prototype, \"buttons\", void 0);\r\n    return BaseCameraPointersInput;\r\n}());\r\nexport { BaseCameraPointersInput };\r\n//# sourceMappingURL=BaseCameraPointersInput.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nvar ArcRotateCameraPointersInput = /** @class */ (function (_super) {\r\n    __extends(ArcRotateCameraPointersInput, _super);\r\n    function ArcRotateCameraPointersInput() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * Defines the buttons associated with the input to handle camera move.\r\n         */\r\n        _this.buttons = [0, 1, 2];\r\n        /**\r\n         * Defines the pointer angular sensibility  along the X axis or how fast is\r\n         * the camera rotating.\r\n         */\r\n        _this.angularSensibilityX = 1000.0;\r\n        /**\r\n         * Defines the pointer angular sensibility along the Y axis or how fast is\r\n         * the camera rotating.\r\n         */\r\n        _this.angularSensibilityY = 1000.0;\r\n        /**\r\n         * Defines the pointer pinch precision or how fast is the camera zooming.\r\n         */\r\n        _this.pinchPrecision = 12.0;\r\n        /**\r\n         * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n         * from 0.\r\n         * It defines the percentage of current camera.radius to use as delta when\r\n         * pinch zoom is used.\r\n         */\r\n        _this.pinchDeltaPercentage = 0;\r\n        /**\r\n         * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n         * that any object in the plane at the camera's target point will scale\r\n         * perfectly with finger motion.\r\n         * Overrides pinchDeltaPercentage and pinchPrecision.\r\n         */\r\n        _this.useNaturalPinchZoom = false;\r\n        /**\r\n         * Defines the pointer panning sensibility or how fast is the camera moving.\r\n         */\r\n        _this.panningSensibility = 1000.0;\r\n        /**\r\n         * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n         */\r\n        _this.multiTouchPanning = true;\r\n        /**\r\n         * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n         * zoom (pinch) through multitouch.\r\n         */\r\n        _this.multiTouchPanAndZoom = true;\r\n        /**\r\n         * Revers pinch action direction.\r\n         */\r\n        _this.pinchInwards = true;\r\n        _this._isPanClick = false;\r\n        _this._twoFingerActivityCount = 0;\r\n        _this._isPinching = false;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.getClassName = function () {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    };\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {\r\n        if (this.panningSensibility !== 0 &&\r\n            ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        }\r\n        else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    };\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onDoubleTap = function (type) {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    };\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n        var direction = this.pinchInwards ? 1 : -1;\r\n        if (this.multiTouchPanAndZoom) {\r\n            if (this.useNaturalPinchZoom) {\r\n                this.camera.radius = this.camera.radius *\r\n                    Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\r\n            }\r\n            else if (this.pinchDeltaPercentage) {\r\n                this.camera.inertialRadiusOffset +=\r\n                    (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *\r\n                        this.camera.radius * this.pinchDeltaPercentage;\r\n            }\r\n            else {\r\n                this.camera.inertialRadiusOffset +=\r\n                    (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                        (this.pinchPrecision * direction *\r\n                            (this.angularSensibilityX + this.angularSensibilityY) / 2);\r\n            }\r\n            if (this.panningSensibility !== 0 &&\r\n                previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n                var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n                var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n                this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n                this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n            }\r\n        }\r\n        else {\r\n            this._twoFingerActivityCount++;\r\n            var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);\r\n            var pinchDistance = Math.sqrt(pinchSquaredDistance);\r\n            if (this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 &&\r\n                    Math.abs(pinchDistance - previousPinchDistance) >\r\n                        this.camera.pinchToPanMaxDistance)) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                if (this.pinchDeltaPercentage) {\r\n                    this.camera.inertialRadiusOffset +=\r\n                        (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *\r\n                            this.camera.radius * this.pinchDeltaPercentage;\r\n                }\r\n                else {\r\n                    this.camera.inertialRadiusOffset +=\r\n                        (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                            (this.pinchPrecision * direction *\r\n                                (this.angularSensibilityX + this.angularSensibilityY) / 2);\r\n                }\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            }\r\n            else {\r\n                // Pause between pinch starting and moving implies not a zoom event.\r\n                // Pan instead.\r\n                if (this.panningSensibility !== 0 && this.multiTouchPanning &&\r\n                    multiTouchPanPosition && previousMultiTouchPanPosition) {\r\n                    var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n                    var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n                    this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n                    this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onButtonDown = function (evt) {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    };\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onButtonUp = function (evt) {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    };\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    ArcRotateCameraPointersInput.prototype.onLostFocus = function () {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    };\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\r\n    return ArcRotateCameraPointersInput;\r\n}(BaseCameraPointersInput));\r\nexport { ArcRotateCameraPointersInput };\r\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] =\r\n    ArcRotateCameraPointersInput;\r\n//# sourceMappingURL=arcRotateCameraPointersInput.js.map","import { __decorate } from \"tslib\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from '../../Misc/tools';\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nvar ArcRotateCameraKeyboardMoveInput = /** @class */ (function () {\r\n    function ArcRotateCameraKeyboardMoveInput() {\r\n        /**\r\n         * Defines the list of key codes associated with the up action (increase alpha)\r\n         */\r\n        this.keysUp = [38];\r\n        /**\r\n         * Defines the list of key codes associated with the down action (decrease alpha)\r\n         */\r\n        this.keysDown = [40];\r\n        /**\r\n         * Defines the list of key codes associated with the left action (increase beta)\r\n         */\r\n        this.keysLeft = [37];\r\n        /**\r\n         * Defines the list of key codes associated with the right action (decrease beta)\r\n         */\r\n        this.keysRight = [39];\r\n        /**\r\n         * Defines the list of key codes associated with the reset action.\r\n         * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n         */\r\n        this.keysReset = [220];\r\n        /**\r\n         * Defines the panning sensibility of the inputs.\r\n         * (How fast is the camera panning)\r\n         */\r\n        this.panningSensibility = 50.0;\r\n        /**\r\n         * Defines the zooming sensibility of the inputs.\r\n         * (How fast is the camera zooming)\r\n         */\r\n        this.zoomingSensibility = 25.0;\r\n        /**\r\n         * Defines whether maintaining the alt key down switch the movement mode from\r\n         * orientation to zoom.\r\n         */\r\n        this.useAltToZoom = true;\r\n        /**\r\n         * Rotation speed of the camera\r\n         */\r\n        this.angularSpeed = 0.01;\r\n        this._keys = new Array();\r\n    }\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    ArcRotateCameraKeyboardMoveInput.prototype.attachControl = function (noPreventDefault) {\r\n        var _this = this;\r\n        // was there a second variable defined?\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {\r\n            _this._keys = [];\r\n        });\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (info) {\r\n            var evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    _this._ctrlPressed = evt.ctrlKey;\r\n                    _this._altPressed = evt.altKey;\r\n                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysReset.indexOf(evt.keyCode) !== -1) {\r\n                        var index = _this._keys.indexOf(evt.keyCode);\r\n                        if (index === -1) {\r\n                            _this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysReset.indexOf(evt.keyCode) !== -1) {\r\n                        var index = _this._keys.indexOf(evt.keyCode);\r\n                        if (index >= 0) {\r\n                            _this._keys.splice(index, 1);\r\n                        }\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    ArcRotateCameraKeyboardMoveInput.prototype.detachControl = function (ignored) {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys = [];\r\n    };\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    ArcRotateCameraKeyboardMoveInput.prototype.checkInputs = function () {\r\n        if (this._onKeyboardObserver) {\r\n            var camera = this.camera;\r\n            for (var index = 0; index < this._keys.length; index++) {\r\n                var keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    }\r\n                    else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                }\r\n                else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    }\r\n                    else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    }\r\n                    else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                }\r\n                else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    }\r\n                    else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                }\r\n                else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    }\r\n                    else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    }\r\n                    else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                }\r\n                else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    ArcRotateCameraKeyboardMoveInput.prototype.getClassName = function () {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    };\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    ArcRotateCameraKeyboardMoveInput.prototype.getSimpleName = function () {\r\n        return \"keyboard\";\r\n    };\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysUp\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysDown\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysLeft\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysRight\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysReset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"panningSensibility\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"zoomingSensibility\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"useAltToZoom\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"angularSpeed\", void 0);\r\n    return ArcRotateCameraKeyboardMoveInput;\r\n}());\r\nexport { ArcRotateCameraKeyboardMoveInput };\r\nCameraInputTypes[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n//# sourceMappingURL=arcRotateCameraKeyboardMoveInput.js.map","import { __decorate } from \"tslib\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Scalar } from '../../Maths/math.scalar';\r\nimport { Tools } from '../../Misc/tools';\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nvar ArcRotateCameraMouseWheelInput = /** @class */ (function () {\r\n    function ArcRotateCameraMouseWheelInput() {\r\n        /**\r\n         * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n         */\r\n        this.wheelPrecision = 3.0;\r\n        /**\r\n         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n         * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n         */\r\n        this.wheelDeltaPercentage = 0;\r\n    }\r\n    ArcRotateCameraMouseWheelInput.prototype.computeDeltaFromMouseWheelLegacyEvent = function (mouseWheelDelta, radius) {\r\n        var delta = 0;\r\n        var wheelDelta = (mouseWheelDelta * 0.01 * this.wheelDeltaPercentage) * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    };\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    ArcRotateCameraMouseWheelInput.prototype.attachControl = function (noPreventDefault) {\r\n        var _this = this;\r\n        // was there a second variable defined?\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = function (p, s) {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            var event = p.event;\r\n            var delta = 0;\r\n            var mouseWheelLegacyEvent = event;\r\n            var wheelDelta = 0;\r\n            if (mouseWheelLegacyEvent.wheelDelta) {\r\n                wheelDelta = mouseWheelLegacyEvent.wheelDelta;\r\n            }\r\n            else {\r\n                wheelDelta = -(event.deltaY || event.detail) * 60;\r\n            }\r\n            if (_this.wheelDeltaPercentage) {\r\n                delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, _this.camera.radius);\r\n                // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                // this will stop multiple scroll events zooming in from adding too much inertia\r\n                if (delta > 0) {\r\n                    var estimatedTargetRadius = _this.camera.radius;\r\n                    var targetInertia = _this.camera.inertialRadiusOffset + delta;\r\n                    for (var i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                        estimatedTargetRadius -= targetInertia;\r\n                        targetInertia *= _this.camera.inertia;\r\n                    }\r\n                    estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                    delta = _this.computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                }\r\n            }\r\n            else {\r\n                delta = wheelDelta / (_this.wheelPrecision * 40);\r\n            }\r\n            if (delta) {\r\n                _this.camera.inertialRadiusOffset += delta;\r\n            }\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    };\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    ArcRotateCameraMouseWheelInput.prototype.detachControl = function (ignored) {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    ArcRotateCameraMouseWheelInput.prototype.getClassName = function () {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    };\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    ArcRotateCameraMouseWheelInput.prototype.getSimpleName = function () {\r\n        return \"mousewheel\";\r\n    };\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\r\n    return ArcRotateCameraMouseWheelInput;\r\n}());\r\nexport { ArcRotateCameraMouseWheelInput };\r\nCameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n//# sourceMappingURL=arcRotateCameraMouseWheelInput.js.map","import { __extends } from \"tslib\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nvar ArcRotateCameraInputsManager = /** @class */ (function (_super) {\r\n    __extends(ArcRotateCameraInputsManager, _super);\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    function ArcRotateCameraInputsManager(camera) {\r\n        return _super.call(this, camera) || this;\r\n    }\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    ArcRotateCameraInputsManager.prototype.addMouseWheel = function () {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    };\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    ArcRotateCameraInputsManager.prototype.addPointers = function () {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    };\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    ArcRotateCameraInputsManager.prototype.addKeyboard = function () {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    };\r\n    return ArcRotateCameraInputsManager;\r\n}(CameraInputsManager));\r\nexport { ArcRotateCameraInputsManager };\r\n//# sourceMappingURL=arcRotateCameraInputsManager.js.map","import { __decorate, __extends } from \"tslib\";\r\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", function (name, scene) {\r\n    return function () { return new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene); };\r\n});\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera\r\n */\r\nvar ArcRotateCamera = /** @class */ (function (_super) {\r\n    __extends(ArcRotateCamera, _super);\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the logitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    function ArcRotateCamera(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive) {\r\n        if (setActiveOnSceneIfNoneActive === void 0) { setActiveOnSceneIfNoneActive = true; }\r\n        var _this = _super.call(this, name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive) || this;\r\n        /**\r\n         * Current inertia value on the longitudinal axis.\r\n         * The bigger this number the longer it will take for the camera to stop.\r\n         */\r\n        _this.inertialAlphaOffset = 0;\r\n        /**\r\n         * Current inertia value on the latitudinal axis.\r\n         * The bigger this number the longer it will take for the camera to stop.\r\n         */\r\n        _this.inertialBetaOffset = 0;\r\n        /**\r\n         * Current inertia value on the radius axis.\r\n         * The bigger this number the longer it will take for the camera to stop.\r\n         */\r\n        _this.inertialRadiusOffset = 0;\r\n        /**\r\n         * Minimum allowed angle on the longitudinal axis.\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.lowerAlphaLimit = null;\r\n        /**\r\n         * Maximum allowed angle on the longitudinal axis.\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.upperAlphaLimit = null;\r\n        /**\r\n         * Minimum allowed angle on the latitudinal axis.\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.lowerBetaLimit = 0.01;\r\n        /**\r\n         * Maximum allowed angle on the latitudinal axis.\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.upperBetaLimit = Math.PI - 0.01;\r\n        /**\r\n         * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.lowerRadiusLimit = null;\r\n        /**\r\n         * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n         * This can help limiting how the Camera is able to move in the scene.\r\n         */\r\n        _this.upperRadiusLimit = null;\r\n        /**\r\n         * Defines the current inertia value used during panning of the camera along the X axis.\r\n         */\r\n        _this.inertialPanningX = 0;\r\n        /**\r\n         * Defines the current inertia value used during panning of the camera along the Y axis.\r\n         */\r\n        _this.inertialPanningY = 0;\r\n        /**\r\n         * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n         * Basically if your fingers moves away from more than this distance you will be considered\r\n         * in pinch mode.\r\n         */\r\n        _this.pinchToPanMaxDistance = 20;\r\n        /**\r\n         * Defines the maximum distance the camera can pan.\r\n         * This could help keeping the cammera always in your scene.\r\n         */\r\n        _this.panningDistanceLimit = null;\r\n        /**\r\n         * Defines the target of the camera before paning.\r\n         */\r\n        _this.panningOriginTarget = Vector3.Zero();\r\n        /**\r\n         * Defines the value of the inertia used during panning.\r\n         * 0 would mean stop inertia and one would mean no decelleration at all.\r\n         */\r\n        _this.panningInertia = 0.9;\r\n        //-- end properties for backward compatibility for inputs\r\n        /**\r\n         * Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)\r\n         */\r\n        _this.zoomOnFactor = 1;\r\n        /**\r\n         * Defines a screen offset for the camera position.\r\n         */\r\n        _this.targetScreenOffset = Vector2.Zero();\r\n        /**\r\n         * Allows the camera to be completely reversed.\r\n         * If false the camera can not arrive upside down.\r\n         */\r\n        _this.allowUpsideDown = true;\r\n        /**\r\n         * Define if double tap/click is used to restore the previously saved state of the camera.\r\n         */\r\n        _this.useInputToRestoreState = true;\r\n        /** @hidden */\r\n        _this._viewMatrix = new Matrix();\r\n        /**\r\n         * Defines the allowed panning axis.\r\n         */\r\n        _this.panningAxis = new Vector3(1, 1, 0);\r\n        /**\r\n         * Observable triggered when the mesh target has been changed on the camera.\r\n         */\r\n        _this.onMeshTargetChangedObservable = new Observable();\r\n        /**\r\n         * Defines whether the camera should check collision with the objects oh the scene.\r\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this\r\n         */\r\n        _this.checkCollisions = false;\r\n        /**\r\n         * Defines the collision radius of the camera.\r\n         * This simulates a sphere around the camera.\r\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n         */\r\n        _this.collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n        _this._previousPosition = Vector3.Zero();\r\n        _this._collisionVelocity = Vector3.Zero();\r\n        _this._newPosition = Vector3.Zero();\r\n        _this._computationVector = Vector3.Zero();\r\n        _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\r\n            if (collidedMesh === void 0) { collidedMesh = null; }\r\n            if (!collidedMesh) {\r\n                _this._previousPosition.copyFrom(_this._position);\r\n            }\r\n            else {\r\n                _this.setPosition(newPosition);\r\n                if (_this.onCollide) {\r\n                    _this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n            // Recompute because of constraints\r\n            var cosa = Math.cos(_this.alpha);\r\n            var sina = Math.sin(_this.alpha);\r\n            var cosb = Math.cos(_this.beta);\r\n            var sinb = Math.sin(_this.beta);\r\n            if (sinb === 0) {\r\n                sinb = 0.0001;\r\n            }\r\n            var target = _this._getTargetPosition();\r\n            _this._computationVector.copyFromFloats(_this.radius * cosa * sinb, _this.radius * cosb, _this.radius * sina * sinb);\r\n            target.addToRef(_this._computationVector, _this._newPosition);\r\n            _this._position.copyFrom(_this._newPosition);\r\n            var up = _this.upVector;\r\n            if (_this.allowUpsideDown && _this.beta < 0) {\r\n                up = up.clone();\r\n                up = up.negate();\r\n            }\r\n            _this._computeViewMatrix(_this._position, target, up);\r\n            _this._viewMatrix.addAtIndex(12, _this.targetScreenOffset.x);\r\n            _this._viewMatrix.addAtIndex(13, _this.targetScreenOffset.y);\r\n            _this._collisionTriggered = false;\r\n        };\r\n        _this._target = Vector3.Zero();\r\n        if (target) {\r\n            _this.setTarget(target);\r\n        }\r\n        _this.alpha = alpha;\r\n        _this.beta = beta;\r\n        _this.radius = radius;\r\n        _this.getViewMatrix();\r\n        _this.inputs = new ArcRotateCameraInputsManager(_this);\r\n        _this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"target\", {\r\n        /**\r\n         * Defines the target point of the camera.\r\n         * The camera looks towards it form the radius distance.\r\n         * Please note that you can set the target to a mesh and thus the target will be copied from mesh.position\r\n         */\r\n        get: function () {\r\n            return this._target;\r\n        },\r\n        set: function (value) {\r\n            this.setTarget(value);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"position\", {\r\n        /**\r\n         * Define the current local position of the camera in the scene\r\n         */\r\n        get: function () {\r\n            return this._position;\r\n        },\r\n        set: function (newPosition) {\r\n            this.setPosition(newPosition);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"upVector\", {\r\n        get: function () {\r\n            return this._upVector;\r\n        },\r\n        /**\r\n         * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n         * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n         * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n         */\r\n        set: function (vec) {\r\n            if (!this._upToYMatrix) {\r\n                this._YToUpMatrix = new Matrix();\r\n                this._upToYMatrix = new Matrix();\r\n                this._upVector = Vector3.Zero();\r\n            }\r\n            vec.normalize();\r\n            this._upVector.copyFrom(vec);\r\n            this.setMatUp();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    ArcRotateCamera.prototype.setMatUp = function () {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._YToUpMatrix);\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    };\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityX\", {\r\n        //-- begin properties for backward compatibility for inputs\r\n        /**\r\n         * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.angularSensibilityX;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.angularSensibilityX = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityY\", {\r\n        /**\r\n         * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.angularSensibilityY;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.angularSensibilityY = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"pinchPrecision\", {\r\n        /**\r\n         * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.pinchPrecision;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.pinchPrecision = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"pinchDeltaPercentage\", {\r\n        /**\r\n         * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n         * It will be used instead of pinchDeltaPrecision if different from 0.\r\n         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.pinchDeltaPercentage;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.pinchDeltaPercentage = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"useNaturalPinchZoom\", {\r\n        /**\r\n         * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n         * and pinch delta percentage.\r\n         * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n         * that any object in the plane at the camera's target point will scale\r\n         * perfectly with finger motion.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.useNaturalPinchZoom;\r\n            }\r\n            return false;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.useNaturalPinchZoom = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"panningSensibility\", {\r\n        /**\r\n         * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n         */\r\n        get: function () {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                return pointers.panningSensibility;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var pointers = this.inputs.attached[\"pointers\"];\r\n            if (pointers) {\r\n                pointers.panningSensibility = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"keysUp\", {\r\n        /**\r\n         * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n         */\r\n        get: function () {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                return keyboard.keysUp;\r\n            }\r\n            return [];\r\n        },\r\n        set: function (value) {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                keyboard.keysUp = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"keysDown\", {\r\n        /**\r\n         * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n         */\r\n        get: function () {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                return keyboard.keysDown;\r\n            }\r\n            return [];\r\n        },\r\n        set: function (value) {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                keyboard.keysDown = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"keysLeft\", {\r\n        /**\r\n         * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n         */\r\n        get: function () {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                return keyboard.keysLeft;\r\n            }\r\n            return [];\r\n        },\r\n        set: function (value) {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                keyboard.keysLeft = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"keysRight\", {\r\n        /**\r\n         * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n         */\r\n        get: function () {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                return keyboard.keysRight;\r\n            }\r\n            return [];\r\n        },\r\n        set: function (value) {\r\n            var keyboard = this.inputs.attached[\"keyboard\"];\r\n            if (keyboard) {\r\n                keyboard.keysRight = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"wheelPrecision\", {\r\n        /**\r\n         * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n         */\r\n        get: function () {\r\n            var mousewheel = this.inputs.attached[\"mousewheel\"];\r\n            if (mousewheel) {\r\n                return mousewheel.wheelPrecision;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var mousewheel = this.inputs.attached[\"mousewheel\"];\r\n            if (mousewheel) {\r\n                mousewheel.wheelPrecision = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"wheelDeltaPercentage\", {\r\n        /**\r\n         * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n         * It will be used instead of pinchDeltaPrecision if different from 0.\r\n         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n         */\r\n        get: function () {\r\n            var mousewheel = this.inputs.attached[\"mousewheel\"];\r\n            if (mousewheel) {\r\n                return mousewheel.wheelDeltaPercentage;\r\n            }\r\n            return 0;\r\n        },\r\n        set: function (value) {\r\n            var mousewheel = this.inputs.attached[\"mousewheel\"];\r\n            if (mousewheel) {\r\n                mousewheel.wheelDeltaPercentage = value;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"bouncingBehavior\", {\r\n        /**\r\n         * Gets the bouncing behavior of the camera if it has been enabled.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n         */\r\n        get: function () {\r\n            return this._bouncingBehavior;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"useBouncingBehavior\", {\r\n        /**\r\n         * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n         */\r\n        get: function () {\r\n            return this._bouncingBehavior != null;\r\n        },\r\n        set: function (value) {\r\n            if (value === this.useBouncingBehavior) {\r\n                return;\r\n            }\r\n            if (value) {\r\n                this._bouncingBehavior = new BouncingBehavior();\r\n                this.addBehavior(this._bouncingBehavior);\r\n            }\r\n            else if (this._bouncingBehavior) {\r\n                this.removeBehavior(this._bouncingBehavior);\r\n                this._bouncingBehavior = null;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"framingBehavior\", {\r\n        /**\r\n         * Gets the framing behavior of the camera if it has been enabled.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n         */\r\n        get: function () {\r\n            return this._framingBehavior;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"useFramingBehavior\", {\r\n        /**\r\n         * Defines if the framing behavior of the camera is enabled on the camera.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n         */\r\n        get: function () {\r\n            return this._framingBehavior != null;\r\n        },\r\n        set: function (value) {\r\n            if (value === this.useFramingBehavior) {\r\n                return;\r\n            }\r\n            if (value) {\r\n                this._framingBehavior = new FramingBehavior();\r\n                this.addBehavior(this._framingBehavior);\r\n            }\r\n            else if (this._framingBehavior) {\r\n                this.removeBehavior(this._framingBehavior);\r\n                this._framingBehavior = null;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"autoRotationBehavior\", {\r\n        /**\r\n         * Gets the auto rotation behavior of the camera if it has been enabled.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n         */\r\n        get: function () {\r\n            return this._autoRotationBehavior;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ArcRotateCamera.prototype, \"useAutoRotationBehavior\", {\r\n        /**\r\n         * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n         * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n         */\r\n        get: function () {\r\n            return this._autoRotationBehavior != null;\r\n        },\r\n        set: function (value) {\r\n            if (value === this.useAutoRotationBehavior) {\r\n                return;\r\n            }\r\n            if (value) {\r\n                this._autoRotationBehavior = new AutoRotationBehavior();\r\n                this.addBehavior(this._autoRotationBehavior);\r\n            }\r\n            else if (this._autoRotationBehavior) {\r\n                this.removeBehavior(this._autoRotationBehavior);\r\n                this._autoRotationBehavior = null;\r\n            }\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Cache\r\n    /** @hidden */\r\n    ArcRotateCamera.prototype._initCache = function () {\r\n        _super.prototype._initCache.call(this);\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    };\r\n    /** @hidden */\r\n    ArcRotateCamera.prototype._updateCache = function (ignoreParentClass) {\r\n        if (!ignoreParentClass) {\r\n            _super.prototype._updateCache.call(this);\r\n        }\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    };\r\n    ArcRotateCamera.prototype._getTargetPosition = function () {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            var pos = this._targetHost.absolutePosition;\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            }\r\n            else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n        return this._target;\r\n    };\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    ArcRotateCamera.prototype.storeState = function () {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n        return _super.prototype.storeState.call(this);\r\n    };\r\n    /**\r\n     * @hidden\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    ArcRotateCamera.prototype._restoreStateValues = function () {\r\n        if (!_super.prototype._restoreStateValues.call(this)) {\r\n            return false;\r\n        }\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n        return true;\r\n    };\r\n    // Synchronized\r\n    /** @hidden */\r\n    ArcRotateCamera.prototype._isSynchronizedViewMatrix = function () {\r\n        if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\r\n            return false;\r\n        }\r\n        return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);\r\n    };\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    ArcRotateCamera.prototype.attachControl = function (ignored, noPreventDefault, useCtrlForPanning, panningMouseButton) {\r\n        var _this = this;\r\n        if (useCtrlForPanning === void 0) { useCtrlForPanning = true; }\r\n        if (panningMouseButton === void 0) { panningMouseButton = 2; }\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._useCtrlForPanning = useCtrlForPanning;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof arguments[0] === \"boolean\") {\r\n            if (arguments.length > 1) {\r\n                this._useCtrlForPanning = arguments[1];\r\n            }\r\n            if (arguments.length > 2) {\r\n                this._panningMouseButton = arguments[2];\r\n            }\r\n        }\r\n        this.inputs.attachElement(noPreventDefault);\r\n        this._reset = function () {\r\n            _this.inertialAlphaOffset = 0;\r\n            _this.inertialBetaOffset = 0;\r\n            _this.inertialRadiusOffset = 0;\r\n            _this.inertialPanningX = 0;\r\n            _this.inertialPanningY = 0;\r\n        };\r\n    };\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    ArcRotateCamera.prototype.detachControl = function (ignored) {\r\n        this.inputs.detachElement();\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    };\r\n    /** @hidden */\r\n    ArcRotateCamera.prototype._checkInputs = function () {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n        this.inputs.checkInputs();\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            var inertialAlphaOffset = this.inertialAlphaOffset;\r\n            if (this.beta <= 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.getScene().useRightHandedSystem) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            this.alpha += inertialAlphaOffset;\r\n            this.beta += this.inertialBetaOffset;\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            if (!this._localDirection) {\r\n                this._localDirection = Vector3.Zero();\r\n                this._transformedDirection = Vector3.Zero();\r\n            }\r\n            this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n            this._localDirection.multiplyInPlace(this.panningAxis);\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n            //Eliminate y if map panning is enabled (panningAxis == 1,0,1)\r\n            if (!this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    var distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                }\r\n                else {\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n        // Limits\r\n        this._checkLimits();\r\n        _super.prototype._checkInputs.call(this);\r\n    };\r\n    ArcRotateCamera.prototype._checkLimits = function () {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        }\r\n        else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        }\r\n        else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    ArcRotateCamera.prototype.rebuildAnglesAndRadius = function () {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n        this.radius = this._computationVector.length();\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n        // Alpha\r\n        var previousAlpha = this.alpha;\r\n        if (this._computationVector.x === 0 && this._computationVector.z === 0) {\r\n            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\r\n        }\r\n        else {\r\n            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\r\n        }\r\n        if (this._computationVector.z < 0) {\r\n            this.alpha = 2 * Math.PI - this.alpha;\r\n        }\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        var alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n        // Beta\r\n        this.beta = Math.acos(this._computationVector.y / this.radius);\r\n        this._checkLimits();\r\n    };\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    ArcRotateCamera.prototype.setPosition = function (position) {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n        this.rebuildAnglesAndRadius();\r\n    };\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     */\r\n    ArcRotateCamera.prototype.setTarget = function (target, toBoundingCenter, allowSamePosition) {\r\n        if (toBoundingCenter === void 0) { toBoundingCenter = false; }\r\n        if (allowSamePosition === void 0) { allowSamePosition = false; }\r\n        if (target.getBoundingInfo) {\r\n            if (toBoundingCenter) {\r\n                this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();\r\n            }\r\n            else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            target.computeWorldMatrix();\r\n            this._targetHost = target;\r\n            this._target = this._getTargetPosition();\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        }\r\n        else {\r\n            var newTarget = target;\r\n            var currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n        this.rebuildAnglesAndRadius();\r\n    };\r\n    /** @hidden */\r\n    ArcRotateCamera.prototype._getViewMatrix = function () {\r\n        // Compute\r\n        var cosa = Math.cos(this.alpha);\r\n        var sina = Math.sin(this.alpha);\r\n        var cosb = Math.cos(this.beta);\r\n        var sinb = Math.sin(this.beta);\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n        var target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._YToUpMatrix, this._computationVector);\r\n        }\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            var coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        }\r\n        else {\r\n            this._position.copyFrom(this._newPosition);\r\n            var up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n            this._computeViewMatrix(this._position, target, up);\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget = target;\r\n        return this._viewMatrix;\r\n    };\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    ArcRotateCamera.prototype.zoomOn = function (meshes, doNotUpdateMaxZ) {\r\n        if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }\r\n        meshes = meshes || this.getScene().meshes;\r\n        var minMaxVector = Mesh.MinMax(meshes);\r\n        var distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);\r\n        this.radius = distance * this.zoomOnFactor;\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    };\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    ArcRotateCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ) {\r\n        if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }\r\n        var meshesOrMinMaxVector;\r\n        var distance;\r\n        if (meshesOrMinMaxVectorAndDistance.min === undefined) {\r\n            // meshes\r\n            var meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        }\r\n        else {\r\n            //minMaxVector and distance\r\n            var minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    };\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     */\r\n    ArcRotateCamera.prototype.createRigCamera = function (name, cameraIndex) {\r\n        var alphaShift = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        var rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n        return rigCam;\r\n    };\r\n    /**\r\n     * @hidden\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    ArcRotateCamera.prototype._updateRigCameras = function () {\r\n        var camLeft = this._rigCameras[0];\r\n        var camRight = this._rigCameras[1];\r\n        camLeft.beta = camRight.beta = this.beta;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        _super.prototype._updateRigCameras.call(this);\r\n    };\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    ArcRotateCamera.prototype.dispose = function () {\r\n        this.inputs.clear();\r\n        _super.prototype.dispose.call(this);\r\n    };\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    ArcRotateCamera.prototype.getClassName = function () {\r\n        return \"ArcRotateCamera\";\r\n    };\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"alpha\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"beta\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"radius\", void 0);\r\n    __decorate([\r\n        serializeAsVector3(\"target\")\r\n    ], ArcRotateCamera.prototype, \"_target\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"inertialAlphaOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"inertialBetaOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"inertialRadiusOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"lowerAlphaLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"upperAlphaLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"lowerBetaLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"upperBetaLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"lowerRadiusLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"upperRadiusLimit\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"inertialPanningX\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"inertialPanningY\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"pinchToPanMaxDistance\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"panningDistanceLimit\", void 0);\r\n    __decorate([\r\n        serializeAsVector3()\r\n    ], ArcRotateCamera.prototype, \"panningOriginTarget\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"panningInertia\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"zoomOnFactor\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"targetScreenOffset\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"allowUpsideDown\", void 0);\r\n    __decorate([\r\n        serialize()\r\n    ], ArcRotateCamera.prototype, \"useInputToRestoreState\", void 0);\r\n    return ArcRotateCamera;\r\n}(TargetCamera));\r\nexport { ArcRotateCamera };\r\n//# sourceMappingURL=arcRotateCamera.js.map","import { __extends } from \"tslib\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from './transformNode';\r\nimport { VertexBuffer } from './buffer';\r\nimport { BoundingInfo } from '../Culling/boundingInfo';\r\nimport { Tools } from '../Misc/tools';\r\nMesh._instancedMeshFactory = function (name, mesh) {\r\n    var instance = new InstancedMesh(name, mesh);\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n        for (var key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n    return instance;\r\n};\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nvar InstancedMesh = /** @class */ (function (_super) {\r\n    __extends(InstancedMesh, _super);\r\n    function InstancedMesh(name, source) {\r\n        var _this = _super.call(this, name, source.getScene()) || this;\r\n        /** @hidden */\r\n        _this._indexInSourceMeshInstanceArray = -1;\r\n        source.addInstance(_this);\r\n        _this._sourceMesh = source;\r\n        _this._unIndexed = source._unIndexed;\r\n        _this.position.copyFrom(source.position);\r\n        _this.rotation.copyFrom(source.rotation);\r\n        _this.scaling.copyFrom(source.scaling);\r\n        if (source.rotationQuaternion) {\r\n            _this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n        _this.animations = Tools.Slice(source.animations);\r\n        for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\r\n            var range = _a[_i];\r\n            if (range != null) {\r\n                _this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n        _this.infiniteDistance = source.infiniteDistance;\r\n        _this.setPivotMatrix(source.getPivotMatrix());\r\n        _this.refreshBoundingInfo();\r\n        _this._syncSubMeshes();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    InstancedMesh.prototype.getClassName = function () {\r\n        return \"InstancedMesh\";\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\r\n        /** Gets the list of lights affecting that mesh */\r\n        get: function () {\r\n            return this._sourceMesh._lightSources;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    InstancedMesh.prototype._resyncLightSources = function () {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._resyncLightSource = function (light) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._removeLightSource = function (light, dispose) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\r\n        // Methods\r\n        /**\r\n         * If the source mesh receives shadows\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.receiveShadows;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"material\", {\r\n        /**\r\n         * The material of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.material;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\r\n        /**\r\n         * Visibility of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.visibility;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\r\n        /**\r\n         * Skeleton of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.skeleton;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\r\n        /**\r\n         * Rendering ground id of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.renderingGroupId;\r\n        },\r\n        set: function (value) {\r\n            if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n                return;\r\n            }\r\n            //no-op with warning\r\n            Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    InstancedMesh.prototype.getTotalVertices = function () {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    };\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    InstancedMesh.prototype.getTotalIndices = function () {\r\n        return this._sourceMesh.getTotalIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\r\n        /**\r\n         * The source mesh of the instance\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    InstancedMesh.prototype.createInstance = function (name) {\r\n        return this._sourceMesh.createInstance(name);\r\n    };\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    InstancedMesh.prototype.isReady = function (completeCheck) {\r\n        if (completeCheck === void 0) { completeCheck = false; }\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    };\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n     */\r\n    InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    };\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     */\r\n    InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    };\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    InstancedMesh.prototype.getIndices = function () {\r\n        return this._sourceMesh.getIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\r\n        get: function () {\r\n            return this._sourceMesh._positions;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\r\n        if (applySkeleton === void 0) { applySkeleton = false; }\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n        var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._preActivate = function () {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n        if (this._currentLOD) {\r\n            var differentSign = (this._currentLOD._getWorldMatrixDeterminant() > 0) !== (this._getWorldMatrixDeterminant() > 0);\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._postActivate = function () {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        }\r\n        else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    };\r\n    InstancedMesh.prototype.getWorldMatrix = function () {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            var tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return TmpVectors.Matrix[0];\r\n        }\r\n        return _super.prototype.getWorldMatrix.call(this);\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     */\r\n    InstancedMesh.prototype.getLOD = function (camera) {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n        var boundingInfo = this.getBoundingInfo();\r\n        this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        if (this._currentLOD === this.sourceMesh) {\r\n            return this.sourceMesh;\r\n        }\r\n        return this._currentLOD;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\r\n        return this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._syncSubMeshes = function () {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._generatePointsArray = function () {\r\n        return this._sourceMesh._generatePointsArray();\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._updateBoundingInfo = function () {\r\n        var effectiveMesh = this;\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\r\n        return this;\r\n    };\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     */\r\n    InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\r\n        if (newParent === void 0) { newParent = null; }\r\n        var result = this._sourceMesh.createInstance(name);\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(this, result, [\r\n            \"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\",\r\n            \"receiveShadows\", \"material\", \"visibility\", \"skeleton\",\r\n            \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\",\r\n            \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\",\r\n            \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\",\r\n            \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"\r\n        ], []);\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\r\n                var mesh = this.getScene().meshes[index];\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n        result.computeWorldMatrix(true);\r\n        return result;\r\n    };\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     */\r\n    InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\r\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\r\n    };\r\n    return InstancedMesh;\r\n}(AbstractMesh));\r\nexport { InstancedMesh };\r\nMesh.prototype.edgesShareWithInstances = false;\r\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\r\n    // Remove existing one\r\n    this.removeVerticesData(kind);\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n        for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\r\n            var instance = _a[_i];\r\n            instance.instancedBuffers = {};\r\n        }\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {}\r\n        };\r\n    }\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n    this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\r\n    for (var _b = 0, _c = this.instances; _b < _c.length; _b++) {\r\n        var instance = _c[_b];\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n};\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\r\n    var instanceCount = visibleInstances.length;\r\n    for (var kind in this.instancedBuffers) {\r\n        var size = this._userInstancedBuffersStorage.sizes[kind];\r\n        var stride = this._userInstancedBuffersStorage.strides[kind];\r\n        // Resize if required\r\n        var expectedSize = (instanceCount + 1) * stride;\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n        var data = this._userInstancedBuffersStorage.data[kind];\r\n        // Update data buffer\r\n        var offset = 0;\r\n        if (renderSelf) {\r\n            var value = this.instancedBuffers[kind];\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            }\r\n            else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n            offset += stride;\r\n        }\r\n        for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            var instance = visibleInstances[instanceIndex];\r\n            var value = instance.instancedBuffers[kind];\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            }\r\n            else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n            offset += stride;\r\n        }\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n            this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\r\n        }\r\n        else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n    for (var kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\r\n        }\r\n    }\r\n    this.instancedBuffers = {};\r\n};\r\n//# sourceMappingURL=instancedMesh.js.map","import { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Animation } from \"./animation\";\r\nimport { Size } from '../Maths/math.size';\r\n// Static values to help the garbage collector\r\n// Quaternion\r\nvar _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n// Vector3\r\nvar _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());\r\n// Vector2\r\nvar _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());\r\n// Size\r\nvar _staticOffsetValueSize = Object.freeze(Size.Zero());\r\n// Color3\r\nvar _staticOffsetValueColor3 = Object.freeze(Color3.Black());\r\n/**\r\n * Defines a runtime animation\r\n */\r\nvar RuntimeAnimation = /** @class */ (function () {\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    function RuntimeAnimation(target, animation, scene, host) {\r\n        var _this = this;\r\n        this._events = new Array();\r\n        /**\r\n         * The current frame of the runtime animation\r\n         */\r\n        this._currentFrame = 0;\r\n        /**\r\n         * The original value of the runtime animation\r\n         */\r\n        this._originalValue = new Array();\r\n        /**\r\n         * The original blend value of the runtime animation\r\n         */\r\n        this._originalBlendValue = null;\r\n        /**\r\n         * The offsets cache of the runtime animation\r\n         */\r\n        this._offsetsCache = {};\r\n        /**\r\n         * The high limits cache of the runtime animation\r\n         */\r\n        this._highLimitsCache = {};\r\n        /**\r\n         * Specifies if the runtime animation has been stopped\r\n         */\r\n        this._stopped = false;\r\n        /**\r\n         * The blending factor of the runtime animation\r\n         */\r\n        this._blendingFactor = 0;\r\n        /**\r\n         * The current value of the runtime animation\r\n         */\r\n        this._currentValue = null;\r\n        this._currentActiveTarget = null;\r\n        this._directTarget = null;\r\n        /**\r\n         * The target path of the runtime animation\r\n         */\r\n        this._targetPath = \"\";\r\n        /**\r\n         * The weight of the runtime animation\r\n         */\r\n        this._weight = 1.0;\r\n        /**\r\n         * The ratio offset of the runtime animation\r\n         */\r\n        this._ratioOffset = 0;\r\n        /**\r\n         * The previous delay of the runtime animation\r\n         */\r\n        this._previousDelay = 0;\r\n        /**\r\n         * The previous ratio of the runtime animation\r\n         */\r\n        this._previousRatio = 0;\r\n        this._targetIsArray = false;\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n        animation._runtimeAnimations.push(this);\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode()\r\n        };\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            var newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            var index = 0;\r\n            for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\r\n                var target_1 = _a[_i];\r\n                this._preparePath(target_1, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        }\r\n        else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n        // Cloning events locally\r\n        var events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach(function (e) {\r\n                _this._events.push(e._clone());\r\n            });\r\n        }\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"currentFrame\", {\r\n        /**\r\n         * Gets the current frame of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentFrame;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"weight\", {\r\n        /**\r\n         * Gets the weight of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._weight;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"currentValue\", {\r\n        /**\r\n         * Gets the current value of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentValue;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"targetPath\", {\r\n        /**\r\n         * Gets the target path of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._targetPath;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"target\", {\r\n        /**\r\n         * Gets the actual target of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._currentActiveTarget;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"isAdditive\", {\r\n        /**\r\n         * Gets the additive state of the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._host && this._host.isAdditive;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    RuntimeAnimation.prototype._preparePath = function (target, targetIndex) {\r\n        if (targetIndex === void 0) { targetIndex = 0; }\r\n        var targetPropertyPath = this._animation.targetPropertyPath;\r\n        if (targetPropertyPath.length > 1) {\r\n            var property = target[targetPropertyPath[0]];\r\n            for (var index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        }\r\n        else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    };\r\n    Object.defineProperty(RuntimeAnimation.prototype, \"animation\", {\r\n        /**\r\n         * Gets the animation from the runtime animation\r\n         */\r\n        get: function () {\r\n            return this._animation;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    RuntimeAnimation.prototype.reset = function (restoreOriginal) {\r\n        if (restoreOriginal === void 0) { restoreOriginal = false; }\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                var index = 0;\r\n                for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\r\n                    var target = _a[_i];\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n            else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n        // Events\r\n        for (var index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    };\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    RuntimeAnimation.prototype.isStopped = function () {\r\n        return this._stopped;\r\n    };\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    RuntimeAnimation.prototype.dispose = function () {\r\n        var index = this._animation.runtimeAnimations.indexOf(this);\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    };\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    RuntimeAnimation.prototype.setValue = function (currentValue, weight) {\r\n        if (this._targetIsArray) {\r\n            for (var index = 0; index < this._target.length; index++) {\r\n                var target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    };\r\n    RuntimeAnimation.prototype._getOriginalValues = function (targetIndex) {\r\n        if (targetIndex === void 0) { targetIndex = 0; }\r\n        var originalValue;\r\n        var target = this._activeTargets[targetIndex];\r\n        if (target.getRestPose && this._targetPath === \"_matrix\") { // For bones\r\n            originalValue = target.getRestPose();\r\n        }\r\n        else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        }\r\n        else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    };\r\n    RuntimeAnimation.prototype._setValue = function (target, destination, currentValue, weight, targetIndex) {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n        this._weight = weight;\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                var originalValue = destination[this._targetPath];\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                }\r\n                else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n            if (this._originalBlendValue.m) { // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    }\r\n                    else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    }\r\n                    else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n            var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        }\r\n        else {\r\n            this._currentValue = currentValue;\r\n        }\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        }\r\n        else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    RuntimeAnimation.prototype._getCorrectLoopMode = function () {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n        return this._animation.loopMode;\r\n    };\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    RuntimeAnimation.prototype.goToFrame = function (frame) {\r\n        var keys = this._animation.getKeys();\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        }\r\n        else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n        // Need to reset animation events\r\n        var events = this._events;\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = frame;\r\n        var currentValue = this._animation._interpolate(frame, this._animationState);\r\n        this.setValue(currentValue, -1);\r\n    };\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    RuntimeAnimation.prototype._prepareForSpeedRatioChange = function (newSpeedRatio) {\r\n        var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\r\n        this._ratioOffset = this._previousRatio - newRatio;\r\n    };\r\n    /**\r\n     * Execute the current animation\r\n     * @param delay defines the delay to add to the current frame\r\n     * @param from defines the lower bound of the animation range\r\n     * @param to defines the upper bound of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @param onLoop optional callback called when animation loops\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    RuntimeAnimation.prototype.animate = function (delay, from, to, loop, speedRatio, weight) {\r\n        if (weight === void 0) { weight = -1.0; }\r\n        var animation = this._animation;\r\n        var targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n        var returnValue = true;\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n        var range = to - from;\r\n        var offsetValue;\r\n        // Compute ratio which represents the frame delta between from and to\r\n        var ratio = (delay * (animation.framePerSecond * speedRatio) / 1000.0) + this._ratioOffset;\r\n        var highLimitValue = 0;\r\n        this._previousDelay = delay;\r\n        this._previousRatio = ratio;\r\n        if (!loop && (to >= from && ratio >= range)) { // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        }\r\n        else if (!loop && (from >= to && ratio <= range)) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        }\r\n        else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            var keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\r\n                var fromValue = animation._interpolate(from, this._animationState);\r\n                var toValue = animation._interpolate(to, this._animationState);\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    default:\r\n                        break;\r\n                }\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n        // Compute value\r\n        var currentFrame;\r\n        if (this._host && this._host.syncRoot) {\r\n            var syncRoot = this._host.syncRoot;\r\n            var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + (to - from) * hostNormalizedFrame;\r\n        }\r\n        else {\r\n            currentFrame = (returnValue && range !== 0) ? from + ratio % range : to;\r\n        }\r\n        // Reset events if looping\r\n        var events = this._events;\r\n        if (range > 0 && this.currentFrame > currentFrame ||\r\n            range < 0 && this.currentFrame < currentFrame) {\r\n            this._onLoop();\r\n            // Need to reset animation events\r\n            if (events.length) {\r\n                for (var index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = range === 0 ? 0 : (ratio / range) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n        var currentValue = animation._interpolate(currentFrame, this._animationState);\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n        // Check events\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if ((range > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (range < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\r\n                    var event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already be done.\r\n                }\r\n            }\r\n        }\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n        return returnValue;\r\n    };\r\n    return RuntimeAnimation;\r\n}());\r\nexport { RuntimeAnimation };\r\n//# sourceMappingURL=runtimeAnimation.js.map","import { __extends } from \"tslib\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from '../Maths/math.axis';\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nvar Bone = /** @class */ (function (_super) {\r\n    __extends(Bone, _super);\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix\r\n     * @param restPose defines the rest pose matrix\r\n     * @param baseMatrix defines the base matrix\r\n     * @param index defines index of the bone in the hiearchy\r\n     */\r\n    function Bone(\r\n    /**\r\n     * defines the bone name\r\n     */\r\n    name, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {\r\n        if (parentBone === void 0) { parentBone = null; }\r\n        if (localMatrix === void 0) { localMatrix = null; }\r\n        if (restPose === void 0) { restPose = null; }\r\n        if (baseMatrix === void 0) { baseMatrix = null; }\r\n        if (index === void 0) { index = null; }\r\n        var _this = _super.call(this, name, skeleton.getScene()) || this;\r\n        _this.name = name;\r\n        /**\r\n         * Gets the list of child bones\r\n         */\r\n        _this.children = new Array();\r\n        /** Gets the animations associated with this bone */\r\n        _this.animations = new Array();\r\n        /**\r\n         * @hidden Internal only\r\n         * Set this value to map this bone to a different index in the transform matrices\r\n         * Set this value to -1 to exclude the bone from the transform matrices\r\n         */\r\n        _this._index = null;\r\n        _this._absoluteTransform = new Matrix();\r\n        _this._invertedAbsoluteTransform = new Matrix();\r\n        _this._scalingDeterminant = 1;\r\n        _this._worldTransform = new Matrix();\r\n        _this._needToDecompose = true;\r\n        _this._needToCompose = false;\r\n        /** @hidden */\r\n        _this._linkedTransformNode = null;\r\n        /** @hidden */\r\n        _this._waitingTransformNodeId = null;\r\n        _this._skeleton = skeleton;\r\n        _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\r\n        _this._restPose = restPose ? restPose : _this._localMatrix.clone();\r\n        _this._bindPose = _this._localMatrix.clone();\r\n        _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();\r\n        _this._index = index;\r\n        skeleton.bones.push(_this);\r\n        _this.setParent(parentBone, false);\r\n        if (baseMatrix || localMatrix) {\r\n            _this._updateDifferenceMatrix();\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Bone.prototype, \"_matrix\", {\r\n        /** @hidden */\r\n        get: function () {\r\n            this._compose();\r\n            return this._localMatrix;\r\n        },\r\n        /** @hidden */\r\n        set: function (value) {\r\n            this._localMatrix.copyFrom(value);\r\n            this._needToDecompose = true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    Bone.prototype.getClassName = function () {\r\n        return \"Bone\";\r\n    };\r\n    // Members\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    Bone.prototype.getSkeleton = function () {\r\n        return this._skeleton;\r\n    };\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    Bone.prototype.getParent = function () {\r\n        return this._parent;\r\n    };\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    Bone.prototype.getChildren = function () {\r\n        return this.children;\r\n    };\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    Bone.prototype.getIndex = function () {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    };\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     */\r\n    Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\r\n        if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\r\n        if (this._parent === parent) {\r\n            return;\r\n        }\r\n        if (this._parent) {\r\n            var index = this._parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this._parent.children.splice(index, 1);\r\n            }\r\n        }\r\n        this._parent = parent;\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n        this.markAsDirty();\r\n    };\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getLocalMatrix = function () {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    };\r\n    /**\r\n     * Gets the base matrix (initial matrix which remains unchanged)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getBaseMatrix = function () {\r\n        return this._baseMatrix;\r\n    };\r\n    /**\r\n     * Gets the rest pose matrix\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getRestPose = function () {\r\n        return this._restPose;\r\n    };\r\n    /**\r\n     * Sets the rest pose matrix\r\n     * @param matrix the local-space rest pose to set for this bone\r\n     */\r\n    Bone.prototype.setRestPose = function (matrix) {\r\n        this._restPose.copyFrom(matrix);\r\n    };\r\n    /**\r\n     * Gets the bind pose matrix\r\n     * @returns the bind pose matrix\r\n     */\r\n    Bone.prototype.getBindPose = function () {\r\n        return this._bindPose;\r\n    };\r\n    /**\r\n     * Sets the bind pose matrix\r\n     * @param matrix the local-space bind pose to set for this bone\r\n     */\r\n    Bone.prototype.setBindPose = function (matrix) {\r\n        this._bindPose.copyFrom(matrix);\r\n    };\r\n    /**\r\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n     */\r\n    Bone.prototype.getWorldMatrix = function () {\r\n        return this._worldTransform;\r\n    };\r\n    /**\r\n     * Sets the local matrix to rest pose matrix\r\n     */\r\n    Bone.prototype.returnToRest = function () {\r\n        if (this._skeleton._numBonesWithLinkedTransformNode > 0) {\r\n            this.updateMatrix(this._restPose, false, false);\r\n        }\r\n        else {\r\n            this.updateMatrix(this._restPose, false, true);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the inverse of the absolute transform matrix.\r\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getInvertedAbsoluteTransform = function () {\r\n        return this._invertedAbsoluteTransform;\r\n    };\r\n    /**\r\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n     * @returns a matrix\r\n     */\r\n    Bone.prototype.getAbsoluteTransform = function () {\r\n        return this._absoluteTransform;\r\n    };\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is copied from the transform node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    Bone.prototype.linkTransformNode = function (transformNode) {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n        this._linkedTransformNode = transformNode;\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    };\r\n    // Properties (matches AbstractMesh properties)\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    Bone.prototype.getTransformNode = function () {\r\n        return this._linkedTransformNode;\r\n    };\r\n    Object.defineProperty(Bone.prototype, \"position\", {\r\n        /** Gets or sets current position (in local space) */\r\n        get: function () {\r\n            this._decompose();\r\n            return this._localPosition;\r\n        },\r\n        set: function (newPosition) {\r\n            this._decompose();\r\n            this._localPosition.copyFrom(newPosition);\r\n            this._markAsDirtyAndCompose();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"rotation\", {\r\n        /** Gets or sets current rotation (in local space) */\r\n        get: function () {\r\n            return this.getRotation();\r\n        },\r\n        set: function (newRotation) {\r\n            this.setRotation(newRotation);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\r\n        /** Gets or sets current rotation quaternion (in local space) */\r\n        get: function () {\r\n            this._decompose();\r\n            return this._localRotation;\r\n        },\r\n        set: function (newRotation) {\r\n            this.setRotationQuaternion(newRotation);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"scaling\", {\r\n        /** Gets or sets current scaling (in local space) */\r\n        get: function () {\r\n            return this.getScale();\r\n        },\r\n        set: function (newScaling) {\r\n            this.setScale(newScaling);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Bone.prototype, \"animationPropertiesOverride\", {\r\n        /**\r\n         * Gets the animation properties override\r\n         */\r\n        get: function () {\r\n            return this._skeleton.animationPropertiesOverride;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    Bone.prototype._decompose = function () {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n        this._needToDecompose = false;\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    };\r\n    Bone.prototype._compose = function () {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    };\r\n    /**\r\n     * Update the base and local matrices\r\n     * @param matrix defines the new base or local matrix\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     * @param updateLocalMatrix defines if the local matrix should be updated\r\n     */\r\n    Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix, updateLocalMatrix) {\r\n        if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\r\n        if (updateLocalMatrix === void 0) { updateLocalMatrix = true; }\r\n        this._baseMatrix.copyFrom(matrix);\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n        if (updateLocalMatrix) {\r\n            this._needToCompose = false; // in case there was a pending compose\r\n            this._localMatrix.copyFrom(matrix);\r\n            this._markAsDirtyAndDecompose();\r\n        }\r\n        else {\r\n            this.markAsDirty();\r\n        }\r\n    };\r\n    /** @hidden */\r\n    Bone.prototype._updateDifferenceMatrix = function (rootMatrix, updateChildren) {\r\n        if (updateChildren === void 0) { updateChildren = true; }\r\n        if (!rootMatrix) {\r\n            rootMatrix = this._baseMatrix;\r\n        }\r\n        if (this._parent) {\r\n            rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        }\r\n        else {\r\n            this._absoluteTransform.copyFrom(rootMatrix);\r\n        }\r\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\r\n        if (updateChildren) {\r\n            for (var index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateDifferenceMatrix();\r\n            }\r\n        }\r\n        this._scalingDeterminant = (this._absoluteTransform.determinant() < 0 ? -1 : 1);\r\n    };\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     */\r\n    Bone.prototype.markAsDirty = function () {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n    };\r\n    /** @hidden */\r\n    Bone.prototype._markAsDirtyAndCompose = function () {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    };\r\n    Bone.prototype._markAsDirtyAndDecompose = function () {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    };\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.translate = function (vec, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lm = this.getLocalMatrix();\r\n        if (space == Space.LOCAL) {\r\n            lm.addAtIndex(12, vec.x);\r\n            lm.addAtIndex(13, vec.y);\r\n            lm.addAtIndex(14, vec.z);\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            var tvec = Bone._tmpVecs[0];\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                }\r\n                else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n            }\r\n            else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n            tmat.setTranslationFromFloats(0, 0, 0);\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n            lm.addAtIndex(12, tvec.x);\r\n            lm.addAtIndex(13, tvec.y);\r\n            lm.addAtIndex(14, tvec.z);\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    /**\r\n     * Set the postion of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setPosition = function (position, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lm = this.getLocalMatrix();\r\n        if (space == Space.LOCAL) {\r\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            var vec = Bone._tmpVecs[0];\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                }\r\n                else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n                tmat.invert();\r\n            }\r\n            else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\r\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param mesh The mesh that this bone is attached to\r\n     */\r\n    Bone.prototype.setAbsolutePosition = function (position, mesh) {\r\n        this.setPosition(position, Space.WORLD, mesh);\r\n    };\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    Bone.prototype.scale = function (x, y, z, scaleChildren) {\r\n        if (scaleChildren === void 0) { scaleChildren = false; }\r\n        var locMat = this.getLocalMatrix();\r\n        // Apply new scaling on top of current local matrix\r\n        var scaleMat = Bone._tmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\r\n            var child = _a[_i];\r\n            var cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n        this._markAsDirtyAndDecompose();\r\n        if (scaleChildren) {\r\n            for (var _b = 0, _c = this.children; _b < _c.length; _b++) {\r\n                var child = _c[_b];\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    Bone.prototype.setScale = function (scale) {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    };\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    Bone.prototype.getScale = function () {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    };\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    Bone.prototype.getScaleToRef = function (result) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    };\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.rotate = function (axis, amount, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var rmat = Bone._tmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    Bone.prototype.setAxisAngle = function (axis, angle, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotation = function (rotation, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\r\n    };\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotationQuaternion = function (quat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n            this._markAsDirtyAndCompose();\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    };\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    Bone.prototype.setRotationMatrix = function (rotMat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n        var rotMat2 = Bone._tmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n        this._rotateWithMatrix(rotMat2, space, mesh);\r\n    };\r\n    Bone.prototype._rotateWithMatrix = function (rmat, space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var lmat = this.getLocalMatrix();\r\n        var lx = lmat.m[12];\r\n        var ly = lmat.m[13];\r\n        var lz = lmat.m[14];\r\n        var parent = this.getParent();\r\n        var parentScale = Bone._tmpMats[3];\r\n        var parentScaleInv = Bone._tmpMats[4];\r\n        if (parent && space == Space.WORLD) {\r\n            if (mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\r\n            }\r\n            else {\r\n                parentScale.copyFrom(parent.getAbsoluteTransform());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        }\r\n        else {\r\n            if (space == Space.WORLD && mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            }\r\n            else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n        this.computeAbsoluteTransforms();\r\n        this._markAsDirtyAndDecompose();\r\n    };\r\n    Bone.prototype._getNegativeRotationToRef = function (rotMatInv, mesh) {\r\n        var scaleMatrix = Bone._tmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh) {\r\n            rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);\r\n        }\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n        return true;\r\n    };\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @returns The position of the bone\r\n     */\r\n    Bone.prototype.getPosition = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var pos = Vector3.Zero();\r\n        this.getPositionToRef(space, mesh, pos);\r\n        return pos;\r\n    };\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    Bone.prototype.getPositionToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space == Space.LOCAL) {\r\n            var lm = this.getLocalMatrix();\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        }\r\n        else {\r\n            var wm = null;\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            if (mesh && wm) {\r\n                tmat.copyFrom(this.getAbsoluteTransform());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            }\r\n            else {\r\n                tmat = this.getAbsoluteTransform();\r\n            }\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    };\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The absolute position of the bone\r\n     */\r\n    Bone.prototype.getAbsolutePosition = function (mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var pos = Vector3.Zero();\r\n        this.getPositionToRef(Space.WORLD, mesh, pos);\r\n        return pos;\r\n    };\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    Bone.prototype.getAbsolutePositionToRef = function (mesh, result) {\r\n        this.getPositionToRef(Space.WORLD, mesh, result);\r\n    };\r\n    /**\r\n     * Compute the absolute transforms of this bone and its children\r\n     */\r\n    Bone.prototype.computeAbsoluteTransforms = function () {\r\n        this._compose();\r\n        if (this._parent) {\r\n            this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        }\r\n        else {\r\n            this._absoluteTransform.copyFrom(this._localMatrix);\r\n            var poseMatrix = this._skeleton.getPoseMatrix();\r\n            if (poseMatrix) {\r\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\r\n            }\r\n        }\r\n        var children = this.children;\r\n        var len = children.length;\r\n        for (var i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteTransforms();\r\n        }\r\n    };\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world direction\r\n     */\r\n    Bone.prototype.getDirection = function (localAxis, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getDirectionToRef(localAxis, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    Bone.prototype.getDirectionToRef = function (localAxis, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var mat = Bone._tmpMats[0];\r\n        mat.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n        result.normalize();\r\n    };\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The euler rotation\r\n     */\r\n    Bone.prototype.getRotation = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getRotationToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var quat = Bone._tmpQuat;\r\n        this.getRotationQuaternionToRef(space, mesh, quat);\r\n        quat.toEulerAnglesToRef(result);\r\n    };\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The quaternion rotation\r\n     */\r\n    Bone.prototype.getRotationQuaternion = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Quaternion.Identity();\r\n        this.getRotationQuaternionToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationQuaternionToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (mesh === void 0) { mesh = null; }\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        }\r\n        else {\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            }\r\n            else {\r\n                mat.copyFrom(amat);\r\n            }\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    };\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The rotation matrix\r\n     */\r\n    Bone.prototype.getRotationMatrix = function (space, mesh) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        var result = Matrix.Identity();\r\n        this.getRotationMatrixToRef(space, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    Bone.prototype.getRotationMatrixToRef = function (space, mesh, result) {\r\n        if (space === void 0) { space = Space.LOCAL; }\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        }\r\n        else {\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            }\r\n            else {\r\n                mat.copyFrom(amat);\r\n            }\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    };\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world position\r\n     */\r\n    Bone.prototype.getAbsolutePositionFromLocal = function (position, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getAbsolutePositionFromLocalToRef(position, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var tmat = Bone._tmpMats[0];\r\n        if (mesh && wm) {\r\n            tmat.copyFrom(this.getAbsoluteTransform());\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n        else {\r\n            tmat = this.getAbsoluteTransform();\r\n        }\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    };\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The local position\r\n     */\r\n    Bone.prototype.getLocalPositionFromAbsolute = function (position, mesh) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var result = Vector3.Zero();\r\n        this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\r\n        return result;\r\n    };\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, mesh, result) {\r\n        if (mesh === void 0) { mesh = null; }\r\n        var wm = null;\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n        this._skeleton.computeAbsoluteTransforms();\r\n        var tmat = Bone._tmpMats[0];\r\n        tmat.copyFrom(this.getAbsoluteTransform());\r\n        if (mesh && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n        tmat.invert();\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    };\r\n    /**\r\n     * Set the current local matrix as the restPose for this bone.\r\n     */\r\n    Bone.prototype.setCurrentPoseAsRest = function () {\r\n        this.setRestPose(this.getLocalMatrix());\r\n    };\r\n    Bone._tmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    Bone._tmpQuat = Quaternion.Identity();\r\n    Bone._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\r\n    return Bone;\r\n}(Node));\r\nexport { Bone };\r\n//# sourceMappingURL=bone.js.map","import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\r\nimport { PrecisionDate } from '../Misc/precisionDate';\r\nimport { Bone } from '../Bones/bone';\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nvar Animatable = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    function Animatable(scene, \r\n    /** defines the target object */\r\n    target, \r\n    /** defines the starting frame number (default is 0) */\r\n    fromFrame, \r\n    /** defines the ending frame number (default is 100) */\r\n    toFrame, \r\n    /** defines if the animation must loop (default is false)  */\r\n    loopAnimation, speedRatio, \r\n    /** defines a callback to call when animation ends if it is not looping */\r\n    onAnimationEnd, animations, \r\n    /** defines a callback to call when animation loops */\r\n    onAnimationLoop, \r\n    /** defines whether the animation should be evaluated additively */\r\n    isAdditive) {\r\n        if (fromFrame === void 0) { fromFrame = 0; }\r\n        if (toFrame === void 0) { toFrame = 100; }\r\n        if (loopAnimation === void 0) { loopAnimation = false; }\r\n        if (speedRatio === void 0) { speedRatio = 1.0; }\r\n        if (isAdditive === void 0) { isAdditive = false; }\r\n        this.target = target;\r\n        this.fromFrame = fromFrame;\r\n        this.toFrame = toFrame;\r\n        this.loopAnimation = loopAnimation;\r\n        this.onAnimationEnd = onAnimationEnd;\r\n        this.onAnimationLoop = onAnimationLoop;\r\n        this.isAdditive = isAdditive;\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n        this._runtimeAnimations = new Array();\r\n        this._paused = false;\r\n        this._speedRatio = 1;\r\n        this._weight = -1.0;\r\n        this._syncRoot = null;\r\n        /**\r\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n         * This will only apply for non looping animation (default is true)\r\n         */\r\n        this.disposeOnEnd = true;\r\n        /**\r\n         * Gets a boolean indicating if the animation has started\r\n         */\r\n        this.animationStarted = false;\r\n        /**\r\n         * Observer raised when the animation ends\r\n         */\r\n        this.onAnimationEndObservable = new Observable();\r\n        /**\r\n         * Observer raised when the animation loops\r\n         */\r\n        this.onAnimationLoopObservable = new Observable();\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n    Object.defineProperty(Animatable.prototype, \"syncRoot\", {\r\n        /**\r\n         * Gets the root Animatable used to synchronize and normalize animations\r\n         */\r\n        get: function () {\r\n            return this._syncRoot;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"masterFrame\", {\r\n        /**\r\n         * Gets the current frame of the first RuntimeAnimation\r\n         * Used to synchronize Animatables\r\n         */\r\n        get: function () {\r\n            if (this._runtimeAnimations.length === 0) {\r\n                return 0;\r\n            }\r\n            return this._runtimeAnimations[0].currentFrame;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"weight\", {\r\n        /**\r\n         * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n         */\r\n        get: function () {\r\n            return this._weight;\r\n        },\r\n        set: function (value) {\r\n            if (value === -1) { // -1 is ok and means no weight\r\n                this._weight = -1;\r\n                return;\r\n            }\r\n            // Else weight must be in [0, 1] range\r\n            this._weight = Math.min(Math.max(value, 0), 1.0);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Animatable.prototype, \"speedRatio\", {\r\n        /**\r\n         * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n         */\r\n        get: function () {\r\n            return this._speedRatio;\r\n        },\r\n        set: function (value) {\r\n            for (var index = 0; index < this._runtimeAnimations.length; index++) {\r\n                var animation = this._runtimeAnimations[index];\r\n                animation._prepareForSpeedRatioChange(value);\r\n            }\r\n            this._speedRatio = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with\r\n     * @returns the current Animatable\r\n     */\r\n    Animatable.prototype.syncWith = function (root) {\r\n        this._syncRoot = root;\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    Animatable.prototype.getAnimations = function () {\r\n        return this._runtimeAnimations;\r\n    };\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    Animatable.prototype.appendAnimations = function (target, animations) {\r\n        var _this = this;\r\n        for (var index = 0; index < animations.length; index++) {\r\n            var animation = animations[index];\r\n            var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = function () {\r\n                _this.onAnimationLoopObservable.notifyObservers(_this);\r\n                if (_this.onAnimationLoop) {\r\n                    _this.onAnimationLoop();\r\n                }\r\n            };\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    Animatable.prototype.getAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    Animatable.prototype.reset = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    };\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    Animatable.prototype.enableBlending = function (blendingSpeed) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    };\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    Animatable.prototype.disableBlending = function () {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    };\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    Animatable.prototype.goToFrame = function (frame) {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        if (runtimeAnimations[0]) {\r\n            var fps = runtimeAnimations[0].animation.framePerSecond;\r\n            var currentFrame = runtimeAnimations[0].currentFrame;\r\n            var delay = this.speedRatio === 0 ? 0 : ((frame - currentFrame) / fps * 1000) / this.speedRatio;\r\n            if (this._localDelayOffset === null) {\r\n                this._localDelayOffset = 0;\r\n            }\r\n            this._localDelayOffset -= delay;\r\n        }\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n    };\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    Animatable.prototype.pause = function () {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    };\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    Animatable.prototype.restart = function () {\r\n        this._paused = false;\r\n    };\r\n    Animatable.prototype._raiseOnAnimationEnd = function () {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    };\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    Animatable.prototype.stop = function (animationName, targetMask) {\r\n        if (animationName || targetMask) {\r\n            var idx = this._scene._activeAnimatables.indexOf(this);\r\n            if (idx > -1) {\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    var runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n                for (var index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fullfilled when the animation ends\r\n     */\r\n    Animatable.prototype.waitAsync = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.onAnimationEndObservable.add(function () {\r\n                resolve(_this);\r\n            }, undefined, undefined, _this, true);\r\n        });\r\n    };\r\n    /** @hidden */\r\n    Animatable.prototype._animate = function (delay) {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        }\r\n        else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n        if (this._weight === 0) { // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n        // Animating\r\n        var running = false;\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        var index;\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            var animation = runtimeAnimations[index];\r\n            var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n        this.animationStarted = running;\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n            this._raiseOnAnimationEnd();\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n        return running;\r\n    };\r\n    return Animatable;\r\n}());\r\nexport { Animatable };\r\nScene.prototype._animate = function () {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n    // Getting time\r\n    var now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n    var animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n    this._animationTime += this.deltaTime;\r\n    var animationTime = this._animationTime;\r\n    for (var index = 0; index < animatables.length; index++) {\r\n        var animatable = animatables[index];\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\r\n    if (weight === void 0) { weight = 1.0; }\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n    return returnedAnimatable;\r\n};\r\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n    var shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        var animatables = target.getAnimatables();\r\n        for (var index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n    animatable.reset();\r\n    return animatable;\r\n};\r\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\r\n    if (speedRatio === void 0) { speedRatio = 1.0; }\r\n    if (stopCurrent === void 0) { stopCurrent = true; }\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n        var child = children_1[_i];\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n    var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n    return animatable;\r\n};\r\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\r\n    if (isAdditive === void 0) { isAdditive = false; }\r\n    var children = target.getDescendants(directDescendantsOnly);\r\n    var result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\r\n        var child = children_2[_i];\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n    return result;\r\n};\r\nScene.prototype.getAnimatableByTarget = function (target) {\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n    return null;\r\n};\r\nScene.prototype.getAllAnimatablesByTarget = function (target) {\r\n    var result = [];\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\r\n    var animatables = this.getAllAnimatablesByTarget(target);\r\n    for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\r\n        var animatable = animatables_1[_i];\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function () {\r\n    if (this._activeAnimatables) {\r\n        for (var i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables = [];\r\n    }\r\n    for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\r\n        var group = _a[_i];\r\n        group.stop();\r\n    }\r\n};\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\r\n    var target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue\r\n        };\r\n    }\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    }\r\n    else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n    var normalizer = 1.0;\r\n    var finalPosition = TmpVectors.Vector3[0];\r\n    var finalScaling = TmpVectors.Vector3[1];\r\n    var finalQuaternion = TmpVectors.Quaternion[0];\r\n    var startIndex = 0;\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var scale = 1;\r\n    var skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            }\r\n            else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n        for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n            var scale = runtimeAnimation.weight / normalizer;\r\n            var currentPosition = TmpVectors.Vector3[2];\r\n            var currentScaling = TmpVectors.Vector3[3];\r\n            var currentQuaternion = TmpVectors.Quaternion[1];\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_1];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        var currentPosition = TmpVectors.Vector3[2];\r\n        var currentScaling = TmpVectors.Vector3[3];\r\n        var currentQuaternion = TmpVectors.Quaternion[1];\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n    var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n    var originalAnimation = holder.animations[0];\r\n    var originalValue = holder.originalValue;\r\n    var cumulativeQuaternion = refQuaternion;\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    }\r\n    else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    }\r\n    else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        var normalizer = 1.0;\r\n        var quaternions = void 0;\r\n        var weights = void 0;\r\n        if (holder.totalWeight < 1.0) {\r\n            var scale = 1.0 - holder.totalWeight;\r\n            quaternions = [];\r\n            weights = [];\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        }\r\n        else {\r\n            if (holder.animations.length === 2) { // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n        for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n        var cumulativeAmount = 0;\r\n        for (var index = 0; index < quaternions.length;) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n    // Add up the additive animations\r\n    for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex_2];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n    return cumulativeQuaternion;\r\n};\r\nScene.prototype._processLateAnimationBindings = function () {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        var target = this._registeredForLateAnimationBindings.data[index];\r\n        for (var path in target._lateAnimationHolders) {\r\n            var holder = target._lateAnimationHolders[path];\r\n            var originalAnimation = holder.animations[0];\r\n            var originalValue = holder.originalValue;\r\n            var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n            var finalValue = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            }\r\n            else {\r\n                var quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                }\r\n                else {\r\n                    var startIndex = 0;\r\n                    var normalizer = 1.0;\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        }\r\n                        else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        }\r\n                        else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    }\r\n                    else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        var scale_1 = originalAnimation.weight / normalizer;\r\n                        if (scale_1 !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale_1);\r\n                            }\r\n                            else {\r\n                                finalValue = originalAnimation.currentValue * scale_1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n                        startIndex = 1;\r\n                    }\r\n                    // Add up the override animations\r\n                    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        var runtimeAnimation = holder.animations[animIndex];\r\n                        var scale = runtimeAnimation.weight / normalizer;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                    // Add up the additive animations\r\n                    for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\r\n                        var runtimeAnimation = holder.additiveAnimations[animIndex_3];\r\n                        var scale = runtimeAnimation.weight;\r\n                        if (!scale) {\r\n                            continue;\r\n                        }\r\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        }\r\n                        else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\r\n    if (rescaleAsRequired === void 0) { rescaleAsRequired = false; }\r\n    if (skelDimensionsRatio === void 0) { skelDimensionsRatio = null; }\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n    // get animation info / verify there is such a range from the source bone\r\n    var sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    var from = sourceRange.from;\r\n    var to = sourceRange.to;\r\n    var sourceKeys = source.animations[0].getKeys();\r\n    // rescaling prep\r\n    var sourceBoneLength = source.length;\r\n    var sourceParent = source.getParent();\r\n    var parent = this.getParent();\r\n    var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n    var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n    var destKeys = this.animations[0].getKeys();\r\n    // loop vars declaration\r\n    var orig;\r\n    var origTranslation;\r\n    var mat;\r\n    for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                }\r\n                else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                }\r\n                else {\r\n                    mat = orig.value;\r\n                }\r\n            }\r\n            else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n//# sourceMappingURL=animatable.js.map","import { Vector3 } from '@babylonjs/core/Maths/math'\nimport { BoxBuilder } from '@babylonjs/core/Meshes/Builders/boxBuilder'\nimport { PlaneBuilder } from '@babylonjs/core/Meshes/Builders/planeBuilder'\nimport { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial'\n\nimport { Animation } from '@babylonjs/core/Animations/animation'\nimport { TransformNode } from '@babylonjs/core/Meshes/transformNode'\nimport { ArcRotateCamera } from '@babylonjs/core/Cameras/arcRotateCamera'\n\nimport '@babylonjs/core/Meshes/instancedMesh'\nimport '@babylonjs/core/Animations/animatable'\n\nconst THREE = [-1, 0, 1]\nconst HALF_PI = Math.PI / 2\n\nconst POINTS = [\n  [ 1, 0, 0],\n  [-1, 0, 0],\n  [0,  1, 0],\n  [0, -1, 0],\n  [0, 0, -1],\n  [0, 0,  1],\n]\n\nconst COLORS = [\n  [0, 0.3, 0.7],\n  [0, 0.6, 0.3],\n  [1, 1.0, 1.0],\n  [1, 0.8, 0.0],\n  [0.7, 0, 0.2],\n  [1, 0.3, 0.0],\n]\n\nconst ROTATIONS = [\n  [0, -HALF_PI, 0],\n  [0,  HALF_PI, 0],\n  [ HALF_PI, 0, 0],\n  [-HALF_PI, 0, 0],\n  [0, 0, 0],\n  [Math.PI, 0, 0],\n]\n\nconst animate = (...params) => new Promise((resolve) => {\n  Animation.CreateAndStartAnimation('', ...params).onAnimationEnd = resolve\n})\n\nexport const createCamera = (scene) => {\n  const camera = new ArcRotateCamera('', 0.4, 1.2, 7, Vector3.Zero(), scene)\n  camera.wheelPrecision = 100\n  camera.lowerRadiusLimit = 6\n  camera.upperRadiusLimit = 8\n  return camera\n}\n\nexport const createGeometry = (scene) => {\n  const baseCubie = BoxBuilder.CreateBox('', { size: 1 }, scene)\n  const cubies = THREE.flatMap((x) => THREE.flatMap((y) => THREE.map((z) => {\n    const c = baseCubie.createInstance('')\n    c.position.set(x, y, z)\n    return c\n  })))\n\n  for (const [i, normal] of POINTS.entries()) {\n    const temPlane = PlaneBuilder.CreatePlane('', { size: 0.9 }, scene)\n    temPlane.material = new StandardMaterial('', scene)\n    temPlane.material.ambientColor.set(...COLORS[i])\n    temPlane.isVisible = false\n\n    for (const cubie of cubies) {\n      const other = cubie.position.add(normal)\n      if (cubies.some((c) => c.position.equals(other))) continue\n      const p = temPlane.createInstance('')\n      p.parent = cubie\n      p.rotation.set(...ROTATIONS[i])\n      p.position.set(...normal).scaleInPlace(0.501)\n    }\n  }\n\n  const core = new Map(POINTS.map((p, face) => {\n    const axis = p.findIndex((i) => i)\n    const mult = HALF_PI * p[axis]\n    const coord = 'xyz'[axis]\n    const target = `rotation.${coord}`\n    const onFace = (c) => c.position.asArray().every((v, i) => !p[i] || p[i] === v)\n    const node = new TransformNode('', scene)\n    node.position.set(...p)\n    return ['FBUDLR'[face], async (turn, frames) => {\n      if (!turn) return\n      const angle = mult * turn\n      const toRotate = cubies.filter(onFace)\n      for (const c of toRotate) c.setParent(node)\n      if (frames) {\n        await animate(node, target, 60, frames, 0, angle, 0)\n      } else {\n        node.rotation[coord] = angle\n      }\n      for (const c of toRotate) {\n        c.setParent(null)\n        // round to avoid accumulating fp errors\n        c.position.set(...c.position.asArray().map((i) => Math.round(i)))\n        c.rotation.set(...c.rotation.asArray().map((i) => Math.round(i / HALF_PI) * HALF_PI))\n      }\n      node.rotation.set(0, 0, 0)\n    }]\n  }))\n\n  return (face, turn, frames = 0) => core.get(face)?.(turn, frames)\n}"],"names":["name","shader"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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"}